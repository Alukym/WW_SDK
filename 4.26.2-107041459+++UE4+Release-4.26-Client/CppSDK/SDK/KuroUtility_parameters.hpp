#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroUtility

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "KuroUtility_structs.hpp"


namespace SDK::Params
{

// Function KuroUtility.AsyncLoadState.AsyncLoadClass
// 0x0018 (0x0018 - 0x0000)
struct AsyncLoadState_AsyncLoadClass final
{
public:
	class FString                                 InPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                UserData;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncLoadState_AsyncLoadClass) == 0x000008, "Wrong alignment on AsyncLoadState_AsyncLoadClass");
static_assert(sizeof(AsyncLoadState_AsyncLoadClass) == 0x000018, "Wrong size on AsyncLoadState_AsyncLoadClass");
static_assert(offsetof(AsyncLoadState_AsyncLoadClass, InPath) == 0x000000, "Member 'AsyncLoadState_AsyncLoadClass::InPath' has a wrong offset!");
static_assert(offsetof(AsyncLoadState_AsyncLoadClass, UserData) == 0x000010, "Member 'AsyncLoadState_AsyncLoadClass::UserData' has a wrong offset!");

// Function KuroUtility.AsyncLoadState.AsyncLoadObject
// 0x0018 (0x0018 - 0x0000)
struct AsyncLoadState_AsyncLoadObject final
{
public:
	class FString                                 InPath;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                UserData;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncLoadState_AsyncLoadObject) == 0x000008, "Wrong alignment on AsyncLoadState_AsyncLoadObject");
static_assert(sizeof(AsyncLoadState_AsyncLoadObject) == 0x000018, "Wrong size on AsyncLoadState_AsyncLoadObject");
static_assert(offsetof(AsyncLoadState_AsyncLoadObject, InPath) == 0x000000, "Member 'AsyncLoadState_AsyncLoadObject::InPath' has a wrong offset!");
static_assert(offsetof(AsyncLoadState_AsyncLoadObject, UserData) == 0x000010, "Member 'AsyncLoadState_AsyncLoadObject::UserData' has a wrong offset!");

// Function KuroUtility.HoldPreloadObject.AddCommonAsset
// 0x0008 (0x0008 - 0x0000)
struct HoldPreloadObject_AddCommonAsset final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HoldPreloadObject_AddCommonAsset) == 0x000008, "Wrong alignment on HoldPreloadObject_AddCommonAsset");
static_assert(sizeof(HoldPreloadObject_AddCommonAsset) == 0x000008, "Wrong size on HoldPreloadObject_AddCommonAsset");
static_assert(offsetof(HoldPreloadObject_AddCommonAsset, InObject) == 0x000000, "Member 'HoldPreloadObject_AddCommonAsset::InObject' has a wrong offset!");

// Function KuroUtility.HoldPreloadObject.AddEntityAsset
// 0x0018 (0x0018 - 0x0000)
struct HoldPreloadObject_AddEntityAsset final
{
public:
	int32                                         EntityId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1989[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                InObject;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198A[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HoldPreloadObject_AddEntityAsset) == 0x000008, "Wrong alignment on HoldPreloadObject_AddEntityAsset");
static_assert(sizeof(HoldPreloadObject_AddEntityAsset) == 0x000018, "Wrong size on HoldPreloadObject_AddEntityAsset");
static_assert(offsetof(HoldPreloadObject_AddEntityAsset, EntityId) == 0x000000, "Member 'HoldPreloadObject_AddEntityAsset::EntityId' has a wrong offset!");
static_assert(offsetof(HoldPreloadObject_AddEntityAsset, InObject) == 0x000008, "Member 'HoldPreloadObject_AddEntityAsset::InObject' has a wrong offset!");
static_assert(offsetof(HoldPreloadObject_AddEntityAsset, ReturnValue) == 0x000010, "Member 'HoldPreloadObject_AddEntityAsset::ReturnValue' has a wrong offset!");

// Function KuroUtility.HoldPreloadObject.GetCommonAssetArray
// 0x0010 (0x0010 - 0x0000)
struct HoldPreloadObject_GetCommonAssetArray final
{
public:
	TArray<class UObject*>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(HoldPreloadObject_GetCommonAssetArray) == 0x000008, "Wrong alignment on HoldPreloadObject_GetCommonAssetArray");
static_assert(sizeof(HoldPreloadObject_GetCommonAssetArray) == 0x000010, "Wrong size on HoldPreloadObject_GetCommonAssetArray");
static_assert(offsetof(HoldPreloadObject_GetCommonAssetArray, ReturnValue) == 0x000000, "Member 'HoldPreloadObject_GetCommonAssetArray::ReturnValue' has a wrong offset!");

// Function KuroUtility.HoldPreloadObject.GetEntityAssetArray
// 0x0020 (0x0020 - 0x0000)
struct HoldPreloadObject_GetEntityAssetArray final
{
public:
	int32                                         EntityId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198B[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        OutAssets;                                         // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198C[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HoldPreloadObject_GetEntityAssetArray) == 0x000008, "Wrong alignment on HoldPreloadObject_GetEntityAssetArray");
static_assert(sizeof(HoldPreloadObject_GetEntityAssetArray) == 0x000020, "Wrong size on HoldPreloadObject_GetEntityAssetArray");
static_assert(offsetof(HoldPreloadObject_GetEntityAssetArray, EntityId) == 0x000000, "Member 'HoldPreloadObject_GetEntityAssetArray::EntityId' has a wrong offset!");
static_assert(offsetof(HoldPreloadObject_GetEntityAssetArray, OutAssets) == 0x000008, "Member 'HoldPreloadObject_GetEntityAssetArray::OutAssets' has a wrong offset!");
static_assert(offsetof(HoldPreloadObject_GetEntityAssetArray, ReturnValue) == 0x000018, "Member 'HoldPreloadObject_GetEntityAssetArray::ReturnValue' has a wrong offset!");

// Function KuroUtility.HoldPreloadObject.RemoveEntityAssets
// 0x0008 (0x0008 - 0x0000)
struct HoldPreloadObject_RemoveEntityAssets final
{
public:
	int32                                         EntityId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198D[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HoldPreloadObject_RemoveEntityAssets) == 0x000004, "Wrong alignment on HoldPreloadObject_RemoveEntityAssets");
static_assert(sizeof(HoldPreloadObject_RemoveEntityAssets) == 0x000008, "Wrong size on HoldPreloadObject_RemoveEntityAssets");
static_assert(offsetof(HoldPreloadObject_RemoveEntityAssets, EntityId) == 0x000000, "Member 'HoldPreloadObject_RemoveEntityAssets::EntityId' has a wrong offset!");
static_assert(offsetof(HoldPreloadObject_RemoveEntityAssets, ReturnValue) == 0x000004, "Member 'HoldPreloadObject_RemoveEntityAssets::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroActorComponent.EditorTickComponent
// 0x0004 (0x0004 - 0x0000)
struct KuroActorComponent_EditorTickComponent final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorComponent_EditorTickComponent) == 0x000004, "Wrong alignment on KuroActorComponent_EditorTickComponent");
static_assert(sizeof(KuroActorComponent_EditorTickComponent) == 0x000004, "Wrong size on KuroActorComponent_EditorTickComponent");
static_assert(offsetof(KuroActorComponent_EditorTickComponent, DeltaTime) == 0x000000, "Member 'KuroActorComponent_EditorTickComponent::DeltaTime' has a wrong offset!");

// Function KuroUtility.KuroActorManager.ClearAcquiredComponents
// 0x0010 (0x0010 - 0x0000)
struct KuroActorManager_ClearAcquiredComponents final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198E[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroActorManager_ClearAcquiredComponents) == 0x000008, "Wrong alignment on KuroActorManager_ClearAcquiredComponents");
static_assert(sizeof(KuroActorManager_ClearAcquiredComponents) == 0x000010, "Wrong size on KuroActorManager_ClearAcquiredComponents");
static_assert(offsetof(KuroActorManager_ClearAcquiredComponents, Actor) == 0x000000, "Member 'KuroActorManager_ClearAcquiredComponents::Actor' has a wrong offset!");
static_assert(offsetof(KuroActorManager_ClearAcquiredComponents, ReturnValue) == 0x000008, "Member 'KuroActorManager_ClearAcquiredComponents::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroActorManager.DestroyActor
// 0x0008 (0x0008 - 0x0000)
struct KuroActorManager_DestroyActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_DestroyActor) == 0x000008, "Wrong alignment on KuroActorManager_DestroyActor");
static_assert(sizeof(KuroActorManager_DestroyActor) == 0x000008, "Wrong size on KuroActorManager_DestroyActor");
static_assert(offsetof(KuroActorManager_DestroyActor, Actor) == 0x000000, "Member 'KuroActorManager_DestroyActor::Actor' has a wrong offset!");

// Function KuroUtility.KuroActorManager.GetAllAcquiredComponents
// 0x0018 (0x0018 - 0x0000)
struct KuroActorManager_GetAllAcquiredComponents final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_GetAllAcquiredComponents) == 0x000008, "Wrong alignment on KuroActorManager_GetAllAcquiredComponents");
static_assert(sizeof(KuroActorManager_GetAllAcquiredComponents) == 0x000018, "Wrong size on KuroActorManager_GetAllAcquiredComponents");
static_assert(offsetof(KuroActorManager_GetAllAcquiredComponents, Actor) == 0x000000, "Member 'KuroActorManager_GetAllAcquiredComponents::Actor' has a wrong offset!");
static_assert(offsetof(KuroActorManager_GetAllAcquiredComponents, ReturnValue) == 0x000008, "Member 'KuroActorManager_GetAllAcquiredComponents::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroActorManager.GetResourceSizeBytes
// 0x0010 (0x0010 - 0x0000)
struct KuroActorManager_GetResourceSizeBytes final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExclusive;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198F[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_GetResourceSizeBytes) == 0x000008, "Wrong alignment on KuroActorManager_GetResourceSizeBytes");
static_assert(sizeof(KuroActorManager_GetResourceSizeBytes) == 0x000010, "Wrong size on KuroActorManager_GetResourceSizeBytes");
static_assert(offsetof(KuroActorManager_GetResourceSizeBytes, Actor) == 0x000000, "Member 'KuroActorManager_GetResourceSizeBytes::Actor' has a wrong offset!");
static_assert(offsetof(KuroActorManager_GetResourceSizeBytes, IsExclusive) == 0x000008, "Member 'KuroActorManager_GetResourceSizeBytes::IsExclusive' has a wrong offset!");
static_assert(offsetof(KuroActorManager_GetResourceSizeBytes, ReturnValue) == 0x00000C, "Member 'KuroActorManager_GetResourceSizeBytes::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroActorManager.IsActorPoolEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroActorManager_IsActorPoolEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_IsActorPoolEnable) == 0x000001, "Wrong alignment on KuroActorManager_IsActorPoolEnable");
static_assert(sizeof(KuroActorManager_IsActorPoolEnable) == 0x000001, "Wrong size on KuroActorManager_IsActorPoolEnable");
static_assert(offsetof(KuroActorManager_IsActorPoolEnable, ReturnValue) == 0x000000, "Member 'KuroActorManager_IsActorPoolEnable::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroActorManager.IsPooledActor
// 0x0010 (0x0010 - 0x0000)
struct KuroActorManager_IsPooledActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1990[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroActorManager_IsPooledActor) == 0x000008, "Wrong alignment on KuroActorManager_IsPooledActor");
static_assert(sizeof(KuroActorManager_IsPooledActor) == 0x000010, "Wrong size on KuroActorManager_IsPooledActor");
static_assert(offsetof(KuroActorManager_IsPooledActor, Actor) == 0x000000, "Member 'KuroActorManager_IsPooledActor::Actor' has a wrong offset!");
static_assert(offsetof(KuroActorManager_IsPooledActor, ReturnValue) == 0x000008, "Member 'KuroActorManager_IsPooledActor::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroActorManager.RegisterActorSkipProperties
// 0x0018 (0x0018 - 0x0000)
struct KuroActorManager_RegisterActorSkipProperties final
{
public:
	class UClass*                                 Param_Class;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPropertyPair>                  Properties;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_RegisterActorSkipProperties) == 0x000008, "Wrong alignment on KuroActorManager_RegisterActorSkipProperties");
static_assert(sizeof(KuroActorManager_RegisterActorSkipProperties) == 0x000018, "Wrong size on KuroActorManager_RegisterActorSkipProperties");
static_assert(offsetof(KuroActorManager_RegisterActorSkipProperties, Param_Class) == 0x000000, "Member 'KuroActorManager_RegisterActorSkipProperties::Param_Class' has a wrong offset!");
static_assert(offsetof(KuroActorManager_RegisterActorSkipProperties, Properties) == 0x000008, "Member 'KuroActorManager_RegisterActorSkipProperties::Properties' has a wrong offset!");

// Function KuroUtility.KuroActorManager.ResetActorToDefault
// 0x0010 (0x0010 - 0x0000)
struct KuroActorManager_ResetActorToDefault final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1991[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroActorManager_ResetActorToDefault) == 0x000008, "Wrong alignment on KuroActorManager_ResetActorToDefault");
static_assert(sizeof(KuroActorManager_ResetActorToDefault) == 0x000010, "Wrong size on KuroActorManager_ResetActorToDefault");
static_assert(offsetof(KuroActorManager_ResetActorToDefault, Actor) == 0x000000, "Member 'KuroActorManager_ResetActorToDefault::Actor' has a wrong offset!");
static_assert(offsetof(KuroActorManager_ResetActorToDefault, ReturnValue) == 0x000008, "Member 'KuroActorManager_ResetActorToDefault::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroActorManager.ResetDelegates
// 0x0008 (0x0008 - 0x0000)
struct KuroActorManager_ResetDelegates final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_ResetDelegates) == 0x000008, "Wrong alignment on KuroActorManager_ResetDelegates");
static_assert(sizeof(KuroActorManager_ResetDelegates) == 0x000008, "Wrong size on KuroActorManager_ResetDelegates");
static_assert(offsetof(KuroActorManager_ResetDelegates, Actor) == 0x000000, "Member 'KuroActorManager_ResetDelegates::Actor' has a wrong offset!");

// Function KuroUtility.KuroActorManager.ResetUberGraph
// 0x0008 (0x0008 - 0x0000)
struct KuroActorManager_ResetUberGraph final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_ResetUberGraph) == 0x000008, "Wrong alignment on KuroActorManager_ResetUberGraph");
static_assert(sizeof(KuroActorManager_ResetUberGraph) == 0x000008, "Wrong size on KuroActorManager_ResetUberGraph");
static_assert(offsetof(KuroActorManager_ResetUberGraph, Obj) == 0x000000, "Member 'KuroActorManager_ResetUberGraph::Obj' has a wrong offset!");

// Function KuroUtility.KuroActorManager.ResetUObjectByCDO
// 0x0008 (0x0008 - 0x0000)
struct KuroActorManager_ResetUObjectByCDO final
{
public:
	class UObject*                                Obj;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_ResetUObjectByCDO) == 0x000008, "Wrong alignment on KuroActorManager_ResetUObjectByCDO");
static_assert(sizeof(KuroActorManager_ResetUObjectByCDO) == 0x000008, "Wrong size on KuroActorManager_ResetUObjectByCDO");
static_assert(offsetof(KuroActorManager_ResetUObjectByCDO, Obj) == 0x000000, "Member 'KuroActorManager_ResetUObjectByCDO::Obj' has a wrong offset!");

// Function KuroUtility.KuroActorManager.SpawnActor
// 0x0070 (0x0070 - 0x0000)
struct KuroActorManager_SpawnActor final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingOverride;                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1992[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAsPoolActor;                                      // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1993[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1994[0x8];                                     // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroActorManager_SpawnActor) == 0x000010, "Wrong alignment on KuroActorManager_SpawnActor");
static_assert(sizeof(KuroActorManager_SpawnActor) == 0x000070, "Wrong size on KuroActorManager_SpawnActor");
static_assert(offsetof(KuroActorManager_SpawnActor, WorldContextObject) == 0x000000, "Member 'KuroActorManager_SpawnActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroActorManager_SpawnActor, ActorClass) == 0x000008, "Member 'KuroActorManager_SpawnActor::ActorClass' has a wrong offset!");
static_assert(offsetof(KuroActorManager_SpawnActor, SpawnTransform) == 0x000010, "Member 'KuroActorManager_SpawnActor::SpawnTransform' has a wrong offset!");
static_assert(offsetof(KuroActorManager_SpawnActor, CollisionHandlingOverride) == 0x000040, "Member 'KuroActorManager_SpawnActor::CollisionHandlingOverride' has a wrong offset!");
static_assert(offsetof(KuroActorManager_SpawnActor, Owner) == 0x000048, "Member 'KuroActorManager_SpawnActor::Owner' has a wrong offset!");
static_assert(offsetof(KuroActorManager_SpawnActor, Instigator) == 0x000050, "Member 'KuroActorManager_SpawnActor::Instigator' has a wrong offset!");
static_assert(offsetof(KuroActorManager_SpawnActor, bAsPoolActor) == 0x000058, "Member 'KuroActorManager_SpawnActor::bAsPoolActor' has a wrong offset!");
static_assert(offsetof(KuroActorManager_SpawnActor, ReturnValue) == 0x000060, "Member 'KuroActorManager_SpawnActor::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroActorManager.UnregisterComponent
// 0x0008 (0x0008 - 0x0000)
struct KuroActorManager_UnregisterComponent final
{
public:
	class UActorComponent*                        Componet;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroActorManager_UnregisterComponent) == 0x000008, "Wrong alignment on KuroActorManager_UnregisterComponent");
static_assert(sizeof(KuroActorManager_UnregisterComponent) == 0x000008, "Wrong size on KuroActorManager_UnregisterComponent");
static_assert(offsetof(KuroActorManager_UnregisterComponent, Componet) == 0x000000, "Member 'KuroActorManager_UnregisterComponent::Componet' has a wrong offset!");

// Function KuroUtility.KuroApplicationLibrary.AddApplicationLifetimeDelegate
// 0x0018 (0x0018 - 0x0000)
struct KuroApplicationLibrary_AddApplicationLifetimeDelegate final
{
public:
	TDelegate<void(int32 Type)>                   InDelegate;                                        // 0x0000(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1995[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroApplicationLibrary_AddApplicationLifetimeDelegate) == 0x000004, "Wrong alignment on KuroApplicationLibrary_AddApplicationLifetimeDelegate");
static_assert(sizeof(KuroApplicationLibrary_AddApplicationLifetimeDelegate) == 0x000018, "Wrong size on KuroApplicationLibrary_AddApplicationLifetimeDelegate");
static_assert(offsetof(KuroApplicationLibrary_AddApplicationLifetimeDelegate, InDelegate) == 0x000000, "Member 'KuroApplicationLibrary_AddApplicationLifetimeDelegate::InDelegate' has a wrong offset!");
static_assert(offsetof(KuroApplicationLibrary_AddApplicationLifetimeDelegate, ReturnValue) == 0x000014, "Member 'KuroApplicationLibrary_AddApplicationLifetimeDelegate::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroApplicationLibrary.AddEditorPreEndPIEDelegate
// 0x0018 (0x0018 - 0x0000)
struct KuroApplicationLibrary_AddEditorPreEndPIEDelegate final
{
public:
	TDelegate<void(bool bSimulateInEditor)>       InDelegate;                                        // 0x0000(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1996[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroApplicationLibrary_AddEditorPreEndPIEDelegate) == 0x000004, "Wrong alignment on KuroApplicationLibrary_AddEditorPreEndPIEDelegate");
static_assert(sizeof(KuroApplicationLibrary_AddEditorPreEndPIEDelegate) == 0x000018, "Wrong size on KuroApplicationLibrary_AddEditorPreEndPIEDelegate");
static_assert(offsetof(KuroApplicationLibrary_AddEditorPreEndPIEDelegate, InDelegate) == 0x000000, "Member 'KuroApplicationLibrary_AddEditorPreEndPIEDelegate::InDelegate' has a wrong offset!");
static_assert(offsetof(KuroApplicationLibrary_AddEditorPreEndPIEDelegate, ReturnValue) == 0x000014, "Member 'KuroApplicationLibrary_AddEditorPreEndPIEDelegate::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroApplicationLibrary.Test
// 0x0008 (0x0008 - 0x0000)
struct KuroApplicationLibrary_Test final
{
public:
	int32                                         Type;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1997[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroApplicationLibrary_Test) == 0x000004, "Wrong alignment on KuroApplicationLibrary_Test");
static_assert(sizeof(KuroApplicationLibrary_Test) == 0x000008, "Wrong size on KuroApplicationLibrary_Test");
static_assert(offsetof(KuroApplicationLibrary_Test, Type) == 0x000000, "Member 'KuroApplicationLibrary_Test::Type' has a wrong offset!");
static_assert(offsetof(KuroApplicationLibrary_Test, ReturnValue) == 0x000004, "Member 'KuroApplicationLibrary_Test::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroApplicationLibrary.UnBind
// 0x0001 (0x0001 - 0x0000)
struct KuroApplicationLibrary_UnBind final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroApplicationLibrary_UnBind) == 0x000001, "Wrong alignment on KuroApplicationLibrary_UnBind");
static_assert(sizeof(KuroApplicationLibrary_UnBind) == 0x000001, "Wrong size on KuroApplicationLibrary_UnBind");
static_assert(offsetof(KuroApplicationLibrary_UnBind, ReturnValue) == 0x000000, "Member 'KuroApplicationLibrary_UnBind::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroCollectActorComponent.GetActorWithTag
// 0x0018 (0x0018 - 0x0000)
struct KuroCollectActorComponent_GetActorWithTag final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollectActorType                             Type;                                              // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199A[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCollectActorComponent_GetActorWithTag) == 0x000008, "Wrong alignment on KuroCollectActorComponent_GetActorWithTag");
static_assert(sizeof(KuroCollectActorComponent_GetActorWithTag) == 0x000018, "Wrong size on KuroCollectActorComponent_GetActorWithTag");
static_assert(offsetof(KuroCollectActorComponent_GetActorWithTag, Tag) == 0x000000, "Member 'KuroCollectActorComponent_GetActorWithTag::Tag' has a wrong offset!");
static_assert(offsetof(KuroCollectActorComponent_GetActorWithTag, Type) == 0x00000C, "Member 'KuroCollectActorComponent_GetActorWithTag::Type' has a wrong offset!");
static_assert(offsetof(KuroCollectActorComponent_GetActorWithTag, ReturnValue) == 0x000010, "Member 'KuroCollectActorComponent_GetActorWithTag::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroCompressLibrary.CompressFileOrFolder
// 0x0068 (0x0068 - 0x0000)
struct KuroCompressLibrary_CompressFileOrFolder final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DestPath;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Rate)>                   OnProgress;                                        // 0x0020(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(TArray<class FString>& SuccessedPaths)> OnCompressComplete;                                // 0x0034(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFail;                                            // 0x0048(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_199B[0x4];                                     // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MaxSingleFileReadSize;                             // 0x0060(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCompressLibrary_CompressFileOrFolder) == 0x000008, "Wrong alignment on KuroCompressLibrary_CompressFileOrFolder");
static_assert(sizeof(KuroCompressLibrary_CompressFileOrFolder) == 0x000068, "Wrong size on KuroCompressLibrary_CompressFileOrFolder");
static_assert(offsetof(KuroCompressLibrary_CompressFileOrFolder, Path) == 0x000000, "Member 'KuroCompressLibrary_CompressFileOrFolder::Path' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFileOrFolder, DestPath) == 0x000010, "Member 'KuroCompressLibrary_CompressFileOrFolder::DestPath' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFileOrFolder, OnProgress) == 0x000020, "Member 'KuroCompressLibrary_CompressFileOrFolder::OnProgress' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFileOrFolder, OnCompressComplete) == 0x000034, "Member 'KuroCompressLibrary_CompressFileOrFolder::OnCompressComplete' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFileOrFolder, OnFail) == 0x000048, "Member 'KuroCompressLibrary_CompressFileOrFolder::OnFail' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFileOrFolder, MaxSingleFileReadSize) == 0x000060, "Member 'KuroCompressLibrary_CompressFileOrFolder::MaxSingleFileReadSize' has a wrong offset!");

// Function KuroUtility.KuroCompressLibrary.CompressFilesOrFoldersAsync
// 0x0068 (0x0068 - 0x0000)
struct KuroCompressLibrary_CompressFilesOrFoldersAsync final
{
public:
	TArray<class FString>                         Paths;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 DestPath;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Rate)>                   OnProgress;                                        // 0x0020(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(TArray<class FString>& SuccessedPaths)> OnCompressComplete;                                // 0x0034(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnFail;                                            // 0x0048(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAutoIncludeFilesUnderFolder;                      // 0x005C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199C[0x3];                                     // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MaxSingleFileReadSize;                             // 0x0060(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCompressLibrary_CompressFilesOrFoldersAsync) == 0x000008, "Wrong alignment on KuroCompressLibrary_CompressFilesOrFoldersAsync");
static_assert(sizeof(KuroCompressLibrary_CompressFilesOrFoldersAsync) == 0x000068, "Wrong size on KuroCompressLibrary_CompressFilesOrFoldersAsync");
static_assert(offsetof(KuroCompressLibrary_CompressFilesOrFoldersAsync, Paths) == 0x000000, "Member 'KuroCompressLibrary_CompressFilesOrFoldersAsync::Paths' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFilesOrFoldersAsync, DestPath) == 0x000010, "Member 'KuroCompressLibrary_CompressFilesOrFoldersAsync::DestPath' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFilesOrFoldersAsync, OnProgress) == 0x000020, "Member 'KuroCompressLibrary_CompressFilesOrFoldersAsync::OnProgress' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFilesOrFoldersAsync, OnCompressComplete) == 0x000034, "Member 'KuroCompressLibrary_CompressFilesOrFoldersAsync::OnCompressComplete' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFilesOrFoldersAsync, OnFail) == 0x000048, "Member 'KuroCompressLibrary_CompressFilesOrFoldersAsync::OnFail' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFilesOrFoldersAsync, bAutoIncludeFilesUnderFolder) == 0x00005C, "Member 'KuroCompressLibrary_CompressFilesOrFoldersAsync::bAutoIncludeFilesUnderFolder' has a wrong offset!");
static_assert(offsetof(KuroCompressLibrary_CompressFilesOrFoldersAsync, MaxSingleFileReadSize) == 0x000060, "Member 'KuroCompressLibrary_CompressFilesOrFoldersAsync::MaxSingleFileReadSize' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.BitwiseLeftShift
// 0x0018 (0x0018 - 0x0000)
struct KuroMathLibrary_BitwiseLeftShift final
{
public:
	int64                                         Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bit;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199E[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_BitwiseLeftShift) == 0x000008, "Wrong alignment on KuroMathLibrary_BitwiseLeftShift");
static_assert(sizeof(KuroMathLibrary_BitwiseLeftShift) == 0x000018, "Wrong size on KuroMathLibrary_BitwiseLeftShift");
static_assert(offsetof(KuroMathLibrary_BitwiseLeftShift, Source) == 0x000000, "Member 'KuroMathLibrary_BitwiseLeftShift::Source' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_BitwiseLeftShift, Bit) == 0x000008, "Member 'KuroMathLibrary_BitwiseLeftShift::Bit' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_BitwiseLeftShift, ReturnValue) == 0x000010, "Member 'KuroMathLibrary_BitwiseLeftShift::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.BitwiseRightShift
// 0x0018 (0x0018 - 0x0000)
struct KuroMathLibrary_BitwiseRightShift final
{
public:
	int64                                         Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bit;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199F[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_BitwiseRightShift) == 0x000008, "Wrong alignment on KuroMathLibrary_BitwiseRightShift");
static_assert(sizeof(KuroMathLibrary_BitwiseRightShift) == 0x000018, "Wrong size on KuroMathLibrary_BitwiseRightShift");
static_assert(offsetof(KuroMathLibrary_BitwiseRightShift, Source) == 0x000000, "Member 'KuroMathLibrary_BitwiseRightShift::Source' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_BitwiseRightShift, Bit) == 0x000008, "Member 'KuroMathLibrary_BitwiseRightShift::Bit' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_BitwiseRightShift, ReturnValue) == 0x000010, "Member 'KuroMathLibrary_BitwiseRightShift::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.IntBitwiseAnd
// 0x000C (0x000C - 0x0000)
struct KuroMathLibrary_IntBitwiseAnd final
{
public:
	int32                                         Num1;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num2;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_IntBitwiseAnd) == 0x000004, "Wrong alignment on KuroMathLibrary_IntBitwiseAnd");
static_assert(sizeof(KuroMathLibrary_IntBitwiseAnd) == 0x00000C, "Wrong size on KuroMathLibrary_IntBitwiseAnd");
static_assert(offsetof(KuroMathLibrary_IntBitwiseAnd, Num1) == 0x000000, "Member 'KuroMathLibrary_IntBitwiseAnd::Num1' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_IntBitwiseAnd, Num2) == 0x000004, "Member 'KuroMathLibrary_IntBitwiseAnd::Num2' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_IntBitwiseAnd, ReturnValue) == 0x000008, "Member 'KuroMathLibrary_IntBitwiseAnd::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.IntBitwiseNot
// 0x0008 (0x0008 - 0x0000)
struct KuroMathLibrary_IntBitwiseNot final
{
public:
	int32                                         Num;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_IntBitwiseNot) == 0x000004, "Wrong alignment on KuroMathLibrary_IntBitwiseNot");
static_assert(sizeof(KuroMathLibrary_IntBitwiseNot) == 0x000008, "Wrong size on KuroMathLibrary_IntBitwiseNot");
static_assert(offsetof(KuroMathLibrary_IntBitwiseNot, Num) == 0x000000, "Member 'KuroMathLibrary_IntBitwiseNot::Num' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_IntBitwiseNot, ReturnValue) == 0x000004, "Member 'KuroMathLibrary_IntBitwiseNot::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.IntBitwiseOr
// 0x000C (0x000C - 0x0000)
struct KuroMathLibrary_IntBitwiseOr final
{
public:
	int32                                         Num1;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num2;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_IntBitwiseOr) == 0x000004, "Wrong alignment on KuroMathLibrary_IntBitwiseOr");
static_assert(sizeof(KuroMathLibrary_IntBitwiseOr) == 0x00000C, "Wrong size on KuroMathLibrary_IntBitwiseOr");
static_assert(offsetof(KuroMathLibrary_IntBitwiseOr, Num1) == 0x000000, "Member 'KuroMathLibrary_IntBitwiseOr::Num1' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_IntBitwiseOr, Num2) == 0x000004, "Member 'KuroMathLibrary_IntBitwiseOr::Num2' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_IntBitwiseOr, ReturnValue) == 0x000008, "Member 'KuroMathLibrary_IntBitwiseOr::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.IntBitwiseXOr
// 0x000C (0x000C - 0x0000)
struct KuroMathLibrary_IntBitwiseXOr final
{
public:
	int32                                         Num1;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num2;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_IntBitwiseXOr) == 0x000004, "Wrong alignment on KuroMathLibrary_IntBitwiseXOr");
static_assert(sizeof(KuroMathLibrary_IntBitwiseXOr) == 0x00000C, "Wrong size on KuroMathLibrary_IntBitwiseXOr");
static_assert(offsetof(KuroMathLibrary_IntBitwiseXOr, Num1) == 0x000000, "Member 'KuroMathLibrary_IntBitwiseXOr::Num1' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_IntBitwiseXOr, Num2) == 0x000004, "Member 'KuroMathLibrary_IntBitwiseXOr::Num2' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_IntBitwiseXOr, ReturnValue) == 0x000008, "Member 'KuroMathLibrary_IntBitwiseXOr::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.KuroStringToInt64
// 0x0018 (0x0018 - 0x0000)
struct KuroMathLibrary_KuroStringToInt64 final
{
public:
	class FString                                 StringNum;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_KuroStringToInt64) == 0x000008, "Wrong alignment on KuroMathLibrary_KuroStringToInt64");
static_assert(sizeof(KuroMathLibrary_KuroStringToInt64) == 0x000018, "Wrong size on KuroMathLibrary_KuroStringToInt64");
static_assert(offsetof(KuroMathLibrary_KuroStringToInt64, StringNum) == 0x000000, "Member 'KuroMathLibrary_KuroStringToInt64::StringNum' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_KuroStringToInt64, ReturnValue) == 0x000010, "Member 'KuroMathLibrary_KuroStringToInt64::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.LongBitwiseAnd
// 0x0018 (0x0018 - 0x0000)
struct KuroMathLibrary_LongBitwiseAnd final
{
public:
	int64                                         Num1;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Num2;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_LongBitwiseAnd) == 0x000008, "Wrong alignment on KuroMathLibrary_LongBitwiseAnd");
static_assert(sizeof(KuroMathLibrary_LongBitwiseAnd) == 0x000018, "Wrong size on KuroMathLibrary_LongBitwiseAnd");
static_assert(offsetof(KuroMathLibrary_LongBitwiseAnd, Num1) == 0x000000, "Member 'KuroMathLibrary_LongBitwiseAnd::Num1' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_LongBitwiseAnd, Num2) == 0x000008, "Member 'KuroMathLibrary_LongBitwiseAnd::Num2' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_LongBitwiseAnd, ReturnValue) == 0x000010, "Member 'KuroMathLibrary_LongBitwiseAnd::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.LongBitwiseNot
// 0x0010 (0x0010 - 0x0000)
struct KuroMathLibrary_LongBitwiseNot final
{
public:
	int64                                         Num;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_LongBitwiseNot) == 0x000008, "Wrong alignment on KuroMathLibrary_LongBitwiseNot");
static_assert(sizeof(KuroMathLibrary_LongBitwiseNot) == 0x000010, "Wrong size on KuroMathLibrary_LongBitwiseNot");
static_assert(offsetof(KuroMathLibrary_LongBitwiseNot, Num) == 0x000000, "Member 'KuroMathLibrary_LongBitwiseNot::Num' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_LongBitwiseNot, ReturnValue) == 0x000008, "Member 'KuroMathLibrary_LongBitwiseNot::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.LongBitwiseOr
// 0x0018 (0x0018 - 0x0000)
struct KuroMathLibrary_LongBitwiseOr final
{
public:
	int64                                         Num1;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Num2;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_LongBitwiseOr) == 0x000008, "Wrong alignment on KuroMathLibrary_LongBitwiseOr");
static_assert(sizeof(KuroMathLibrary_LongBitwiseOr) == 0x000018, "Wrong size on KuroMathLibrary_LongBitwiseOr");
static_assert(offsetof(KuroMathLibrary_LongBitwiseOr, Num1) == 0x000000, "Member 'KuroMathLibrary_LongBitwiseOr::Num1' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_LongBitwiseOr, Num2) == 0x000008, "Member 'KuroMathLibrary_LongBitwiseOr::Num2' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_LongBitwiseOr, ReturnValue) == 0x000010, "Member 'KuroMathLibrary_LongBitwiseOr::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.LongBitwiseXOr
// 0x0018 (0x0018 - 0x0000)
struct KuroMathLibrary_LongBitwiseXOr final
{
public:
	int64                                         Num1;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         Num2;                                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_LongBitwiseXOr) == 0x000008, "Wrong alignment on KuroMathLibrary_LongBitwiseXOr");
static_assert(sizeof(KuroMathLibrary_LongBitwiseXOr) == 0x000018, "Wrong size on KuroMathLibrary_LongBitwiseXOr");
static_assert(offsetof(KuroMathLibrary_LongBitwiseXOr, Num1) == 0x000000, "Member 'KuroMathLibrary_LongBitwiseXOr::Num1' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_LongBitwiseXOr, Num2) == 0x000008, "Member 'KuroMathLibrary_LongBitwiseXOr::Num2' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_LongBitwiseXOr, ReturnValue) == 0x000010, "Member 'KuroMathLibrary_LongBitwiseXOr::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.Max
// 0x0018 (0x0018 - 0x0000)
struct KuroMathLibrary_Max final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_Max) == 0x000004, "Wrong alignment on KuroMathLibrary_Max");
static_assert(sizeof(KuroMathLibrary_Max) == 0x000018, "Wrong size on KuroMathLibrary_Max");
static_assert(offsetof(KuroMathLibrary_Max, A) == 0x000000, "Member 'KuroMathLibrary_Max::A' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_Max, B) == 0x000008, "Member 'KuroMathLibrary_Max::B' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_Max, ReturnValue) == 0x000010, "Member 'KuroMathLibrary_Max::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMathLibrary.Min
// 0x0018 (0x0018 - 0x0000)
struct KuroMathLibrary_Min final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMathLibrary_Min) == 0x000004, "Wrong alignment on KuroMathLibrary_Min");
static_assert(sizeof(KuroMathLibrary_Min) == 0x000018, "Wrong size on KuroMathLibrary_Min");
static_assert(offsetof(KuroMathLibrary_Min, A) == 0x000000, "Member 'KuroMathLibrary_Min::A' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_Min, B) == 0x000008, "Member 'KuroMathLibrary_Min::B' has a wrong offset!");
static_assert(offsetof(KuroMathLibrary_Min, ReturnValue) == 0x000010, "Member 'KuroMathLibrary_Min::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMeshTextureFunctionLibrary.HandleSkeletalMeshComponentStreaming
// 0x0010 (0x0010 - 0x0000)
struct KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartForceStreamIn;                               // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A0[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming) == 0x000008, "Wrong alignment on KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming");
static_assert(sizeof(KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming) == 0x000010, "Wrong size on KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming");
static_assert(offsetof(KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming, SkeletalMesh) == 0x000000, "Member 'KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming, bStartForceStreamIn) == 0x000008, "Member 'KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming::bStartForceStreamIn' has a wrong offset!");

// Function KuroUtility.KuroMeshTextureFunctionLibrary.IsSkeletalMeshComponentStreamingComplete
// 0x0010 (0x0010 - 0x0000)
struct KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A1[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete) == 0x000008, "Wrong alignment on KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete");
static_assert(sizeof(KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete) == 0x000010, "Wrong size on KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete");
static_assert(offsetof(KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete, SkeletalMesh) == 0x000000, "Member 'KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete, ReturnValue) == 0x000008, "Member 'KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroMeshTextureFunctionLibrary.IsStaticMeshComponentStreamingComplete
// 0x0010 (0x0010 - 0x0000)
struct KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A2[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete) == 0x000008, "Wrong alignment on KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete");
static_assert(sizeof(KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete) == 0x000010, "Wrong size on KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete");
static_assert(offsetof(KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete, StaticMesh) == 0x000000, "Member 'KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete::StaticMesh' has a wrong offset!");
static_assert(offsetof(KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete, ReturnValue) == 0x000008, "Member 'KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroPhysicsLibrary.GetHitPoint
// 0x0038 (0x0038 - 0x0000)
struct KuroPhysicsLibrary_GetHitPoint final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    TraceComp;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroHitResult*                         HitResult;                                         // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawDuration;                                      // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceTrace;                                        // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0035(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A3[0x2];                                     // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroPhysicsLibrary_GetHitPoint) == 0x000008, "Wrong alignment on KuroPhysicsLibrary_GetHitPoint");
static_assert(sizeof(KuroPhysicsLibrary_GetHitPoint) == 0x000038, "Wrong size on KuroPhysicsLibrary_GetHitPoint");
static_assert(offsetof(KuroPhysicsLibrary_GetHitPoint, StartLocation) == 0x000000, "Member 'KuroPhysicsLibrary_GetHitPoint::StartLocation' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetHitPoint, EndLocation) == 0x00000C, "Member 'KuroPhysicsLibrary_GetHitPoint::EndLocation' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetHitPoint, Actor) == 0x000018, "Member 'KuroPhysicsLibrary_GetHitPoint::Actor' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetHitPoint, TraceComp) == 0x000020, "Member 'KuroPhysicsLibrary_GetHitPoint::TraceComp' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetHitPoint, HitResult) == 0x000028, "Member 'KuroPhysicsLibrary_GetHitPoint::HitResult' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetHitPoint, DrawDuration) == 0x000030, "Member 'KuroPhysicsLibrary_GetHitPoint::DrawDuration' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetHitPoint, ForceTrace) == 0x000034, "Member 'KuroPhysicsLibrary_GetHitPoint::ForceTrace' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetHitPoint, ReturnValue) == 0x000035, "Member 'KuroPhysicsLibrary_GetHitPoint::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroPhysicsLibrary.GetSphereHitPoint
// 0x0040 (0x0040 - 0x0000)
struct KuroPhysicsLibrary_GetSphereHitPoint final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Actor;                                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    TraceComp;                                         // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A4[0x4];                                     // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroHitResult*                         HitResult;                                         // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawDuration;                                      // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceTrace;                                        // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A5[0x2];                                     // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroPhysicsLibrary_GetSphereHitPoint) == 0x000008, "Wrong alignment on KuroPhysicsLibrary_GetSphereHitPoint");
static_assert(sizeof(KuroPhysicsLibrary_GetSphereHitPoint) == 0x000040, "Wrong size on KuroPhysicsLibrary_GetSphereHitPoint");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, StartLocation) == 0x000000, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::StartLocation' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, EndLocation) == 0x00000C, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::EndLocation' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, Actor) == 0x000018, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::Actor' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, TraceComp) == 0x000020, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::TraceComp' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, Radius) == 0x000028, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::Radius' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, HitResult) == 0x000030, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::HitResult' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, DrawDuration) == 0x000038, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::DrawDuration' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, ForceTrace) == 0x00003C, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::ForceTrace' has a wrong offset!");
static_assert(offsetof(KuroPhysicsLibrary_GetSphereHitPoint, ReturnValue) == 0x00003D, "Member 'KuroPhysicsLibrary_GetSphereHitPoint::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticAndroidLibrary.AddAndroidScreenChangeDelegate
// 0x0014 (0x0014 - 0x0000)
struct KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate final
{
public:
	TDelegate<void()>                             Handler;                                           // 0x0000(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate) == 0x000004, "Wrong alignment on KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate");
static_assert(sizeof(KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate) == 0x000014, "Wrong size on KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate");
static_assert(offsetof(KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate, Handler) == 0x000000, "Member 'KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate::Handler' has a wrong offset!");

// Function KuroUtility.KuroStaticAndroidLibrary.GetDeviceIsEmulator
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticAndroidLibrary_GetDeviceIsEmulator final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticAndroidLibrary_GetDeviceIsEmulator) == 0x000001, "Wrong alignment on KuroStaticAndroidLibrary_GetDeviceIsEmulator");
static_assert(sizeof(KuroStaticAndroidLibrary_GetDeviceIsEmulator) == 0x000001, "Wrong size on KuroStaticAndroidLibrary_GetDeviceIsEmulator");
static_assert(offsetof(KuroStaticAndroidLibrary_GetDeviceIsEmulator, ReturnValue) == 0x000000, "Member 'KuroStaticAndroidLibrary_GetDeviceIsEmulator::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticAndroidLibrary.GetDeviceIsRooted
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticAndroidLibrary_GetDeviceIsRooted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticAndroidLibrary_GetDeviceIsRooted) == 0x000001, "Wrong alignment on KuroStaticAndroidLibrary_GetDeviceIsRooted");
static_assert(sizeof(KuroStaticAndroidLibrary_GetDeviceIsRooted) == 0x000001, "Wrong size on KuroStaticAndroidLibrary_GetDeviceIsRooted");
static_assert(offsetof(KuroStaticAndroidLibrary_GetDeviceIsRooted, ReturnValue) == 0x000000, "Member 'KuroStaticAndroidLibrary_GetDeviceIsRooted::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticiOSLibrary.GetDeviceJailbroken
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticiOSLibrary_GetDeviceJailbroken final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticiOSLibrary_GetDeviceJailbroken) == 0x000001, "Wrong alignment on KuroStaticiOSLibrary_GetDeviceJailbroken");
static_assert(sizeof(KuroStaticiOSLibrary_GetDeviceJailbroken) == 0x000001, "Wrong size on KuroStaticiOSLibrary_GetDeviceJailbroken");
static_assert(offsetof(KuroStaticiOSLibrary_GetDeviceJailbroken, ReturnValue) == 0x000000, "Member 'KuroStaticiOSLibrary_GetDeviceJailbroken::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.AddToRoot
// 0x0008 (0x0008 - 0x0000)
struct KuroStaticLibrary_AddToRoot final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_AddToRoot) == 0x000008, "Wrong alignment on KuroStaticLibrary_AddToRoot");
static_assert(sizeof(KuroStaticLibrary_AddToRoot) == 0x000008, "Wrong size on KuroStaticLibrary_AddToRoot");
static_assert(offsetof(KuroStaticLibrary_AddToRoot, InObject) == 0x000000, "Member 'KuroStaticLibrary_AddToRoot::InObject' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ApplyChangeToBlueprint
// 0x0008 (0x0008 - 0x0000)
struct KuroStaticLibrary_ApplyChangeToBlueprint final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_ApplyChangeToBlueprint) == 0x000008, "Wrong alignment on KuroStaticLibrary_ApplyChangeToBlueprint");
static_assert(sizeof(KuroStaticLibrary_ApplyChangeToBlueprint) == 0x000008, "Wrong size on KuroStaticLibrary_ApplyChangeToBlueprint");
static_assert(offsetof(KuroStaticLibrary_ApplyChangeToBlueprint, Actor) == 0x000000, "Member 'KuroStaticLibrary_ApplyChangeToBlueprint::Actor' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ClearPlayerInputCache
// 0x0008 (0x0008 - 0x0000)
struct KuroStaticLibrary_ClearPlayerInputCache final
{
public:
	class APlayerController*                      PC;                                                // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_ClearPlayerInputCache) == 0x000008, "Wrong alignment on KuroStaticLibrary_ClearPlayerInputCache");
static_assert(sizeof(KuroStaticLibrary_ClearPlayerInputCache) == 0x000008, "Wrong size on KuroStaticLibrary_ClearPlayerInputCache");
static_assert(offsetof(KuroStaticLibrary_ClearPlayerInputCache, PC) == 0x000000, "Member 'KuroStaticLibrary_ClearPlayerInputCache::PC' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ConvertToObjectType
// 0x0002 (0x0002 - 0x0000)
struct KuroStaticLibrary_ConvertToObjectType final
{
public:
	ECollisionChannel                             InCollisionChannel;                                // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectTypeQuery                              ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_ConvertToObjectType) == 0x000001, "Wrong alignment on KuroStaticLibrary_ConvertToObjectType");
static_assert(sizeof(KuroStaticLibrary_ConvertToObjectType) == 0x000002, "Wrong size on KuroStaticLibrary_ConvertToObjectType");
static_assert(offsetof(KuroStaticLibrary_ConvertToObjectType, InCollisionChannel) == 0x000000, "Member 'KuroStaticLibrary_ConvertToObjectType::InCollisionChannel' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ConvertToObjectType, ReturnValue) == 0x000001, "Member 'KuroStaticLibrary_ConvertToObjectType::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ConvertToTraceType
// 0x0002 (0x0002 - 0x0000)
struct KuroStaticLibrary_ConvertToTraceType final
{
public:
	ECollisionChannel                             InCollisionChannel;                                // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_ConvertToTraceType) == 0x000001, "Wrong alignment on KuroStaticLibrary_ConvertToTraceType");
static_assert(sizeof(KuroStaticLibrary_ConvertToTraceType) == 0x000002, "Wrong size on KuroStaticLibrary_ConvertToTraceType");
static_assert(offsetof(KuroStaticLibrary_ConvertToTraceType, InCollisionChannel) == 0x000000, "Member 'KuroStaticLibrary_ConvertToTraceType::InCollisionChannel' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ConvertToTraceType, ReturnValue) == 0x000001, "Member 'KuroStaticLibrary_ConvertToTraceType::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.CopyFile
// 0x0028 (0x0028 - 0x0000)
struct KuroStaticLibrary_CopyFile final
{
public:
	class FString                                 SourcePath;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DstPath;                                           // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A7[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_CopyFile) == 0x000008, "Wrong alignment on KuroStaticLibrary_CopyFile");
static_assert(sizeof(KuroStaticLibrary_CopyFile) == 0x000028, "Wrong size on KuroStaticLibrary_CopyFile");
static_assert(offsetof(KuroStaticLibrary_CopyFile, SourcePath) == 0x000000, "Member 'KuroStaticLibrary_CopyFile::SourcePath' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_CopyFile, DstPath) == 0x000010, "Member 'KuroStaticLibrary_CopyFile::DstPath' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_CopyFile, ReturnValue) == 0x000020, "Member 'KuroStaticLibrary_CopyFile::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.CountCurFrame
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticLibrary_CountCurFrame final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_CountCurFrame) == 0x000001, "Wrong alignment on KuroStaticLibrary_CountCurFrame");
static_assert(sizeof(KuroStaticLibrary_CountCurFrame) == 0x000001, "Wrong size on KuroStaticLibrary_CountCurFrame");
static_assert(offsetof(KuroStaticLibrary_CountCurFrame, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_CountCurFrame::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.DeleteFile
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_DeleteFile final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireExists;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEvenReadOnly;                                     // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bQuiet;                                            // 0x0012(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0013(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A8[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_DeleteFile) == 0x000008, "Wrong alignment on KuroStaticLibrary_DeleteFile");
static_assert(sizeof(KuroStaticLibrary_DeleteFile) == 0x000018, "Wrong size on KuroStaticLibrary_DeleteFile");
static_assert(offsetof(KuroStaticLibrary_DeleteFile, Path) == 0x000000, "Member 'KuroStaticLibrary_DeleteFile::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_DeleteFile, bRequireExists) == 0x000010, "Member 'KuroStaticLibrary_DeleteFile::bRequireExists' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_DeleteFile, bEvenReadOnly) == 0x000011, "Member 'KuroStaticLibrary_DeleteFile::bEvenReadOnly' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_DeleteFile, bQuiet) == 0x000012, "Member 'KuroStaticLibrary_DeleteFile::bQuiet' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_DeleteFile, ReturnValue) == 0x000013, "Member 'KuroStaticLibrary_DeleteFile::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.DeleteFolder
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_DeleteFolder final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequireExists;                                    // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTree;                                             // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0012(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19A9[0x5];                                     // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_DeleteFolder) == 0x000008, "Wrong alignment on KuroStaticLibrary_DeleteFolder");
static_assert(sizeof(KuroStaticLibrary_DeleteFolder) == 0x000018, "Wrong size on KuroStaticLibrary_DeleteFolder");
static_assert(offsetof(KuroStaticLibrary_DeleteFolder, Path) == 0x000000, "Member 'KuroStaticLibrary_DeleteFolder::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_DeleteFolder, bRequireExists) == 0x000010, "Member 'KuroStaticLibrary_DeleteFolder::bRequireExists' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_DeleteFolder, bTree) == 0x000011, "Member 'KuroStaticLibrary_DeleteFolder::bTree' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_DeleteFolder, ReturnValue) == 0x000012, "Member 'KuroStaticLibrary_DeleteFolder::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.DestroyObject
// 0x0008 (0x0008 - 0x0000)
struct KuroStaticLibrary_DestroyObject final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_DestroyObject) == 0x000008, "Wrong alignment on KuroStaticLibrary_DestroyObject");
static_assert(sizeof(KuroStaticLibrary_DestroyObject) == 0x000008, "Wrong size on KuroStaticLibrary_DestroyObject");
static_assert(offsetof(KuroStaticLibrary_DestroyObject, Object) == 0x000000, "Member 'KuroStaticLibrary_DestroyObject::Object' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.DirectoryExists
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_DirectoryExists final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AA[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_DirectoryExists) == 0x000008, "Wrong alignment on KuroStaticLibrary_DirectoryExists");
static_assert(sizeof(KuroStaticLibrary_DirectoryExists) == 0x000018, "Wrong size on KuroStaticLibrary_DirectoryExists");
static_assert(offsetof(KuroStaticLibrary_DirectoryExists, Path) == 0x000000, "Member 'KuroStaticLibrary_DirectoryExists::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_DirectoryExists, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_DirectoryExists::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.EncompassesPoint
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_EncompassesPoint final
{
public:
	class AVolume*                                Volume;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AB[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_EncompassesPoint) == 0x000008, "Wrong alignment on KuroStaticLibrary_EncompassesPoint");
static_assert(sizeof(KuroStaticLibrary_EncompassesPoint) == 0x000020, "Wrong size on KuroStaticLibrary_EncompassesPoint");
static_assert(offsetof(KuroStaticLibrary_EncompassesPoint, Volume) == 0x000000, "Member 'KuroStaticLibrary_EncompassesPoint::Volume' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_EncompassesPoint, Point) == 0x000008, "Member 'KuroStaticLibrary_EncompassesPoint::Point' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_EncompassesPoint, SphereRadius) == 0x000014, "Member 'KuroStaticLibrary_EncompassesPoint::SphereRadius' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_EncompassesPoint, ReturnValue) == 0x000018, "Member 'KuroStaticLibrary_EncompassesPoint::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ExecProcess
// 0x0050 (0x0050 - 0x0000)
struct KuroStaticLibrary_ExecProcess final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Params_0;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnCode;                                        // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AC[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutStd;                                            // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutErr;                                            // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AD[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_ExecProcess) == 0x000008, "Wrong alignment on KuroStaticLibrary_ExecProcess");
static_assert(sizeof(KuroStaticLibrary_ExecProcess) == 0x000050, "Wrong size on KuroStaticLibrary_ExecProcess");
static_assert(offsetof(KuroStaticLibrary_ExecProcess, URL) == 0x000000, "Member 'KuroStaticLibrary_ExecProcess::URL' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ExecProcess, Params_0) == 0x000010, "Member 'KuroStaticLibrary_ExecProcess::Params_0' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ExecProcess, ReturnCode) == 0x000020, "Member 'KuroStaticLibrary_ExecProcess::ReturnCode' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ExecProcess, OutStd) == 0x000028, "Member 'KuroStaticLibrary_ExecProcess::OutStd' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ExecProcess, OutErr) == 0x000038, "Member 'KuroStaticLibrary_ExecProcess::OutErr' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ExecProcess, ReturnValue) == 0x000048, "Member 'KuroStaticLibrary_ExecProcess::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ExecuteFunctionByName
// 0x0030 (0x0030 - 0x0000)
struct KuroStaticLibrary_ExecuteFunctionByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Result;                                            // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AE[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_ExecuteFunctionByName) == 0x000008, "Wrong alignment on KuroStaticLibrary_ExecuteFunctionByName");
static_assert(sizeof(KuroStaticLibrary_ExecuteFunctionByName) == 0x000030, "Wrong size on KuroStaticLibrary_ExecuteFunctionByName");
static_assert(offsetof(KuroStaticLibrary_ExecuteFunctionByName, Object) == 0x000000, "Member 'KuroStaticLibrary_ExecuteFunctionByName::Object' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ExecuteFunctionByName, FunctionName) == 0x000008, "Member 'KuroStaticLibrary_ExecuteFunctionByName::FunctionName' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ExecuteFunctionByName, Result) == 0x000018, "Member 'KuroStaticLibrary_ExecuteFunctionByName::Result' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ExecuteFunctionByName, ReturnValue) == 0x000028, "Member 'KuroStaticLibrary_ExecuteFunctionByName::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ExitGame
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticLibrary_ExitGame final
{
public:
	bool                                          Force;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_ExitGame) == 0x000001, "Wrong alignment on KuroStaticLibrary_ExitGame");
static_assert(sizeof(KuroStaticLibrary_ExitGame) == 0x000001, "Wrong size on KuroStaticLibrary_ExitGame");
static_assert(offsetof(KuroStaticLibrary_ExitGame, Force) == 0x000000, "Member 'KuroStaticLibrary_ExitGame::Force' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.FileExists
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_FileExists final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19AF[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_FileExists) == 0x000008, "Wrong alignment on KuroStaticLibrary_FileExists");
static_assert(sizeof(KuroStaticLibrary_FileExists) == 0x000018, "Wrong size on KuroStaticLibrary_FileExists");
static_assert(offsetof(KuroStaticLibrary_FileExists, Path) == 0x000000, "Member 'KuroStaticLibrary_FileExists::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_FileExists, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_FileExists::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ForceGarbageCollection
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticLibrary_ForceGarbageCollection final
{
public:
	bool                                          bFullPurge;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_ForceGarbageCollection) == 0x000001, "Wrong alignment on KuroStaticLibrary_ForceGarbageCollection");
static_assert(sizeof(KuroStaticLibrary_ForceGarbageCollection) == 0x000001, "Wrong size on KuroStaticLibrary_ForceGarbageCollection");
static_assert(offsetof(KuroStaticLibrary_ForceGarbageCollection, bFullPurge) == 0x000000, "Member 'KuroStaticLibrary_ForceGarbageCollection::bFullPurge' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.FromUnixTimestamp
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_FromUnixTimestamp final
{
public:
	int32                                         Timestamp;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B0[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_FromUnixTimestamp) == 0x000008, "Wrong alignment on KuroStaticLibrary_FromUnixTimestamp");
static_assert(sizeof(KuroStaticLibrary_FromUnixTimestamp) == 0x000010, "Wrong size on KuroStaticLibrary_FromUnixTimestamp");
static_assert(offsetof(KuroStaticLibrary_FromUnixTimestamp, Timestamp) == 0x000000, "Member 'KuroStaticLibrary_FromUnixTimestamp::Timestamp' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_FromUnixTimestamp, ReturnValue) == 0x000008, "Member 'KuroStaticLibrary_FromUnixTimestamp::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetActorCount
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetActorCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetActorCount) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetActorCount");
static_assert(sizeof(KuroStaticLibrary_GetActorCount) == 0x000004, "Wrong size on KuroStaticLibrary_GetActorCount");
static_assert(offsetof(KuroStaticLibrary_GetActorCount, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetActorCount::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetAnimAssets
// 0x0058 (0x0058 - 0x0000)
struct KuroStaticLibrary_GetAnimAssets final
{
public:
	const class UAnimBlueprint*                   InAnimBlueprint;                                   // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UAnimationAsset*>                  OutAnimationAssets;                                // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetAnimAssets) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetAnimAssets");
static_assert(sizeof(KuroStaticLibrary_GetAnimAssets) == 0x000058, "Wrong size on KuroStaticLibrary_GetAnimAssets");
static_assert(offsetof(KuroStaticLibrary_GetAnimAssets, InAnimBlueprint) == 0x000000, "Member 'KuroStaticLibrary_GetAnimAssets::InAnimBlueprint' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetAnimAssets, OutAnimationAssets) == 0x000008, "Member 'KuroStaticLibrary_GetAnimAssets::OutAnimationAssets' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetAnimAssetsByAnimBlueprintClass
// 0x0058 (0x0058 - 0x0000)
struct KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass final
{
public:
	TSubclassOf<class UAnimInstance>              InAnimClass;                                       // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UAnimationAsset*>                  OutAnimationAssets;                                // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass");
static_assert(sizeof(KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass) == 0x000058, "Wrong size on KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass");
static_assert(offsetof(KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass, InAnimClass) == 0x000000, "Member 'KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass::InAnimClass' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass, OutAnimationAssets) == 0x000008, "Member 'KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass::OutAnimationAssets' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetAnimAssetsByAnimInstance
// 0x0058 (0x0058 - 0x0000)
struct KuroStaticLibrary_GetAnimAssetsByAnimInstance final
{
public:
	const class UAnimInstance*                    InAnimInstance;                                    // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class UAnimationAsset*>                  OutAnimationAssets;                                // 0x0008(0x0050)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetAnimAssetsByAnimInstance) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetAnimAssetsByAnimInstance");
static_assert(sizeof(KuroStaticLibrary_GetAnimAssetsByAnimInstance) == 0x000058, "Wrong size on KuroStaticLibrary_GetAnimAssetsByAnimInstance");
static_assert(offsetof(KuroStaticLibrary_GetAnimAssetsByAnimInstance, InAnimInstance) == 0x000000, "Member 'KuroStaticLibrary_GetAnimAssetsByAnimInstance::InAnimInstance' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetAnimAssetsByAnimInstance, OutAnimationAssets) == 0x000008, "Member 'KuroStaticLibrary_GetAnimAssetsByAnimInstance::OutAnimationAssets' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetAnimMontageNotifies
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_GetAnimMontageNotifies final
{
public:
	const class UAnimMontage*                     AnimMontage;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimNotifyEvent>               OutNotifies;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetAnimMontageNotifies) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetAnimMontageNotifies");
static_assert(sizeof(KuroStaticLibrary_GetAnimMontageNotifies) == 0x000018, "Wrong size on KuroStaticLibrary_GetAnimMontageNotifies");
static_assert(offsetof(KuroStaticLibrary_GetAnimMontageNotifies, AnimMontage) == 0x000000, "Member 'KuroStaticLibrary_GetAnimMontageNotifies::AnimMontage' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetAnimMontageNotifies, OutNotifies) == 0x000008, "Member 'KuroStaticLibrary_GetAnimMontageNotifies::OutNotifies' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetAnimSequenceNotifies
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_GetAnimSequenceNotifies final
{
public:
	const class UAnimSequenceBase*                AnimSequence;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAnimNotifyEvent>               OutNotifies;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetAnimSequenceNotifies) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetAnimSequenceNotifies");
static_assert(sizeof(KuroStaticLibrary_GetAnimSequenceNotifies) == 0x000018, "Wrong size on KuroStaticLibrary_GetAnimSequenceNotifies");
static_assert(offsetof(KuroStaticLibrary_GetAnimSequenceNotifies, AnimSequence) == 0x000000, "Member 'KuroStaticLibrary_GetAnimSequenceNotifies::AnimSequence' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetAnimSequenceNotifies, OutNotifies) == 0x000008, "Member 'KuroStaticLibrary_GetAnimSequenceNotifies::OutNotifies' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetAnimSequencesByAnimMontage
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_GetAnimSequencesByAnimMontage final
{
public:
	const class UAnimMontage*                     AnimMontage;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              OutAnimSequences;                                  // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetAnimSequencesByAnimMontage) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetAnimSequencesByAnimMontage");
static_assert(sizeof(KuroStaticLibrary_GetAnimSequencesByAnimMontage) == 0x000018, "Wrong size on KuroStaticLibrary_GetAnimSequencesByAnimMontage");
static_assert(offsetof(KuroStaticLibrary_GetAnimSequencesByAnimMontage, AnimMontage) == 0x000000, "Member 'KuroStaticLibrary_GetAnimSequencesByAnimMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetAnimSequencesByAnimMontage, OutAnimSequences) == 0x000008, "Member 'KuroStaticLibrary_GetAnimSequencesByAnimMontage::OutAnimSequences' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetAvailablePhysicalGB
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetAvailablePhysicalGB final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetAvailablePhysicalGB) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetAvailablePhysicalGB");
static_assert(sizeof(KuroStaticLibrary_GetAvailablePhysicalGB) == 0x000004, "Wrong size on KuroStaticLibrary_GetAvailablePhysicalGB");
static_assert(offsetof(KuroStaticLibrary_GetAvailablePhysicalGB, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetAvailablePhysicalGB::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetAvailableVirtualGB
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetAvailableVirtualGB final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetAvailableVirtualGB) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetAvailableVirtualGB");
static_assert(sizeof(KuroStaticLibrary_GetAvailableVirtualGB) == 0x000004, "Wrong size on KuroStaticLibrary_GetAvailableVirtualGB");
static_assert(offsetof(KuroStaticLibrary_GetAvailableVirtualGB, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetAvailableVirtualGB::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetBatteryLevel
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetBatteryLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetBatteryLevel) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetBatteryLevel");
static_assert(sizeof(KuroStaticLibrary_GetBatteryLevel) == 0x000004, "Wrong size on KuroStaticLibrary_GetBatteryLevel");
static_assert(offsetof(KuroStaticLibrary_GetBatteryLevel, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetBatteryLevel::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetBlueprintCallstack
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetBlueprintCallstack final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetBlueprintCallstack) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetBlueprintCallstack");
static_assert(sizeof(KuroStaticLibrary_GetBlueprintCallstack) == 0x000010, "Wrong size on KuroStaticLibrary_GetBlueprintCallstack");
static_assert(offsetof(KuroStaticLibrary_GetBlueprintCallstack, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetBlueprintCallstack::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetCameraShakeInfo
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_GetCameraShakeInfo final
{
public:
	TSubclassOf<class UCameraShakeBase>           CameraShakeClass;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCameraShakeInfo                       OutInfo;                                           // 0x0008(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B1[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_GetCameraShakeInfo) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetCameraShakeInfo");
static_assert(sizeof(KuroStaticLibrary_GetCameraShakeInfo) == 0x000020, "Wrong size on KuroStaticLibrary_GetCameraShakeInfo");
static_assert(offsetof(KuroStaticLibrary_GetCameraShakeInfo, CameraShakeClass) == 0x000000, "Member 'KuroStaticLibrary_GetCameraShakeInfo::CameraShakeClass' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetCameraShakeInfo, OutInfo) == 0x000008, "Member 'KuroStaticLibrary_GetCameraShakeInfo::OutInfo' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetCameraShakeInfo, ReturnValue) == 0x000018, "Member 'KuroStaticLibrary_GetCameraShakeInfo::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetCharacterAnimClass
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetCharacterAnimClass final
{
public:
	TSubclassOf<class AActor>                     InActorClass;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              OutAnimClass;                                      // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetCharacterAnimClass) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetCharacterAnimClass");
static_assert(sizeof(KuroStaticLibrary_GetCharacterAnimClass) == 0x000010, "Wrong size on KuroStaticLibrary_GetCharacterAnimClass");
static_assert(offsetof(KuroStaticLibrary_GetCharacterAnimClass, InActorClass) == 0x000000, "Member 'KuroStaticLibrary_GetCharacterAnimClass::InActorClass' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetCharacterAnimClass, OutAnimClass) == 0x000008, "Member 'KuroStaticLibrary_GetCharacterAnimClass::OutAnimClass' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetCreatureGenDirectoryByMap
// 0x0028 (0x0028 - 0x0000)
struct KuroStaticLibrary_GetCreatureGenDirectoryByMap final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapID;                                             // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Exist;                                             // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B2[0x3];                                     // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Directory;                                         // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetCreatureGenDirectoryByMap) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetCreatureGenDirectoryByMap");
static_assert(sizeof(KuroStaticLibrary_GetCreatureGenDirectoryByMap) == 0x000028, "Wrong size on KuroStaticLibrary_GetCreatureGenDirectoryByMap");
static_assert(offsetof(KuroStaticLibrary_GetCreatureGenDirectoryByMap, Path) == 0x000000, "Member 'KuroStaticLibrary_GetCreatureGenDirectoryByMap::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetCreatureGenDirectoryByMap, MapID) == 0x000010, "Member 'KuroStaticLibrary_GetCreatureGenDirectoryByMap::MapID' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetCreatureGenDirectoryByMap, Exist) == 0x000014, "Member 'KuroStaticLibrary_GetCreatureGenDirectoryByMap::Exist' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetCreatureGenDirectoryByMap, Directory) == 0x000018, "Member 'KuroStaticLibrary_GetCreatureGenDirectoryByMap::Directory' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetCultureRegion
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetCultureRegion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetCultureRegion) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetCultureRegion");
static_assert(sizeof(KuroStaticLibrary_GetCultureRegion) == 0x000010, "Wrong size on KuroStaticLibrary_GetCultureRegion");
static_assert(offsetof(KuroStaticLibrary_GetCultureRegion, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetCultureRegion::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetCurCPUFrequency
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetCurCPUFrequency final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetCurCPUFrequency) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetCurCPUFrequency");
static_assert(sizeof(KuroStaticLibrary_GetCurCPUFrequency) == 0x000004, "Wrong size on KuroStaticLibrary_GetCurCPUFrequency");
static_assert(offsetof(KuroStaticLibrary_GetCurCPUFrequency, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetCurCPUFrequency::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetDefaultObject
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetDefaultObject final
{
public:
	class UClass*                                 Param_Class;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetDefaultObject) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetDefaultObject");
static_assert(sizeof(KuroStaticLibrary_GetDefaultObject) == 0x000010, "Wrong size on KuroStaticLibrary_GetDefaultObject");
static_assert(offsetof(KuroStaticLibrary_GetDefaultObject, Param_Class) == 0x000000, "Member 'KuroStaticLibrary_GetDefaultObject::Param_Class' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetDefaultObject, ReturnValue) == 0x000008, "Member 'KuroStaticLibrary_GetDefaultObject::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetDeviceCPU
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetDeviceCPU final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetDeviceCPU) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetDeviceCPU");
static_assert(sizeof(KuroStaticLibrary_GetDeviceCPU) == 0x000010, "Wrong size on KuroStaticLibrary_GetDeviceCPU");
static_assert(offsetof(KuroStaticLibrary_GetDeviceCPU, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetDeviceCPU::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetDirectories
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_GetDirectories final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetDirectories) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetDirectories");
static_assert(sizeof(KuroStaticLibrary_GetDirectories) == 0x000020, "Wrong size on KuroStaticLibrary_GetDirectories");
static_assert(offsetof(KuroStaticLibrary_GetDirectories, Path) == 0x000000, "Member 'KuroStaticLibrary_GetDirectories::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetDirectories, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_GetDirectories::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetFiles
// 0x0030 (0x0030 - 0x0000)
struct KuroStaticLibrary_GetFiles final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Extension;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetFiles) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetFiles");
static_assert(sizeof(KuroStaticLibrary_GetFiles) == 0x000030, "Wrong size on KuroStaticLibrary_GetFiles");
static_assert(offsetof(KuroStaticLibrary_GetFiles, Path) == 0x000000, "Member 'KuroStaticLibrary_GetFiles::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetFiles, Extension) == 0x000010, "Member 'KuroStaticLibrary_GetFiles::Extension' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetFiles, ReturnValue) == 0x000020, "Member 'KuroStaticLibrary_GetFiles::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetFilesRecursive
// 0x0038 (0x0038 - 0x0000)
struct KuroStaticLibrary_GetFilesRecursive final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filter;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Files;                                             // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Directories;                                       // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B3[0x6];                                     // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetFilesRecursive) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetFilesRecursive");
static_assert(sizeof(KuroStaticLibrary_GetFilesRecursive) == 0x000038, "Wrong size on KuroStaticLibrary_GetFilesRecursive");
static_assert(offsetof(KuroStaticLibrary_GetFilesRecursive, Path) == 0x000000, "Member 'KuroStaticLibrary_GetFilesRecursive::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetFilesRecursive, Filter) == 0x000010, "Member 'KuroStaticLibrary_GetFilesRecursive::Filter' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetFilesRecursive, Files) == 0x000020, "Member 'KuroStaticLibrary_GetFilesRecursive::Files' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetFilesRecursive, Directories) == 0x000021, "Member 'KuroStaticLibrary_GetFilesRecursive::Directories' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetFilesRecursive, ReturnValue) == 0x000028, "Member 'KuroStaticLibrary_GetFilesRecursive::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetFirstLocationFromSeqTrack
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_GetFirstLocationFromSeqTrack final
{
public:
	class UMovieScene3DTransformTrack*            TransformTrack;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B4[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_GetFirstLocationFromSeqTrack) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetFirstLocationFromSeqTrack");
static_assert(sizeof(KuroStaticLibrary_GetFirstLocationFromSeqTrack) == 0x000018, "Wrong size on KuroStaticLibrary_GetFirstLocationFromSeqTrack");
static_assert(offsetof(KuroStaticLibrary_GetFirstLocationFromSeqTrack, TransformTrack) == 0x000000, "Member 'KuroStaticLibrary_GetFirstLocationFromSeqTrack::TransformTrack' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetFirstLocationFromSeqTrack, ReturnValue) == 0x000008, "Member 'KuroStaticLibrary_GetFirstLocationFromSeqTrack::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetFrameInfo
// 0x000C (0x000C - 0x0000)
struct KuroStaticLibrary_GetFrameInfo final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetFrameInfo) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetFrameInfo");
static_assert(sizeof(KuroStaticLibrary_GetFrameInfo) == 0x00000C, "Wrong size on KuroStaticLibrary_GetFrameInfo");
static_assert(offsetof(KuroStaticLibrary_GetFrameInfo, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetFrameInfo::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetGPUFrameTime
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetGPUFrameTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetGPUFrameTime) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetGPUFrameTime");
static_assert(sizeof(KuroStaticLibrary_GetGPUFrameTime) == 0x000004, "Wrong size on KuroStaticLibrary_GetGPUFrameTime");
static_assert(offsetof(KuroStaticLibrary_GetGPUFrameTime, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetGPUFrameTime::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetGPUInfo
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetGPUInfo final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetGPUInfo) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetGPUInfo");
static_assert(sizeof(KuroStaticLibrary_GetGPUInfo) == 0x000010, "Wrong size on KuroStaticLibrary_GetGPUInfo");
static_assert(offsetof(KuroStaticLibrary_GetGPUInfo, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetGPUInfo::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetLevelPath
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_GetLevelPath final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetLevelPath) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetLevelPath");
static_assert(sizeof(KuroStaticLibrary_GetLevelPath) == 0x000018, "Wrong size on KuroStaticLibrary_GetLevelPath");
static_assert(offsetof(KuroStaticLibrary_GetLevelPath, WorldContextObject) == 0x000000, "Member 'KuroStaticLibrary_GetLevelPath::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetLevelPath, ReturnValue) == 0x000008, "Member 'KuroStaticLibrary_GetLevelPath::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetLevelPrefabShowActor
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetLevelPrefabShowActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetLevelPrefabShowActor) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetLevelPrefabShowActor");
static_assert(sizeof(KuroStaticLibrary_GetLevelPrefabShowActor) == 0x000010, "Wrong size on KuroStaticLibrary_GetLevelPrefabShowActor");
static_assert(offsetof(KuroStaticLibrary_GetLevelPrefabShowActor, Actor) == 0x000000, "Member 'KuroStaticLibrary_GetLevelPrefabShowActor::Actor' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetLevelPrefabShowActor, ReturnValue) == 0x000008, "Member 'KuroStaticLibrary_GetLevelPrefabShowActor::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetLLMInfo
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetLLMInfo final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetLLMInfo) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetLLMInfo");
static_assert(sizeof(KuroStaticLibrary_GetLLMInfo) == 0x000010, "Wrong size on KuroStaticLibrary_GetLLMInfo");
static_assert(offsetof(KuroStaticLibrary_GetLLMInfo, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetLLMInfo::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetLocalHostAddresses
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_GetLocalHostAddresses final
{
public:
	TArray<class FString>                         OutAddresses;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAppendPort;                                       // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B5[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_GetLocalHostAddresses) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetLocalHostAddresses");
static_assert(sizeof(KuroStaticLibrary_GetLocalHostAddresses) == 0x000018, "Wrong size on KuroStaticLibrary_GetLocalHostAddresses");
static_assert(offsetof(KuroStaticLibrary_GetLocalHostAddresses, OutAddresses) == 0x000000, "Member 'KuroStaticLibrary_GetLocalHostAddresses::OutAddresses' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetLocalHostAddresses, bAppendPort) == 0x000010, "Member 'KuroStaticLibrary_GetLocalHostAddresses::bAppendPort' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetNavPointData
// 0x0050 (0x0050 - 0x0000)
struct KuroStaticLibrary_GetNavPointData final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XNumber;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YNumber;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dis;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B6[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationData*                        NavData;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QueryExtent;                                       // 0x002C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetNavPointData) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetNavPointData");
static_assert(sizeof(KuroStaticLibrary_GetNavPointData) == 0x000050, "Wrong size on KuroStaticLibrary_GetNavPointData");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, WorldContextObject) == 0x000000, "Member 'KuroStaticLibrary_GetNavPointData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, XNumber) == 0x000008, "Member 'KuroStaticLibrary_GetNavPointData::XNumber' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, YNumber) == 0x00000C, "Member 'KuroStaticLibrary_GetNavPointData::YNumber' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, Dis) == 0x000010, "Member 'KuroStaticLibrary_GetNavPointData::Dis' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, NavData) == 0x000018, "Member 'KuroStaticLibrary_GetNavPointData::NavData' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, Point) == 0x000020, "Member 'KuroStaticLibrary_GetNavPointData::Point' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, QueryExtent) == 0x00002C, "Member 'KuroStaticLibrary_GetNavPointData::QueryExtent' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, FilterClass) == 0x000038, "Member 'KuroStaticLibrary_GetNavPointData::FilterClass' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetNavPointData, ReturnValue) == 0x000040, "Member 'KuroStaticLibrary_GetNavPointData::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetPeakUsedPhysicalGB
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetPeakUsedPhysicalGB final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetPeakUsedPhysicalGB) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetPeakUsedPhysicalGB");
static_assert(sizeof(KuroStaticLibrary_GetPeakUsedPhysicalGB) == 0x000004, "Wrong size on KuroStaticLibrary_GetPeakUsedPhysicalGB");
static_assert(offsetof(KuroStaticLibrary_GetPeakUsedPhysicalGB, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetPeakUsedPhysicalGB::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetPeakUsedVirtualGB
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetPeakUsedVirtualGB final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetPeakUsedVirtualGB) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetPeakUsedVirtualGB");
static_assert(sizeof(KuroStaticLibrary_GetPeakUsedVirtualGB) == 0x000004, "Wrong size on KuroStaticLibrary_GetPeakUsedVirtualGB");
static_assert(offsetof(KuroStaticLibrary_GetPeakUsedVirtualGB, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetPeakUsedVirtualGB::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetPIEStartTimeInSeconds
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetPIEStartTimeInSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetPIEStartTimeInSeconds) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetPIEStartTimeInSeconds");
static_assert(sizeof(KuroStaticLibrary_GetPIEStartTimeInSeconds) == 0x000004, "Wrong size on KuroStaticLibrary_GetPIEStartTimeInSeconds");
static_assert(offsetof(KuroStaticLibrary_GetPIEStartTimeInSeconds, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetPIEStartTimeInSeconds::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetPlatformTimeInSeconds
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetPlatformTimeInSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetPlatformTimeInSeconds) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetPlatformTimeInSeconds");
static_assert(sizeof(KuroStaticLibrary_GetPlatformTimeInSeconds) == 0x000004, "Wrong size on KuroStaticLibrary_GetPlatformTimeInSeconds");
static_assert(offsetof(KuroStaticLibrary_GetPlatformTimeInSeconds, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetPlatformTimeInSeconds::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetRawFrameTime
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetRawFrameTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetRawFrameTime) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetRawFrameTime");
static_assert(sizeof(KuroStaticLibrary_GetRawFrameTime) == 0x000004, "Wrong size on KuroStaticLibrary_GetRawFrameTime");
static_assert(offsetof(KuroStaticLibrary_GetRawFrameTime, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetRawFrameTime::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetRawGameThreadTime
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetRawGameThreadTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetRawGameThreadTime) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetRawGameThreadTime");
static_assert(sizeof(KuroStaticLibrary_GetRawGameThreadTime) == 0x000004, "Wrong size on KuroStaticLibrary_GetRawGameThreadTime");
static_assert(offsetof(KuroStaticLibrary_GetRawGameThreadTime, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetRawGameThreadTime::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetRawRenderThreadTime
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetRawRenderThreadTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetRawRenderThreadTime) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetRawRenderThreadTime");
static_assert(sizeof(KuroStaticLibrary_GetRawRenderThreadTime) == 0x000004, "Wrong size on KuroStaticLibrary_GetRawRenderThreadTime");
static_assert(offsetof(KuroStaticLibrary_GetRawRenderThreadTime, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetRawRenderThreadTime::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetRawRHITTime
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetRawRHITTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetRawRHITTime) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetRawRHITTime");
static_assert(sizeof(KuroStaticLibrary_GetRawRHITTime) == 0x000004, "Wrong size on KuroStaticLibrary_GetRawRHITTime");
static_assert(offsetof(KuroStaticLibrary_GetRawRHITTime, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetRawRHITTime::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetSequenceTracksForObjectBindingID
// 0x0028 (0x0028 - 0x0000)
struct KuroStaticLibrary_GetSequenceTracksForObjectBindingID final
{
public:
	const class ALevelSequenceActor*              Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B7[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneTrack*>               ReturnValue;                                       // 0x0018(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetSequenceTracksForObjectBindingID) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetSequenceTracksForObjectBindingID");
static_assert(sizeof(KuroStaticLibrary_GetSequenceTracksForObjectBindingID) == 0x000028, "Wrong size on KuroStaticLibrary_GetSequenceTracksForObjectBindingID");
static_assert(offsetof(KuroStaticLibrary_GetSequenceTracksForObjectBindingID, Actor) == 0x000000, "Member 'KuroStaticLibrary_GetSequenceTracksForObjectBindingID::Actor' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetSequenceTracksForObjectBindingID, TagName) == 0x000008, "Member 'KuroStaticLibrary_GetSequenceTracksForObjectBindingID::TagName' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetSequenceTracksForObjectBindingID, ReturnValue) == 0x000018, "Member 'KuroStaticLibrary_GetSequenceTracksForObjectBindingID::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetSlotNamesByAnimMontage
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_GetSlotNamesByAnimMontage final
{
public:
	const class UAnimMontage*                     AnimMontage;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutSlotNames;                                      // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetSlotNamesByAnimMontage) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetSlotNamesByAnimMontage");
static_assert(sizeof(KuroStaticLibrary_GetSlotNamesByAnimMontage) == 0x000018, "Wrong size on KuroStaticLibrary_GetSlotNamesByAnimMontage");
static_assert(offsetof(KuroStaticLibrary_GetSlotNamesByAnimMontage, AnimMontage) == 0x000000, "Member 'KuroStaticLibrary_GetSlotNamesByAnimMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetSlotNamesByAnimMontage, OutSlotNames) == 0x000008, "Member 'KuroStaticLibrary_GetSlotNamesByAnimMontage::OutSlotNames' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetSplineRotationAtSplinePoint
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_GetSplineRotationAtSplinePoint final
{
public:
	class USplineComponent*                       Spline;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointIndex;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B8[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19B9[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_GetSplineRotationAtSplinePoint) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetSplineRotationAtSplinePoint");
static_assert(sizeof(KuroStaticLibrary_GetSplineRotationAtSplinePoint) == 0x000020, "Wrong size on KuroStaticLibrary_GetSplineRotationAtSplinePoint");
static_assert(offsetof(KuroStaticLibrary_GetSplineRotationAtSplinePoint, Spline) == 0x000000, "Member 'KuroStaticLibrary_GetSplineRotationAtSplinePoint::Spline' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetSplineRotationAtSplinePoint, PointIndex) == 0x000008, "Member 'KuroStaticLibrary_GetSplineRotationAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetSplineRotationAtSplinePoint, CoordinateSpace) == 0x00000C, "Member 'KuroStaticLibrary_GetSplineRotationAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetSplineRotationAtSplinePoint, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_GetSplineRotationAtSplinePoint::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetStatUnitInfo
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_GetStatUnitInfo final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetStatUnitInfo) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetStatUnitInfo");
static_assert(sizeof(KuroStaticLibrary_GetStatUnitInfo) == 0x000010, "Wrong size on KuroStaticLibrary_GetStatUnitInfo");
static_assert(offsetof(KuroStaticLibrary_GetStatUnitInfo, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetStatUnitInfo::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetTotalMemoryGB
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetTotalMemoryGB final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetTotalMemoryGB) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetTotalMemoryGB");
static_assert(sizeof(KuroStaticLibrary_GetTotalMemoryGB) == 0x000004, "Wrong size on KuroStaticLibrary_GetTotalMemoryGB");
static_assert(offsetof(KuroStaticLibrary_GetTotalMemoryGB, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetTotalMemoryGB::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetTrackByClass
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_GetTrackByClass final
{
public:
	TArray<class UMovieSceneTrack*>               Tracks;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UMovieSceneTrack>           Param_Class;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMovieSceneTrack*                       ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetTrackByClass) == 0x000008, "Wrong alignment on KuroStaticLibrary_GetTrackByClass");
static_assert(sizeof(KuroStaticLibrary_GetTrackByClass) == 0x000020, "Wrong size on KuroStaticLibrary_GetTrackByClass");
static_assert(offsetof(KuroStaticLibrary_GetTrackByClass, Tracks) == 0x000000, "Member 'KuroStaticLibrary_GetTrackByClass::Tracks' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetTrackByClass, Param_Class) == 0x000010, "Member 'KuroStaticLibrary_GetTrackByClass::Param_Class' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_GetTrackByClass, ReturnValue) == 0x000018, "Member 'KuroStaticLibrary_GetTrackByClass::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetUsedMemoryGB
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetUsedMemoryGB final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetUsedMemoryGB) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetUsedMemoryGB");
static_assert(sizeof(KuroStaticLibrary_GetUsedMemoryGB) == 0x000004, "Wrong size on KuroStaticLibrary_GetUsedMemoryGB");
static_assert(offsetof(KuroStaticLibrary_GetUsedMemoryGB, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetUsedMemoryGB::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetUsedPhysicalGB
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetUsedPhysicalGB final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetUsedPhysicalGB) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetUsedPhysicalGB");
static_assert(sizeof(KuroStaticLibrary_GetUsedPhysicalGB) == 0x000004, "Wrong size on KuroStaticLibrary_GetUsedPhysicalGB");
static_assert(offsetof(KuroStaticLibrary_GetUsedPhysicalGB, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetUsedPhysicalGB::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetUsedVirtualGB
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetUsedVirtualGB final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetUsedVirtualGB) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetUsedVirtualGB");
static_assert(sizeof(KuroStaticLibrary_GetUsedVirtualGB) == 0x000004, "Wrong size on KuroStaticLibrary_GetUsedVirtualGB");
static_assert(offsetof(KuroStaticLibrary_GetUsedVirtualGB, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetUsedVirtualGB::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.GetUseMemoryProportion
// 0x0004 (0x0004 - 0x0000)
struct KuroStaticLibrary_GetUseMemoryProportion final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_GetUseMemoryProportion) == 0x000004, "Wrong alignment on KuroStaticLibrary_GetUseMemoryProportion");
static_assert(sizeof(KuroStaticLibrary_GetUseMemoryProportion) == 0x000004, "Wrong size on KuroStaticLibrary_GetUseMemoryProportion");
static_assert(offsetof(KuroStaticLibrary_GetUseMemoryProportion, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_GetUseMemoryProportion::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.HashStringWithSHA1
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_HashStringWithSHA1 final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_HashStringWithSHA1) == 0x000008, "Wrong alignment on KuroStaticLibrary_HashStringWithSHA1");
static_assert(sizeof(KuroStaticLibrary_HashStringWithSHA1) == 0x000020, "Wrong size on KuroStaticLibrary_HashStringWithSHA1");
static_assert(offsetof(KuroStaticLibrary_HashStringWithSHA1, InString) == 0x000000, "Member 'KuroStaticLibrary_HashStringWithSHA1::InString' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_HashStringWithSHA1, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_HashStringWithSHA1::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IcmpPing
// 0x0028 (0x0028 - 0x0000)
struct KuroStaticLibrary_IcmpPing final
{
public:
	class FString                                 IpAddress;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Address, float Time, int32 ResponseState)> InDelegate;                                        // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_IcmpPing) == 0x000008, "Wrong alignment on KuroStaticLibrary_IcmpPing");
static_assert(sizeof(KuroStaticLibrary_IcmpPing) == 0x000028, "Wrong size on KuroStaticLibrary_IcmpPing");
static_assert(offsetof(KuroStaticLibrary_IcmpPing, IpAddress) == 0x000000, "Member 'KuroStaticLibrary_IcmpPing::IpAddress' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IcmpPing, Timeout) == 0x000010, "Member 'KuroStaticLibrary_IcmpPing::Timeout' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IcmpPing, InDelegate) == 0x000014, "Member 'KuroStaticLibrary_IcmpPing::InDelegate' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IsAsyncLoadingThreadEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticLibrary_IsAsyncLoadingThreadEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_IsAsyncLoadingThreadEnabled) == 0x000001, "Wrong alignment on KuroStaticLibrary_IsAsyncLoadingThreadEnabled");
static_assert(sizeof(KuroStaticLibrary_IsAsyncLoadingThreadEnabled) == 0x000001, "Wrong size on KuroStaticLibrary_IsAsyncLoadingThreadEnabled");
static_assert(offsetof(KuroStaticLibrary_IsAsyncLoadingThreadEnabled, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_IsAsyncLoadingThreadEnabled::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IsBuildShipping
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticLibrary_IsBuildShipping final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_IsBuildShipping) == 0x000001, "Wrong alignment on KuroStaticLibrary_IsBuildShipping");
static_assert(sizeof(KuroStaticLibrary_IsBuildShipping) == 0x000001, "Wrong size on KuroStaticLibrary_IsBuildShipping");
static_assert(offsetof(KuroStaticLibrary_IsBuildShipping, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_IsBuildShipping::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IsBuildTest
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticLibrary_IsBuildTest final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_IsBuildTest) == 0x000001, "Wrong alignment on KuroStaticLibrary_IsBuildTest");
static_assert(sizeof(KuroStaticLibrary_IsBuildTest) == 0x000001, "Wrong size on KuroStaticLibrary_IsBuildTest");
static_assert(offsetof(KuroStaticLibrary_IsBuildTest, ReturnValue) == 0x000000, "Member 'KuroStaticLibrary_IsBuildTest::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IsEditor
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_IsEditor final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BA[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_IsEditor) == 0x000008, "Wrong alignment on KuroStaticLibrary_IsEditor");
static_assert(sizeof(KuroStaticLibrary_IsEditor) == 0x000010, "Wrong size on KuroStaticLibrary_IsEditor");
static_assert(offsetof(KuroStaticLibrary_IsEditor, WorldContextObject) == 0x000000, "Member 'KuroStaticLibrary_IsEditor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IsEditor, ReturnValue) == 0x000008, "Member 'KuroStaticLibrary_IsEditor::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IsImplementInterface
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_IsImplementInterface final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 InInterfaceClass;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BB[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_IsImplementInterface) == 0x000008, "Wrong alignment on KuroStaticLibrary_IsImplementInterface");
static_assert(sizeof(KuroStaticLibrary_IsImplementInterface) == 0x000018, "Wrong size on KuroStaticLibrary_IsImplementInterface");
static_assert(offsetof(KuroStaticLibrary_IsImplementInterface, InClass) == 0x000000, "Member 'KuroStaticLibrary_IsImplementInterface::InClass' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IsImplementInterface, InInterfaceClass) == 0x000008, "Member 'KuroStaticLibrary_IsImplementInterface::InInterfaceClass' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IsImplementInterface, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_IsImplementInterface::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IsModuleLoaded
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_IsModuleLoaded final
{
public:
	class FString                                 ModelName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BC[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_IsModuleLoaded) == 0x000008, "Wrong alignment on KuroStaticLibrary_IsModuleLoaded");
static_assert(sizeof(KuroStaticLibrary_IsModuleLoaded) == 0x000018, "Wrong size on KuroStaticLibrary_IsModuleLoaded");
static_assert(offsetof(KuroStaticLibrary_IsModuleLoaded, ModelName) == 0x000000, "Member 'KuroStaticLibrary_IsModuleLoaded::ModelName' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IsModuleLoaded, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_IsModuleLoaded::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IsObjectClassByName
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_IsObjectClassByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClassName;                                         // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BD[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_IsObjectClassByName) == 0x000008, "Wrong alignment on KuroStaticLibrary_IsObjectClassByName");
static_assert(sizeof(KuroStaticLibrary_IsObjectClassByName) == 0x000018, "Wrong size on KuroStaticLibrary_IsObjectClassByName");
static_assert(offsetof(KuroStaticLibrary_IsObjectClassByName, Object) == 0x000000, "Member 'KuroStaticLibrary_IsObjectClassByName::Object' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IsObjectClassByName, ClassName) == 0x000008, "Member 'KuroStaticLibrary_IsObjectClassByName::ClassName' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IsObjectClassByName, ReturnValue) == 0x000014, "Member 'KuroStaticLibrary_IsObjectClassByName::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.IsWorldTearingDown
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_IsWorldTearingDown final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BE[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_IsWorldTearingDown) == 0x000008, "Wrong alignment on KuroStaticLibrary_IsWorldTearingDown");
static_assert(sizeof(KuroStaticLibrary_IsWorldTearingDown) == 0x000010, "Wrong size on KuroStaticLibrary_IsWorldTearingDown");
static_assert(offsetof(KuroStaticLibrary_IsWorldTearingDown, World) == 0x000000, "Member 'KuroStaticLibrary_IsWorldTearingDown::World' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_IsWorldTearingDown, ReturnValue) == 0x000008, "Member 'KuroStaticLibrary_IsWorldTearingDown::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.KuroFormatText
// 0x0030 (0x0030 - 0x0000)
struct KuroStaticLibrary_KuroFormatText final
{
public:
	class FString                                 Format;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Parameters;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_KuroFormatText) == 0x000008, "Wrong alignment on KuroStaticLibrary_KuroFormatText");
static_assert(sizeof(KuroStaticLibrary_KuroFormatText) == 0x000030, "Wrong size on KuroStaticLibrary_KuroFormatText");
static_assert(offsetof(KuroStaticLibrary_KuroFormatText, Format) == 0x000000, "Member 'KuroStaticLibrary_KuroFormatText::Format' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_KuroFormatText, Parameters) == 0x000010, "Member 'KuroStaticLibrary_KuroFormatText::Parameters' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_KuroFormatText, ReturnValue) == 0x000020, "Member 'KuroStaticLibrary_KuroFormatText::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.LoadFilesRecursive
// 0x0038 (0x0038 - 0x0000)
struct KuroStaticLibrary_LoadFilesRecursive final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filter;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Files;                                             // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Directories;                                       // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19BF[0x6];                                     // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_LoadFilesRecursive) == 0x000008, "Wrong alignment on KuroStaticLibrary_LoadFilesRecursive");
static_assert(sizeof(KuroStaticLibrary_LoadFilesRecursive) == 0x000038, "Wrong size on KuroStaticLibrary_LoadFilesRecursive");
static_assert(offsetof(KuroStaticLibrary_LoadFilesRecursive, Path) == 0x000000, "Member 'KuroStaticLibrary_LoadFilesRecursive::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_LoadFilesRecursive, Filter) == 0x000010, "Member 'KuroStaticLibrary_LoadFilesRecursive::Filter' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_LoadFilesRecursive, Files) == 0x000020, "Member 'KuroStaticLibrary_LoadFilesRecursive::Files' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_LoadFilesRecursive, Directories) == 0x000021, "Member 'KuroStaticLibrary_LoadFilesRecursive::Directories' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_LoadFilesRecursive, ReturnValue) == 0x000028, "Member 'KuroStaticLibrary_LoadFilesRecursive::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.LoadFileToString
// 0x0028 (0x0028 - 0x0000)
struct KuroStaticLibrary_LoadFileToString final
{
public:
	class FString                                 Result;                                            // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C0[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_LoadFileToString) == 0x000008, "Wrong alignment on KuroStaticLibrary_LoadFileToString");
static_assert(sizeof(KuroStaticLibrary_LoadFileToString) == 0x000028, "Wrong size on KuroStaticLibrary_LoadFileToString");
static_assert(offsetof(KuroStaticLibrary_LoadFileToString, Result) == 0x000000, "Member 'KuroStaticLibrary_LoadFileToString::Result' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_LoadFileToString, Filename) == 0x000010, "Member 'KuroStaticLibrary_LoadFileToString::Filename' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_LoadFileToString, ReturnValue) == 0x000020, "Member 'KuroStaticLibrary_LoadFileToString::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.LoadFileToStringArray
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_LoadFileToStringArray final
{
public:
	class FString                                 FileRevisionPath;                                  // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_LoadFileToStringArray) == 0x000008, "Wrong alignment on KuroStaticLibrary_LoadFileToStringArray");
static_assert(sizeof(KuroStaticLibrary_LoadFileToStringArray) == 0x000020, "Wrong size on KuroStaticLibrary_LoadFileToStringArray");
static_assert(offsetof(KuroStaticLibrary_LoadFileToStringArray, FileRevisionPath) == 0x000000, "Member 'KuroStaticLibrary_LoadFileToStringArray::FileRevisionPath' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_LoadFileToStringArray, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_LoadFileToStringArray::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.MakeDirectory
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_MakeDirectory final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTree;                                             // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C1[0x6];                                     // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_MakeDirectory) == 0x000008, "Wrong alignment on KuroStaticLibrary_MakeDirectory");
static_assert(sizeof(KuroStaticLibrary_MakeDirectory) == 0x000018, "Wrong size on KuroStaticLibrary_MakeDirectory");
static_assert(offsetof(KuroStaticLibrary_MakeDirectory, Path) == 0x000000, "Member 'KuroStaticLibrary_MakeDirectory::Path' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_MakeDirectory, bTree) == 0x000010, "Member 'KuroStaticLibrary_MakeDirectory::bTree' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_MakeDirectory, ReturnValue) == 0x000011, "Member 'KuroStaticLibrary_MakeDirectory::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.PerceptionConfigureSense
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_PerceptionConfigureSense final
{
public:
	class UAIPerceptionComponent*                 AIPerception;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAISenseConfig*                         AISenseConfig;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_PerceptionConfigureSense) == 0x000008, "Wrong alignment on KuroStaticLibrary_PerceptionConfigureSense");
static_assert(sizeof(KuroStaticLibrary_PerceptionConfigureSense) == 0x000010, "Wrong size on KuroStaticLibrary_PerceptionConfigureSense");
static_assert(offsetof(KuroStaticLibrary_PerceptionConfigureSense, AIPerception) == 0x000000, "Member 'KuroStaticLibrary_PerceptionConfigureSense::AIPerception' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_PerceptionConfigureSense, AISenseConfig) == 0x000008, "Member 'KuroStaticLibrary_PerceptionConfigureSense::AISenseConfig' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.RegisterCustomCommandProcessor
// 0x0028 (0x0028 - 0x0000)
struct KuroStaticLibrary_RegisterCustomCommandProcessor final
{
public:
	class FString                                 Category;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& Command)> Processor;                                         // 0x0010(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C2[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_RegisterCustomCommandProcessor) == 0x000008, "Wrong alignment on KuroStaticLibrary_RegisterCustomCommandProcessor");
static_assert(sizeof(KuroStaticLibrary_RegisterCustomCommandProcessor) == 0x000028, "Wrong size on KuroStaticLibrary_RegisterCustomCommandProcessor");
static_assert(offsetof(KuroStaticLibrary_RegisterCustomCommandProcessor, Category) == 0x000000, "Member 'KuroStaticLibrary_RegisterCustomCommandProcessor::Category' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_RegisterCustomCommandProcessor, Processor) == 0x000010, "Member 'KuroStaticLibrary_RegisterCustomCommandProcessor::Processor' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.RemoveFromRoot
// 0x0008 (0x0008 - 0x0000)
struct KuroStaticLibrary_RemoveFromRoot final
{
public:
	class UObject*                                InObject;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_RemoveFromRoot) == 0x000008, "Wrong alignment on KuroStaticLibrary_RemoveFromRoot");
static_assert(sizeof(KuroStaticLibrary_RemoveFromRoot) == 0x000008, "Wrong size on KuroStaticLibrary_RemoveFromRoot");
static_assert(offsetof(KuroStaticLibrary_RemoveFromRoot, InObject) == 0x000000, "Member 'KuroStaticLibrary_RemoveFromRoot::InObject' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SaveStringToFile
// 0x0028 (0x0028 - 0x0000)
struct KuroStaticLibrary_SaveStringToFile final
{
public:
	class FString                                 SaveText;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FileName;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithBom;                                          // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C3[0x6];                                     // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_SaveStringToFile) == 0x000008, "Wrong alignment on KuroStaticLibrary_SaveStringToFile");
static_assert(sizeof(KuroStaticLibrary_SaveStringToFile) == 0x000028, "Wrong size on KuroStaticLibrary_SaveStringToFile");
static_assert(offsetof(KuroStaticLibrary_SaveStringToFile, SaveText) == 0x000000, "Member 'KuroStaticLibrary_SaveStringToFile::SaveText' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SaveStringToFile, FileName) == 0x000010, "Member 'KuroStaticLibrary_SaveStringToFile::FileName' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SaveStringToFile, bWithBom) == 0x000020, "Member 'KuroStaticLibrary_SaveStringToFile::bWithBom' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SaveStringToFile, ReturnValue) == 0x000021, "Member 'KuroStaticLibrary_SaveStringToFile::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SetActorModify
// 0x0008 (0x0008 - 0x0000)
struct KuroStaticLibrary_SetActorModify final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_SetActorModify) == 0x000008, "Wrong alignment on KuroStaticLibrary_SetActorModify");
static_assert(sizeof(KuroStaticLibrary_SetActorModify) == 0x000008, "Wrong size on KuroStaticLibrary_SetActorModify");
static_assert(offsetof(KuroStaticLibrary_SetActorModify, Actor) == 0x000000, "Member 'KuroStaticLibrary_SetActorModify::Actor' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SetActorPermanent
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_SetActorPermanent final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPermanent;                                      // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWithAllChildren;                                  // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C4[0x6];                                     // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_SetActorPermanent) == 0x000008, "Wrong alignment on KuroStaticLibrary_SetActorPermanent");
static_assert(sizeof(KuroStaticLibrary_SetActorPermanent) == 0x000010, "Wrong size on KuroStaticLibrary_SetActorPermanent");
static_assert(offsetof(KuroStaticLibrary_SetActorPermanent, Actor) == 0x000000, "Member 'KuroStaticLibrary_SetActorPermanent::Actor' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SetActorPermanent, bIsPermanent) == 0x000008, "Member 'KuroStaticLibrary_SetActorPermanent::bIsPermanent' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SetActorPermanent, bWithAllChildren) == 0x000009, "Member 'KuroStaticLibrary_SetActorPermanent::bWithAllChildren' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SetBaseAndSaveBaseLocation
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_SetBaseAndSaveBaseLocation final
{
public:
	class UCharacterMovementComponent*            CharacterMovementComp;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    NewBase;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_SetBaseAndSaveBaseLocation) == 0x000008, "Wrong alignment on KuroStaticLibrary_SetBaseAndSaveBaseLocation");
static_assert(sizeof(KuroStaticLibrary_SetBaseAndSaveBaseLocation) == 0x000010, "Wrong size on KuroStaticLibrary_SetBaseAndSaveBaseLocation");
static_assert(offsetof(KuroStaticLibrary_SetBaseAndSaveBaseLocation, CharacterMovementComp) == 0x000000, "Member 'KuroStaticLibrary_SetBaseAndSaveBaseLocation::CharacterMovementComp' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SetBaseAndSaveBaseLocation, NewBase) == 0x000008, "Member 'KuroStaticLibrary_SetBaseAndSaveBaseLocation::NewBase' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SetEditorWidgetSkipTick
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticLibrary_SetEditorWidgetSkipTick final
{
public:
	bool                                          bSkipTick;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_SetEditorWidgetSkipTick) == 0x000001, "Wrong alignment on KuroStaticLibrary_SetEditorWidgetSkipTick");
static_assert(sizeof(KuroStaticLibrary_SetEditorWidgetSkipTick) == 0x000001, "Wrong size on KuroStaticLibrary_SetEditorWidgetSkipTick");
static_assert(offsetof(KuroStaticLibrary_SetEditorWidgetSkipTick, bSkipTick) == 0x000000, "Member 'KuroStaticLibrary_SetEditorWidgetSkipTick::bSkipTick' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SetGameThreadAffinity
// 0x0001 (0x0001 - 0x0000)
struct KuroStaticLibrary_SetGameThreadAffinity final
{
public:
	bool                                          bIsInFighting;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_SetGameThreadAffinity) == 0x000001, "Wrong alignment on KuroStaticLibrary_SetGameThreadAffinity");
static_assert(sizeof(KuroStaticLibrary_SetGameThreadAffinity) == 0x000001, "Wrong size on KuroStaticLibrary_SetGameThreadAffinity");
static_assert(offsetof(KuroStaticLibrary_SetGameThreadAffinity, bIsInFighting) == 0x000000, "Member 'KuroStaticLibrary_SetGameThreadAffinity::bIsInFighting' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SetMontageANIndex
// 0x0008 (0x0008 - 0x0000)
struct KuroStaticLibrary_SetMontageANIndex final
{
public:
	const class UAnimMontage*                     AnimMontage;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_SetMontageANIndex) == 0x000008, "Wrong alignment on KuroStaticLibrary_SetMontageANIndex");
static_assert(sizeof(KuroStaticLibrary_SetMontageANIndex) == 0x000008, "Wrong size on KuroStaticLibrary_SetMontageANIndex");
static_assert(offsetof(KuroStaticLibrary_SetMontageANIndex, AnimMontage) == 0x000000, "Member 'KuroStaticLibrary_SetMontageANIndex::AnimMontage' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SetSplinePointsWithType
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_SetSplinePointsWithType final
{
public:
	class USplineComponent*                       Spline;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplinePointType                              Type;                                              // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x001A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C5[0x5];                                     // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_SetSplinePointsWithType) == 0x000008, "Wrong alignment on KuroStaticLibrary_SetSplinePointsWithType");
static_assert(sizeof(KuroStaticLibrary_SetSplinePointsWithType) == 0x000020, "Wrong size on KuroStaticLibrary_SetSplinePointsWithType");
static_assert(offsetof(KuroStaticLibrary_SetSplinePointsWithType, Spline) == 0x000000, "Member 'KuroStaticLibrary_SetSplinePointsWithType::Spline' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SetSplinePointsWithType, Points) == 0x000008, "Member 'KuroStaticLibrary_SetSplinePointsWithType::Points' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SetSplinePointsWithType, CoordinateSpace) == 0x000018, "Member 'KuroStaticLibrary_SetSplinePointsWithType::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SetSplinePointsWithType, Type) == 0x000019, "Member 'KuroStaticLibrary_SetSplinePointsWithType::Type' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SetSplinePointsWithType, bUpdateSpline) == 0x00001A, "Member 'KuroStaticLibrary_SetSplinePointsWithType::bUpdateSpline' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SetStaticMeshVelocity
// 0x0020 (0x0020 - 0x0000)
struct KuroStaticLibrary_SetStaticMeshVelocity final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                NewVelocity;                                       // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C6[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_SetStaticMeshVelocity) == 0x000008, "Wrong alignment on KuroStaticLibrary_SetStaticMeshVelocity");
static_assert(sizeof(KuroStaticLibrary_SetStaticMeshVelocity) == 0x000020, "Wrong size on KuroStaticLibrary_SetStaticMeshVelocity");
static_assert(offsetof(KuroStaticLibrary_SetStaticMeshVelocity, Actors) == 0x000000, "Member 'KuroStaticLibrary_SetStaticMeshVelocity::Actors' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SetStaticMeshVelocity, NewVelocity) == 0x000010, "Member 'KuroStaticLibrary_SetStaticMeshVelocity::NewVelocity' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.SpawnActorFromAnother
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_SpawnActorFromAnother final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Parent;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_SpawnActorFromAnother) == 0x000008, "Wrong alignment on KuroStaticLibrary_SpawnActorFromAnother");
static_assert(sizeof(KuroStaticLibrary_SpawnActorFromAnother) == 0x000018, "Wrong size on KuroStaticLibrary_SpawnActorFromAnother");
static_assert(offsetof(KuroStaticLibrary_SpawnActorFromAnother, Actor) == 0x000000, "Member 'KuroStaticLibrary_SpawnActorFromAnother::Actor' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SpawnActorFromAnother, Parent) == 0x000008, "Member 'KuroStaticLibrary_SpawnActorFromAnother::Parent' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_SpawnActorFromAnother, ReturnValue) == 0x000010, "Member 'KuroStaticLibrary_SpawnActorFromAnother::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.StopAllMontagesBySlotName
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_StopAllMontagesBySlotName final
{
public:
	class UAnimInstance*                          UAnimInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSlotName;                                        // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendOutTime;                                    // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_StopAllMontagesBySlotName) == 0x000008, "Wrong alignment on KuroStaticLibrary_StopAllMontagesBySlotName");
static_assert(sizeof(KuroStaticLibrary_StopAllMontagesBySlotName) == 0x000018, "Wrong size on KuroStaticLibrary_StopAllMontagesBySlotName");
static_assert(offsetof(KuroStaticLibrary_StopAllMontagesBySlotName, UAnimInstance) == 0x000000, "Member 'KuroStaticLibrary_StopAllMontagesBySlotName::UAnimInstance' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_StopAllMontagesBySlotName, InSlotName) == 0x000008, "Member 'KuroStaticLibrary_StopAllMontagesBySlotName::InSlotName' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_StopAllMontagesBySlotName, InBlendOutTime) == 0x000014, "Member 'KuroStaticLibrary_StopAllMontagesBySlotName::InBlendOutTime' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ToggleSequenceNodeActiveByTag
// 0x0018 (0x0018 - 0x0000)
struct KuroStaticLibrary_ToggleSequenceNodeActiveByTag final
{
public:
	const class ALevelSequenceActor*              Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C7[0x2];                                     // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_ToggleSequenceNodeActiveByTag) == 0x000008, "Wrong alignment on KuroStaticLibrary_ToggleSequenceNodeActiveByTag");
static_assert(sizeof(KuroStaticLibrary_ToggleSequenceNodeActiveByTag) == 0x000018, "Wrong size on KuroStaticLibrary_ToggleSequenceNodeActiveByTag");
static_assert(offsetof(KuroStaticLibrary_ToggleSequenceNodeActiveByTag, Actor) == 0x000000, "Member 'KuroStaticLibrary_ToggleSequenceNodeActiveByTag::Actor' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ToggleSequenceNodeActiveByTag, TagName) == 0x000008, "Member 'KuroStaticLibrary_ToggleSequenceNodeActiveByTag::TagName' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ToggleSequenceNodeActiveByTag, bActive) == 0x000014, "Member 'KuroStaticLibrary_ToggleSequenceNodeActiveByTag::bActive' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ToggleSequenceNodeActiveByTag, ReturnValue) == 0x000015, "Member 'KuroStaticLibrary_ToggleSequenceNodeActiveByTag::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.ToUnixTimestamp
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_ToUnixTimestamp final
{
public:
	struct FDateTime                              InDataTime;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C8[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroStaticLibrary_ToUnixTimestamp) == 0x000008, "Wrong alignment on KuroStaticLibrary_ToUnixTimestamp");
static_assert(sizeof(KuroStaticLibrary_ToUnixTimestamp) == 0x000010, "Wrong size on KuroStaticLibrary_ToUnixTimestamp");
static_assert(offsetof(KuroStaticLibrary_ToUnixTimestamp, InDataTime) == 0x000000, "Member 'KuroStaticLibrary_ToUnixTimestamp::InDataTime' has a wrong offset!");
static_assert(offsetof(KuroStaticLibrary_ToUnixTimestamp, ReturnValue) == 0x000008, "Member 'KuroStaticLibrary_ToUnixTimestamp::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroStaticLibrary.UnRegisterCustomCommandProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroStaticLibrary_UnRegisterCustomCommandProcessor final
{
public:
	class FString                                 Category;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroStaticLibrary_UnRegisterCustomCommandProcessor) == 0x000008, "Wrong alignment on KuroStaticLibrary_UnRegisterCustomCommandProcessor");
static_assert(sizeof(KuroStaticLibrary_UnRegisterCustomCommandProcessor) == 0x000010, "Wrong size on KuroStaticLibrary_UnRegisterCustomCommandProcessor");
static_assert(offsetof(KuroStaticLibrary_UnRegisterCustomCommandProcessor, Category) == 0x000000, "Member 'KuroStaticLibrary_UnRegisterCustomCommandProcessor::Category' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.EnableAuthorization
// 0x0001 (0x0001 - 0x0000)
struct KuroTencentCOSLibrary_EnableAuthorization final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_EnableAuthorization) == 0x000001, "Wrong alignment on KuroTencentCOSLibrary_EnableAuthorization");
static_assert(sizeof(KuroTencentCOSLibrary_EnableAuthorization) == 0x000001, "Wrong size on KuroTencentCOSLibrary_EnableAuthorization");
static_assert(offsetof(KuroTencentCOSLibrary_EnableAuthorization, Enable) == 0x000000, "Member 'KuroTencentCOSLibrary_EnableAuthorization::Enable' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.GetAllFileNumNeedToSend
// 0x0004 (0x0004 - 0x0000)
struct KuroTencentCOSLibrary_GetAllFileNumNeedToSend final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_GetAllFileNumNeedToSend) == 0x000004, "Wrong alignment on KuroTencentCOSLibrary_GetAllFileNumNeedToSend");
static_assert(sizeof(KuroTencentCOSLibrary_GetAllFileNumNeedToSend) == 0x000004, "Wrong size on KuroTencentCOSLibrary_GetAllFileNumNeedToSend");
static_assert(offsetof(KuroTencentCOSLibrary_GetAllFileNumNeedToSend, ReturnValue) == 0x000000, "Member 'KuroTencentCOSLibrary_GetAllFileNumNeedToSend::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.GetSendedFileNum
// 0x0004 (0x0004 - 0x0000)
struct KuroTencentCOSLibrary_GetSendedFileNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_GetSendedFileNum) == 0x000004, "Wrong alignment on KuroTencentCOSLibrary_GetSendedFileNum");
static_assert(sizeof(KuroTencentCOSLibrary_GetSendedFileNum) == 0x000004, "Wrong size on KuroTencentCOSLibrary_GetSendedFileNum");
static_assert(offsetof(KuroTencentCOSLibrary_GetSendedFileNum, ReturnValue) == 0x000000, "Member 'KuroTencentCOSLibrary_GetSendedFileNum::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.IsSending
// 0x0001 (0x0001 - 0x0000)
struct KuroTencentCOSLibrary_IsSending final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_IsSending) == 0x000001, "Wrong alignment on KuroTencentCOSLibrary_IsSending");
static_assert(sizeof(KuroTencentCOSLibrary_IsSending) == 0x000001, "Wrong size on KuroTencentCOSLibrary_IsSending");
static_assert(offsetof(KuroTencentCOSLibrary_IsSending, ReturnValue) == 0x000000, "Member 'KuroTencentCOSLibrary_IsSending::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.SendFileToTencentCOS
// 0x0060 (0x0060 - 0x0000)
struct KuroTencentCOSLibrary_SendFileToTencentCOS final
{
public:
	class FString                                 Path;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RemoteURI;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecretID;                                          // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecretKey;                                         // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BucketName;                                        // 0x0040(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Region;                                            // 0x0050(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_SendFileToTencentCOS) == 0x000008, "Wrong alignment on KuroTencentCOSLibrary_SendFileToTencentCOS");
static_assert(sizeof(KuroTencentCOSLibrary_SendFileToTencentCOS) == 0x000060, "Wrong size on KuroTencentCOSLibrary_SendFileToTencentCOS");
static_assert(offsetof(KuroTencentCOSLibrary_SendFileToTencentCOS, Path) == 0x000000, "Member 'KuroTencentCOSLibrary_SendFileToTencentCOS::Path' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SendFileToTencentCOS, RemoteURI) == 0x000010, "Member 'KuroTencentCOSLibrary_SendFileToTencentCOS::RemoteURI' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SendFileToTencentCOS, SecretID) == 0x000020, "Member 'KuroTencentCOSLibrary_SendFileToTencentCOS::SecretID' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SendFileToTencentCOS, SecretKey) == 0x000030, "Member 'KuroTencentCOSLibrary_SendFileToTencentCOS::SecretKey' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SendFileToTencentCOS, BucketName) == 0x000040, "Member 'KuroTencentCOSLibrary_SendFileToTencentCOS::BucketName' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SendFileToTencentCOS, Region) == 0x000050, "Member 'KuroTencentCOSLibrary_SendFileToTencentCOS::Region' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.SendLogToTencentCOS
// 0x0014 (0x0014 - 0x0000)
struct KuroTencentCOSLibrary_SendLogToTencentCOS final
{
public:
	TDelegate<void(int32 State, float Rate)>      OnProgress;                                        // 0x0000(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_SendLogToTencentCOS) == 0x000004, "Wrong alignment on KuroTencentCOSLibrary_SendLogToTencentCOS");
static_assert(sizeof(KuroTencentCOSLibrary_SendLogToTencentCOS) == 0x000014, "Wrong size on KuroTencentCOSLibrary_SendLogToTencentCOS");
static_assert(offsetof(KuroTencentCOSLibrary_SendLogToTencentCOS, OnProgress) == 0x000000, "Member 'KuroTencentCOSLibrary_SendLogToTencentCOS::OnProgress' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.SetAdmissibleValue
// 0x0004 (0x0004 - 0x0000)
struct KuroTencentCOSLibrary_SetAdmissibleValue final
{
public:
	int32                                         SingleLogSizeInMb;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_SetAdmissibleValue) == 0x000004, "Wrong alignment on KuroTencentCOSLibrary_SetAdmissibleValue");
static_assert(sizeof(KuroTencentCOSLibrary_SetAdmissibleValue) == 0x000004, "Wrong size on KuroTencentCOSLibrary_SetAdmissibleValue");
static_assert(offsetof(KuroTencentCOSLibrary_SetAdmissibleValue, SingleLogSizeInMb) == 0x000000, "Member 'KuroTencentCOSLibrary_SetAdmissibleValue::SingleLogSizeInMb' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.SetFilesToSend
// 0x0010 (0x0010 - 0x0000)
struct KuroTencentCOSLibrary_SetFilesToSend final
{
public:
	TArray<class FString>                         FilePaths;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_SetFilesToSend) == 0x000008, "Wrong alignment on KuroTencentCOSLibrary_SetFilesToSend");
static_assert(sizeof(KuroTencentCOSLibrary_SetFilesToSend) == 0x000010, "Wrong size on KuroTencentCOSLibrary_SetFilesToSend");
static_assert(offsetof(KuroTencentCOSLibrary_SetFilesToSend, FilePaths) == 0x000000, "Member 'KuroTencentCOSLibrary_SetFilesToSend::FilePaths' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.SetHandleFunc
// 0x0028 (0x0028 - 0x0000)
struct KuroTencentCOSLibrary_SetHandleFunc final
{
public:
	TDelegate<void(TArray<class FString>& FileNames)> PrepareFunc;                                       // 0x0000(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(TArray<class FString>& SendedFiles)> PostSend;                                          // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_SetHandleFunc) == 0x000004, "Wrong alignment on KuroTencentCOSLibrary_SetHandleFunc");
static_assert(sizeof(KuroTencentCOSLibrary_SetHandleFunc) == 0x000028, "Wrong size on KuroTencentCOSLibrary_SetHandleFunc");
static_assert(offsetof(KuroTencentCOSLibrary_SetHandleFunc, PrepareFunc) == 0x000000, "Member 'KuroTencentCOSLibrary_SetHandleFunc::PrepareFunc' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SetHandleFunc, PostSend) == 0x000014, "Member 'KuroTencentCOSLibrary_SetHandleFunc::PostSend' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.SetIsAutoSend
// 0x0001 (0x0001 - 0x0000)
struct KuroTencentCOSLibrary_SetIsAutoSend final
{
public:
	bool                                          bIsAutoSend;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_SetIsAutoSend) == 0x000001, "Wrong alignment on KuroTencentCOSLibrary_SetIsAutoSend");
static_assert(sizeof(KuroTencentCOSLibrary_SetIsAutoSend) == 0x000001, "Wrong size on KuroTencentCOSLibrary_SetIsAutoSend");
static_assert(offsetof(KuroTencentCOSLibrary_SetIsAutoSend, bIsAutoSend) == 0x000000, "Member 'KuroTencentCOSLibrary_SetIsAutoSend::bIsAutoSend' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.SetSendLogConfig
// 0x0040 (0x0040 - 0x0000)
struct KuroTencentCOSLibrary_SetSendLogConfig final
{
public:
	class FString                                 SecretID;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SecretKey;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BucketName;                                        // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Region;                                            // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_SetSendLogConfig) == 0x000008, "Wrong alignment on KuroTencentCOSLibrary_SetSendLogConfig");
static_assert(sizeof(KuroTencentCOSLibrary_SetSendLogConfig) == 0x000040, "Wrong size on KuroTencentCOSLibrary_SetSendLogConfig");
static_assert(offsetof(KuroTencentCOSLibrary_SetSendLogConfig, SecretID) == 0x000000, "Member 'KuroTencentCOSLibrary_SetSendLogConfig::SecretID' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SetSendLogConfig, SecretKey) == 0x000010, "Member 'KuroTencentCOSLibrary_SetSendLogConfig::SecretKey' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SetSendLogConfig, BucketName) == 0x000020, "Member 'KuroTencentCOSLibrary_SetSendLogConfig::BucketName' has a wrong offset!");
static_assert(offsetof(KuroTencentCOSLibrary_SetSendLogConfig, Region) == 0x000030, "Member 'KuroTencentCOSLibrary_SetSendLogConfig::Region' has a wrong offset!");

// Function KuroUtility.KuroTencentCOSLibrary.SetSendLogZipName
// 0x0010 (0x0010 - 0x0000)
struct KuroTencentCOSLibrary_SetSendLogZipName final
{
public:
	class FString                                 ZipFileName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTencentCOSLibrary_SetSendLogZipName) == 0x000008, "Wrong alignment on KuroTencentCOSLibrary_SetSendLogZipName");
static_assert(sizeof(KuroTencentCOSLibrary_SetSendLogZipName) == 0x000010, "Wrong size on KuroTencentCOSLibrary_SetSendLogZipName");
static_assert(offsetof(KuroTencentCOSLibrary_SetSendLogZipName, ZipFileName) == 0x000000, "Member 'KuroTencentCOSLibrary_SetSendLogZipName::ZipFileName' has a wrong offset!");

// Function KuroUtility.KuroTickableManager.CreateTickableFunc
// 0x0020 (0x0020 - 0x0000)
struct KuroTickableManager_CreateTickableFunc final
{
public:
	class UObject*                                InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float DeltaSeconds)>           TickableHandler;                                   // 0x0008(0x0014)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19CA[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroTickableManager_CreateTickableFunc) == 0x000008, "Wrong alignment on KuroTickableManager_CreateTickableFunc");
static_assert(sizeof(KuroTickableManager_CreateTickableFunc) == 0x000020, "Wrong size on KuroTickableManager_CreateTickableFunc");
static_assert(offsetof(KuroTickableManager_CreateTickableFunc, InOwner) == 0x000000, "Member 'KuroTickableManager_CreateTickableFunc::InOwner' has a wrong offset!");
static_assert(offsetof(KuroTickableManager_CreateTickableFunc, TickableHandler) == 0x000008, "Member 'KuroTickableManager_CreateTickableFunc::TickableHandler' has a wrong offset!");

// Function KuroUtility.KuroTickableManager.RemoveTickableFunc
// 0x0008 (0x0008 - 0x0000)
struct KuroTickableManager_RemoveTickableFunc final
{
public:
	class UObject*                                InOwner;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTickableManager_RemoveTickableFunc) == 0x000008, "Wrong alignment on KuroTickableManager_RemoveTickableFunc");
static_assert(sizeof(KuroTickableManager_RemoveTickableFunc) == 0x000008, "Wrong size on KuroTickableManager_RemoveTickableFunc");
static_assert(offsetof(KuroTickableManager_RemoveTickableFunc, InOwner) == 0x000000, "Member 'KuroTickableManager_RemoveTickableFunc::InOwner' has a wrong offset!");

// Function KuroUtility.KuroTriggerVolumeManager.GetKuroTriggerVolume
// 0x0018 (0x0018 - 0x0000)
struct KuroTriggerVolumeManager_GetKuroTriggerVolume final
{
public:
	class FName                                   ActorKey;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19CC[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTriggerVolumeManager_GetKuroTriggerVolume) == 0x000008, "Wrong alignment on KuroTriggerVolumeManager_GetKuroTriggerVolume");
static_assert(sizeof(KuroTriggerVolumeManager_GetKuroTriggerVolume) == 0x000018, "Wrong size on KuroTriggerVolumeManager_GetKuroTriggerVolume");
static_assert(offsetof(KuroTriggerVolumeManager_GetKuroTriggerVolume, ActorKey) == 0x000000, "Member 'KuroTriggerVolumeManager_GetKuroTriggerVolume::ActorKey' has a wrong offset!");
static_assert(offsetof(KuroTriggerVolumeManager_GetKuroTriggerVolume, ReturnValue) == 0x000010, "Member 'KuroTriggerVolumeManager_GetKuroTriggerVolume::ReturnValue' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.BindBeginLoadMap
// 0x0014 (0x0014 - 0x0000)
struct LoadMapNotify_BindBeginLoadMap final
{
public:
	TDelegate<void(const class FString& MapName)> BeginLoadMapHandler;                               // 0x0000(0x0014)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_BindBeginLoadMap) == 0x000004, "Wrong alignment on LoadMapNotify_BindBeginLoadMap");
static_assert(sizeof(LoadMapNotify_BindBeginLoadMap) == 0x000014, "Wrong size on LoadMapNotify_BindBeginLoadMap");
static_assert(offsetof(LoadMapNotify_BindBeginLoadMap, BeginLoadMapHandler) == 0x000000, "Member 'LoadMapNotify_BindBeginLoadMap::BeginLoadMapHandler' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.BindBeginTravelLoadMap
// 0x0014 (0x0014 - 0x0000)
struct LoadMapNotify_BindBeginTravelLoadMap final
{
public:
	TDelegate<void(const class FString& MapName)> BeginTravelLoadMapHandler;                         // 0x0000(0x0014)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_BindBeginTravelLoadMap) == 0x000004, "Wrong alignment on LoadMapNotify_BindBeginTravelLoadMap");
static_assert(sizeof(LoadMapNotify_BindBeginTravelLoadMap) == 0x000014, "Wrong size on LoadMapNotify_BindBeginTravelLoadMap");
static_assert(offsetof(LoadMapNotify_BindBeginTravelLoadMap, BeginTravelLoadMapHandler) == 0x000000, "Member 'LoadMapNotify_BindBeginTravelLoadMap::BeginTravelLoadMapHandler' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.BindEndLoadMap
// 0x0014 (0x0014 - 0x0000)
struct LoadMapNotify_BindEndLoadMap final
{
public:
	TDelegate<void(const class FString& MapName)> EndLoadMapHandler;                                 // 0x0000(0x0014)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_BindEndLoadMap) == 0x000004, "Wrong alignment on LoadMapNotify_BindEndLoadMap");
static_assert(sizeof(LoadMapNotify_BindEndLoadMap) == 0x000014, "Wrong size on LoadMapNotify_BindEndLoadMap");
static_assert(offsetof(LoadMapNotify_BindEndLoadMap, EndLoadMapHandler) == 0x000000, "Member 'LoadMapNotify_BindEndLoadMap::EndLoadMapHandler' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.BindEndLoadTransitionMap
// 0x0014 (0x0014 - 0x0000)
struct LoadMapNotify_BindEndLoadTransitionMap final
{
public:
	TDelegate<void()>                             EndLoadTransitionMapHandler;                       // 0x0000(0x0014)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_BindEndLoadTransitionMap) == 0x000004, "Wrong alignment on LoadMapNotify_BindEndLoadTransitionMap");
static_assert(sizeof(LoadMapNotify_BindEndLoadTransitionMap) == 0x000014, "Wrong size on LoadMapNotify_BindEndLoadTransitionMap");
static_assert(offsetof(LoadMapNotify_BindEndLoadTransitionMap, EndLoadTransitionMapHandler) == 0x000000, "Member 'LoadMapNotify_BindEndLoadTransitionMap::EndLoadTransitionMapHandler' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.BindLoadStreamLevel
// 0x0014 (0x0014 - 0x0000)
struct LoadMapNotify_BindLoadStreamLevel final
{
public:
	TDelegate<void(int32 LinkId, class FName& LevelName, class ULevelStreaming* StreamingLevel)> LoadStreamLevelHandler;                            // 0x0000(0x0014)(ConstParm, Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_BindLoadStreamLevel) == 0x000004, "Wrong alignment on LoadMapNotify_BindLoadStreamLevel");
static_assert(sizeof(LoadMapNotify_BindLoadStreamLevel) == 0x000014, "Wrong size on LoadMapNotify_BindLoadStreamLevel");
static_assert(offsetof(LoadMapNotify_BindLoadStreamLevel, LoadStreamLevelHandler) == 0x000000, "Member 'LoadMapNotify_BindLoadStreamLevel::LoadStreamLevelHandler' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.BindUnLoadStreamLevel
// 0x0014 (0x0014 - 0x0000)
struct LoadMapNotify_BindUnLoadStreamLevel final
{
public:
	TDelegate<void(int32 LinkId, class FName& LevelName)> UnLoadStreamLevelHandler;                          // 0x0000(0x0014)(ConstParm, Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_BindUnLoadStreamLevel) == 0x000004, "Wrong alignment on LoadMapNotify_BindUnLoadStreamLevel");
static_assert(sizeof(LoadMapNotify_BindUnLoadStreamLevel) == 0x000014, "Wrong size on LoadMapNotify_BindUnLoadStreamLevel");
static_assert(offsetof(LoadMapNotify_BindUnLoadStreamLevel, UnLoadStreamLevelHandler) == 0x000000, "Member 'LoadMapNotify_BindUnLoadStreamLevel::UnLoadStreamLevelHandler' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.LoadStreamLevel
// 0x0014 (0x0014 - 0x0000)
struct LoadMapNotify_LoadStreamLevel final
{
public:
	class FName                                   Path;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeVisibleAfterLoad;                             // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockOnLoad;                                // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19CE[0x2];                                     // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_LoadStreamLevel) == 0x000004, "Wrong alignment on LoadMapNotify_LoadStreamLevel");
static_assert(sizeof(LoadMapNotify_LoadStreamLevel) == 0x000014, "Wrong size on LoadMapNotify_LoadStreamLevel");
static_assert(offsetof(LoadMapNotify_LoadStreamLevel, Path) == 0x000000, "Member 'LoadMapNotify_LoadStreamLevel::Path' has a wrong offset!");
static_assert(offsetof(LoadMapNotify_LoadStreamLevel, bMakeVisibleAfterLoad) == 0x00000C, "Member 'LoadMapNotify_LoadStreamLevel::bMakeVisibleAfterLoad' has a wrong offset!");
static_assert(offsetof(LoadMapNotify_LoadStreamLevel, bShouldBlockOnLoad) == 0x00000D, "Member 'LoadMapNotify_LoadStreamLevel::bShouldBlockOnLoad' has a wrong offset!");
static_assert(offsetof(LoadMapNotify_LoadStreamLevel, ReturnValue) == 0x000010, "Member 'LoadMapNotify_LoadStreamLevel::ReturnValue' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.OnLoadStreamLevel
// 0x0004 (0x0004 - 0x0000)
struct LoadMapNotify_OnLoadStreamLevel final
{
public:
	int32                                         LinkID;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_OnLoadStreamLevel) == 0x000004, "Wrong alignment on LoadMapNotify_OnLoadStreamLevel");
static_assert(sizeof(LoadMapNotify_OnLoadStreamLevel) == 0x000004, "Wrong size on LoadMapNotify_OnLoadStreamLevel");
static_assert(offsetof(LoadMapNotify_OnLoadStreamLevel, LinkID) == 0x000000, "Member 'LoadMapNotify_OnLoadStreamLevel::LinkID' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.OnUnLoadStreamLevel
// 0x0004 (0x0004 - 0x0000)
struct LoadMapNotify_OnUnLoadStreamLevel final
{
public:
	int32                                         LinkID;                                            // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_OnUnLoadStreamLevel) == 0x000004, "Wrong alignment on LoadMapNotify_OnUnLoadStreamLevel");
static_assert(sizeof(LoadMapNotify_OnUnLoadStreamLevel) == 0x000004, "Wrong size on LoadMapNotify_OnUnLoadStreamLevel");
static_assert(offsetof(LoadMapNotify_OnUnLoadStreamLevel, LinkID) == 0x000000, "Member 'LoadMapNotify_OnUnLoadStreamLevel::LinkID' has a wrong offset!");

// Function KuroUtility.LoadMapNotify.UnloadStreamLevel
// 0x0014 (0x0014 - 0x0000)
struct LoadMapNotify_UnloadStreamLevel final
{
public:
	class FName                                   Path;                                              // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockOnLoad;                                // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19CF[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LoadMapNotify_UnloadStreamLevel) == 0x000004, "Wrong alignment on LoadMapNotify_UnloadStreamLevel");
static_assert(sizeof(LoadMapNotify_UnloadStreamLevel) == 0x000014, "Wrong size on LoadMapNotify_UnloadStreamLevel");
static_assert(offsetof(LoadMapNotify_UnloadStreamLevel, Path) == 0x000000, "Member 'LoadMapNotify_UnloadStreamLevel::Path' has a wrong offset!");
static_assert(offsetof(LoadMapNotify_UnloadStreamLevel, bShouldBlockOnLoad) == 0x00000C, "Member 'LoadMapNotify_UnloadStreamLevel::bShouldBlockOnLoad' has a wrong offset!");
static_assert(offsetof(LoadMapNotify_UnloadStreamLevel, ReturnValue) == 0x000010, "Member 'LoadMapNotify_UnloadStreamLevel::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroTickManager.AddPrerequisiteActorComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroTickManager_AddPrerequisiteActorComponent final
{
public:
	ETickingGroup                                 TickingGroup;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D1[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        ActorComp;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTickManager_AddPrerequisiteActorComponent) == 0x000008, "Wrong alignment on KuroTickManager_AddPrerequisiteActorComponent");
static_assert(sizeof(KuroTickManager_AddPrerequisiteActorComponent) == 0x000010, "Wrong size on KuroTickManager_AddPrerequisiteActorComponent");
static_assert(offsetof(KuroTickManager_AddPrerequisiteActorComponent, TickingGroup) == 0x000000, "Member 'KuroTickManager_AddPrerequisiteActorComponent::TickingGroup' has a wrong offset!");
static_assert(offsetof(KuroTickManager_AddPrerequisiteActorComponent, ActorComp) == 0x000008, "Member 'KuroTickManager_AddPrerequisiteActorComponent::ActorComp' has a wrong offset!");

// Function KuroUtility.KuroTickManager.AddTick
// 0x001C (0x001C - 0x0000)
struct KuroTickManager_AddTick final
{
public:
	ETickingGroup                                 TickingGroup;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D2[0x3];                                     // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(float DeltaSeconds)>           TickHandler;                                       // 0x0004(0x0014)(ConstParm, Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D3[0x3];                                     // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroTickManager_AddTick) == 0x000004, "Wrong alignment on KuroTickManager_AddTick");
static_assert(sizeof(KuroTickManager_AddTick) == 0x00001C, "Wrong size on KuroTickManager_AddTick");
static_assert(offsetof(KuroTickManager_AddTick, TickingGroup) == 0x000000, "Member 'KuroTickManager_AddTick::TickingGroup' has a wrong offset!");
static_assert(offsetof(KuroTickManager_AddTick, TickHandler) == 0x000004, "Member 'KuroTickManager_AddTick::TickHandler' has a wrong offset!");
static_assert(offsetof(KuroTickManager_AddTick, ReturnValue) == 0x000018, "Member 'KuroTickManager_AddTick::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroTickManager.CleanSkeletalMeshProxyTickFunction
// 0x0008 (0x0008 - 0x0000)
struct KuroTickManager_CleanSkeletalMeshProxyTickFunction final
{
public:
	class USkeletalMeshComponent*                 SkelComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTickManager_CleanSkeletalMeshProxyTickFunction) == 0x000008, "Wrong alignment on KuroTickManager_CleanSkeletalMeshProxyTickFunction");
static_assert(sizeof(KuroTickManager_CleanSkeletalMeshProxyTickFunction) == 0x000008, "Wrong size on KuroTickManager_CleanSkeletalMeshProxyTickFunction");
static_assert(offsetof(KuroTickManager_CleanSkeletalMeshProxyTickFunction, SkelComp) == 0x000000, "Member 'KuroTickManager_CleanSkeletalMeshProxyTickFunction::SkelComp' has a wrong offset!");

// Function KuroUtility.KuroTickManager.RemovePrerequisiteActorComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroTickManager_RemovePrerequisiteActorComponent final
{
public:
	ETickingGroup                                 TickingGroup;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D4[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        ActorComp;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTickManager_RemovePrerequisiteActorComponent) == 0x000008, "Wrong alignment on KuroTickManager_RemovePrerequisiteActorComponent");
static_assert(sizeof(KuroTickManager_RemovePrerequisiteActorComponent) == 0x000010, "Wrong size on KuroTickManager_RemovePrerequisiteActorComponent");
static_assert(offsetof(KuroTickManager_RemovePrerequisiteActorComponent, TickingGroup) == 0x000000, "Member 'KuroTickManager_RemovePrerequisiteActorComponent::TickingGroup' has a wrong offset!");
static_assert(offsetof(KuroTickManager_RemovePrerequisiteActorComponent, ActorComp) == 0x000008, "Member 'KuroTickManager_RemovePrerequisiteActorComponent::ActorComp' has a wrong offset!");

// Function KuroUtility.KuroTickManager.RemoveTick
// 0x0002 (0x0002 - 0x0000)
struct KuroTickManager_RemoveTick final
{
public:
	ETickingGroup                                 TickingGroup;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTickManager_RemoveTick) == 0x000001, "Wrong alignment on KuroTickManager_RemoveTick");
static_assert(sizeof(KuroTickManager_RemoveTick) == 0x000002, "Wrong size on KuroTickManager_RemoveTick");
static_assert(offsetof(KuroTickManager_RemoveTick, TickingGroup) == 0x000000, "Member 'KuroTickManager_RemoveTick::TickingGroup' has a wrong offset!");
static_assert(offsetof(KuroTickManager_RemoveTick, ReturnValue) == 0x000001, "Member 'KuroTickManager_RemoveTick::ReturnValue' has a wrong offset!");

// Function KuroUtility.KuroTickManager.SetSkeletalMeshProxyTickFunction
// 0x0010 (0x0010 - 0x0000)
struct KuroTickManager_SetSkeletalMeshProxyTickFunction final
{
public:
	ETickingGroup                                 TickingGroup;                                      // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D5[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkelComp;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTickManager_SetSkeletalMeshProxyTickFunction) == 0x000008, "Wrong alignment on KuroTickManager_SetSkeletalMeshProxyTickFunction");
static_assert(sizeof(KuroTickManager_SetSkeletalMeshProxyTickFunction) == 0x000010, "Wrong size on KuroTickManager_SetSkeletalMeshProxyTickFunction");
static_assert(offsetof(KuroTickManager_SetSkeletalMeshProxyTickFunction, TickingGroup) == 0x000000, "Member 'KuroTickManager_SetSkeletalMeshProxyTickFunction::TickingGroup' has a wrong offset!");
static_assert(offsetof(KuroTickManager_SetSkeletalMeshProxyTickFunction, SkelComp) == 0x000008, "Member 'KuroTickManager_SetSkeletalMeshProxyTickFunction::SkelComp' has a wrong offset!");

}

