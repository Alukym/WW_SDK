#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroRenderingRuntimeBPPlugin

#include "Basic.hpp"

#include "Renderer_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "KuroPointCloud_structs.hpp"
#include "ProceduralMeshComponent_classes.hpp"
#include "KuroRenderingRuntimeBPPlugin_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "KuroCurve_structs.hpp"
#include "LevelSequence_classes.hpp"


namespace SDK
{

// Class KuroRenderingRuntimeBPPlugin.KuroUiSceneInfo
// 0x0050 (0x0080 - 0x0030)
class UKuroUiSceneInfo final : public UObject
{
public:
	struct FVector                                Location;                                          // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1868[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LevelName;                                         // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OptionalLevelName;                                 // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoaded;                                          // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroUiSceneLoadingState                      CurrentState;                                      // 0x0062(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1869[0x5];                                     // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class AKuroUiSceneRootActor*                  RootActor;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreamingDynamic*                 LevelStreaming;                                    // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Destroy();
	void Init(class ULevelStreamingDynamic* InLevelStreaming, class FString* InLevelName, class FString* OptionalName, struct FVector* InLocation, class UWorld* InWorld);
	void OnLevelInVisible();
	void OnLevelLoad();
	void OnLevelVisible();
	void SetLevelVisible(bool InIsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroUiSceneInfo">();
	}
	static class UKuroUiSceneInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroUiSceneInfo>();
	}
};
static_assert(alignof(UKuroUiSceneInfo) == 0x000008, "Wrong alignment on UKuroUiSceneInfo");
static_assert(sizeof(UKuroUiSceneInfo) == 0x000080, "Wrong size on UKuroUiSceneInfo");
static_assert(offsetof(UKuroUiSceneInfo, Location) == 0x000030, "Member 'UKuroUiSceneInfo::Location' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, LevelName) == 0x000040, "Member 'UKuroUiSceneInfo::LevelName' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, OptionalLevelName) == 0x000050, "Member 'UKuroUiSceneInfo::OptionalLevelName' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, IsLoaded) == 0x000060, "Member 'UKuroUiSceneInfo::IsLoaded' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, IsVisible) == 0x000061, "Member 'UKuroUiSceneInfo::IsVisible' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, CurrentState) == 0x000062, "Member 'UKuroUiSceneInfo::CurrentState' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, RootActor) == 0x000068, "Member 'UKuroUiSceneInfo::RootActor' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, LevelStreaming) == 0x000070, "Member 'UKuroUiSceneInfo::LevelStreaming' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneInfo, World) == 0x000078, "Member 'UKuroUiSceneInfo::World' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroChangeMaterialsTextures
// 0x0030 (0x0068 - 0x0038)
class UKuroChangeMaterialsTextures final : public UPrimaryDataAsset
{
public:
	class FString                                 SkeletalMeshName;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_186B[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTexture2D>>      Textures;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroChangeMaterialsTextures">();
	}
	static class UKuroChangeMaterialsTextures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroChangeMaterialsTextures>();
	}
};
static_assert(alignof(UKuroChangeMaterialsTextures) == 0x000008, "Wrong alignment on UKuroChangeMaterialsTextures");
static_assert(sizeof(UKuroChangeMaterialsTextures) == 0x000068, "Wrong size on UKuroChangeMaterialsTextures");
static_assert(offsetof(UKuroChangeMaterialsTextures, SkeletalMeshName) == 0x000038, "Member 'UKuroChangeMaterialsTextures::SkeletalMeshName' has a wrong offset!");
static_assert(offsetof(UKuroChangeMaterialsTextures, ParameterName) == 0x000048, "Member 'UKuroChangeMaterialsTextures::ParameterName' has a wrong offset!");
static_assert(offsetof(UKuroChangeMaterialsTextures, Textures) == 0x000058, "Member 'UKuroChangeMaterialsTextures::Textures' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.SplitTextureStreamerDebugActor
// 0x0070 (0x0318 - 0x02A8)
class ASplitTextureStreamerDebugActor final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroSplitTextureStreamerSettings*      StreamerSettings;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadNumPerSide;                                    // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_186C[0x4];                                     // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        LoadedTextures;                                    // 0x02C0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_186D[0x48];                                    // 0x02D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplitTextureStreamerDebugActor">();
	}
	static class ASplitTextureStreamerDebugActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplitTextureStreamerDebugActor>();
	}
};
static_assert(alignof(ASplitTextureStreamerDebugActor) == 0x000008, "Wrong alignment on ASplitTextureStreamerDebugActor");
static_assert(sizeof(ASplitTextureStreamerDebugActor) == 0x000318, "Wrong size on ASplitTextureStreamerDebugActor");
static_assert(offsetof(ASplitTextureStreamerDebugActor, SceneComponent) == 0x0002A8, "Member 'ASplitTextureStreamerDebugActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ASplitTextureStreamerDebugActor, StreamerSettings) == 0x0002B0, "Member 'ASplitTextureStreamerDebugActor::StreamerSettings' has a wrong offset!");
static_assert(offsetof(ASplitTextureStreamerDebugActor, LoadNumPerSide) == 0x0002B8, "Member 'ASplitTextureStreamerDebugActor::LoadNumPerSide' has a wrong offset!");
static_assert(offsetof(ASplitTextureStreamerDebugActor, LoadedTextures) == 0x0002C0, "Member 'ASplitTextureStreamerDebugActor::LoadedTextures' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.InteractiveLeaves
// 0x01B8 (0x0460 - 0x02A8)
class alignas(0x10) AInteractiveLeaves final : public AActor
{
public:
	class UInstancedStaticMeshComponent*          IsmComponent;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticComponent;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractiveLeavesConfigData*           Config;                                            // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKuroPointCloudCache*                   PointCache;                                        // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_186E[0x198];                                   // 0x02C8(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveLeaves">();
	}
	static class AInteractiveLeaves* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractiveLeaves>();
	}
};
static_assert(alignof(AInteractiveLeaves) == 0x000010, "Wrong alignment on AInteractiveLeaves");
static_assert(sizeof(AInteractiveLeaves) == 0x000460, "Wrong size on AInteractiveLeaves");
static_assert(offsetof(AInteractiveLeaves, IsmComponent) == 0x0002A8, "Member 'AInteractiveLeaves::IsmComponent' has a wrong offset!");
static_assert(offsetof(AInteractiveLeaves, StaticComponent) == 0x0002B0, "Member 'AInteractiveLeaves::StaticComponent' has a wrong offset!");
static_assert(offsetof(AInteractiveLeaves, Config) == 0x0002B8, "Member 'AInteractiveLeaves::Config' has a wrong offset!");
static_assert(offsetof(AInteractiveLeaves, PointCache) == 0x0002C0, "Member 'AInteractiveLeaves::PointCache' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroChangeSkeletalMaterialsComponent
// 0x0010 (0x00D0 - 0x00C0)
class UKuroChangeSkeletalMaterialsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_186F[0x10];                                    // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelChangeMaterials();
	void ChangeMaterialsWithDataAsset(const class UKuroChangeMaterialsTextures* DataAsset);
	void ChangeMaterialsWithTextures(class USkeletalMeshComponent* SkeletalMeshComponent, class FName ParameterName, const TArray<TSoftObjectPtr<class UTexture2D>>& Textures);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroChangeSkeletalMaterialsComponent">();
	}
	static class UKuroChangeSkeletalMaterialsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroChangeSkeletalMaterialsComponent>();
	}
};
static_assert(alignof(UKuroChangeSkeletalMaterialsComponent) == 0x000008, "Wrong alignment on UKuroChangeSkeletalMaterialsComponent");
static_assert(sizeof(UKuroChangeSkeletalMaterialsComponent) == 0x0000D0, "Wrong size on UKuroChangeSkeletalMaterialsComponent");

// Class KuroRenderingRuntimeBPPlugin.SunLensFlareConfig
// 0x0030 (0x0068 - 0x0038)
class USunLensFlareConfig final : public UPrimaryDataAsset
{
public:
	class UStaticMesh*                            StaticMeshGhost;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialGhost;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMeshHalo;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialHalo;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMeshGlare;                                   // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialGlare;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SunLensFlareConfig">();
	}
	static class USunLensFlareConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<USunLensFlareConfig>();
	}
};
static_assert(alignof(USunLensFlareConfig) == 0x000008, "Wrong alignment on USunLensFlareConfig");
static_assert(sizeof(USunLensFlareConfig) == 0x000068, "Wrong size on USunLensFlareConfig");
static_assert(offsetof(USunLensFlareConfig, StaticMeshGhost) == 0x000038, "Member 'USunLensFlareConfig::StaticMeshGhost' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, MaterialGhost) == 0x000040, "Member 'USunLensFlareConfig::MaterialGhost' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, StaticMeshHalo) == 0x000048, "Member 'USunLensFlareConfig::StaticMeshHalo' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, MaterialHalo) == 0x000050, "Member 'USunLensFlareConfig::MaterialHalo' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, StaticMeshGlare) == 0x000058, "Member 'USunLensFlareConfig::StaticMeshGlare' has a wrong offset!");
static_assert(offsetof(USunLensFlareConfig, MaterialGlare) == 0x000060, "Member 'USunLensFlareConfig::MaterialGlare' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.InteractiveLeavesConfigData
// 0x00C8 (0x0100 - 0x0038)
class UInteractiveLeavesConfigData final : public UPrimaryDataAsset
{
public:
	class UKuroPointCloudCache*                   PointCache;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            InstanceMesh;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     InstanceMaterial;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            WholeMesh;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     WholeMaterial;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRadius;                                      // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveRadius;                                      // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAgeRandom;                                  // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisappearTime;                                     // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReviveTime;                                        // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Drag;                                              // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerForceSize;                                   // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerForceExp;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitVelocitySizeMin;                               // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitVelocitySizeMax;                               // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitFloatVelocitySizeMin;                          // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitFloatVelocitySizeMax;                          // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConstForce;                                        // 0x0094(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroPointKdTree                       SpatialTree;                                       // 0x00A0(0x0058)(Edit, EditConst, NativeAccessSpecifierPublic)
	int32                                         PointNumCached;                                    // 0x00F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1871[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractiveLeavesConfigData">();
	}
	static class UInteractiveLeavesConfigData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractiveLeavesConfigData>();
	}
};
static_assert(alignof(UInteractiveLeavesConfigData) == 0x000008, "Wrong alignment on UInteractiveLeavesConfigData");
static_assert(sizeof(UInteractiveLeavesConfigData) == 0x000100, "Wrong size on UInteractiveLeavesConfigData");
static_assert(offsetof(UInteractiveLeavesConfigData, PointCache) == 0x000038, "Member 'UInteractiveLeavesConfigData::PointCache' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InstanceMesh) == 0x000040, "Member 'UInteractiveLeavesConfigData::InstanceMesh' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InstanceMaterial) == 0x000048, "Member 'UInteractiveLeavesConfigData::InstanceMaterial' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, WholeMesh) == 0x000050, "Member 'UInteractiveLeavesConfigData::WholeMesh' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, WholeMaterial) == 0x000058, "Member 'UInteractiveLeavesConfigData::WholeMaterial' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, PlayerRadius) == 0x000060, "Member 'UInteractiveLeavesConfigData::PlayerRadius' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, ReviveRadius) == 0x000064, "Member 'UInteractiveLeavesConfigData::ReviveRadius' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, LifeTime) == 0x000068, "Member 'UInteractiveLeavesConfigData::LifeTime' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitialAgeRandom) == 0x00006C, "Member 'UInteractiveLeavesConfigData::InitialAgeRandom' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, DisappearTime) == 0x000070, "Member 'UInteractiveLeavesConfigData::DisappearTime' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, ReviveTime) == 0x000074, "Member 'UInteractiveLeavesConfigData::ReviveTime' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, Drag) == 0x000078, "Member 'UInteractiveLeavesConfigData::Drag' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, PlayerForceSize) == 0x00007C, "Member 'UInteractiveLeavesConfigData::PlayerForceSize' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, PlayerForceExp) == 0x000080, "Member 'UInteractiveLeavesConfigData::PlayerForceExp' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitVelocitySizeMin) == 0x000084, "Member 'UInteractiveLeavesConfigData::InitVelocitySizeMin' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitVelocitySizeMax) == 0x000088, "Member 'UInteractiveLeavesConfigData::InitVelocitySizeMax' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitFloatVelocitySizeMin) == 0x00008C, "Member 'UInteractiveLeavesConfigData::InitFloatVelocitySizeMin' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, InitFloatVelocitySizeMax) == 0x000090, "Member 'UInteractiveLeavesConfigData::InitFloatVelocitySizeMax' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, ConstForce) == 0x000094, "Member 'UInteractiveLeavesConfigData::ConstForce' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, SpatialTree) == 0x0000A0, "Member 'UInteractiveLeavesConfigData::SpatialTree' has a wrong offset!");
static_assert(offsetof(UInteractiveLeavesConfigData, PointNumCached) == 0x0000F8, "Member 'UInteractiveLeavesConfigData::PointNumCached' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSuperFarFogConfig
// 0x0020 (0x0058 - 0x0038)
class UKuroSuperFarFogConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FKuroSuperFarFogLayer>          Layers;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobileDistanceScale;                               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1872[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSuperFarFogConfig">();
	}
	static class UKuroSuperFarFogConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSuperFarFogConfig>();
	}
};
static_assert(alignof(UKuroSuperFarFogConfig) == 0x000008, "Wrong alignment on UKuroSuperFarFogConfig");
static_assert(sizeof(UKuroSuperFarFogConfig) == 0x000058, "Wrong size on UKuroSuperFarFogConfig");
static_assert(offsetof(UKuroSuperFarFogConfig, Layers) == 0x000038, "Member 'UKuroSuperFarFogConfig::Layers' has a wrong offset!");
static_assert(offsetof(UKuroSuperFarFogConfig, MinDistance) == 0x000048, "Member 'UKuroSuperFarFogConfig::MinDistance' has a wrong offset!");
static_assert(offsetof(UKuroSuperFarFogConfig, MaxDistance) == 0x00004C, "Member 'UKuroSuperFarFogConfig::MaxDistance' has a wrong offset!");
static_assert(offsetof(UKuroSuperFarFogConfig, MobileDistanceScale) == 0x000050, "Member 'UKuroSuperFarFogConfig::MobileDistanceScale' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroAnimNotify
// 0x0008 (0x0048 - 0x0040)
class UKuroAnimNotify : public UAnimNotify
{
public:
	int32                                         ExportIndex;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1873[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool K2_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
	bool K2_PostChangeProperty(const class FName PropertyName);
	bool K2_ValidateAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimNotify">();
	}
	static class UKuroAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimNotify>();
	}
};
static_assert(alignof(UKuroAnimNotify) == 0x000008, "Wrong alignment on UKuroAnimNotify");
static_assert(sizeof(UKuroAnimNotify) == 0x000048, "Wrong size on UKuroAnimNotify");
static_assert(offsetof(UKuroAnimNotify, ExportIndex) == 0x000040, "Member 'UKuroAnimNotify::ExportIndex' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSuperFarFog
// 0x0020 (0x02C8 - 0x02A8)
class AKuroSuperFarFog final : public AActor
{
public:
	class UStaticMeshComponent*                   FogMeshComponent;                                  // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKuroSuperFarFogConfig*                 Config;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1876[0x10];                                    // 0x02B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSuperFarFog">();
	}
	static class AKuroSuperFarFog* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSuperFarFog>();
	}
};
static_assert(alignof(AKuroSuperFarFog) == 0x000008, "Wrong alignment on AKuroSuperFarFog");
static_assert(sizeof(AKuroSuperFarFog) == 0x0002C8, "Wrong size on AKuroSuperFarFog");
static_assert(offsetof(AKuroSuperFarFog, FogMeshComponent) == 0x0002A8, "Member 'AKuroSuperFarFog::FogMeshComponent' has a wrong offset!");
static_assert(offsetof(AKuroSuperFarFog, Config) == 0x0002B0, "Member 'AKuroSuperFarFog::Config' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState
// 0x0008 (0x0048 - 0x0040)
class UKuroAnimNotifyState : public UAnimNotifyState
{
public:
	int32                                         ExportIndex;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1877[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool K2_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration);
	bool K2_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
	bool K2_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime);
	bool K2_PostChangeProperty(const class FName PropertyName);
	bool K2_ValidateAssets();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroAnimNotifyState">();
	}
	static class UKuroAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroAnimNotifyState>();
	}
};
static_assert(alignof(UKuroAnimNotifyState) == 0x000008, "Wrong alignment on UKuroAnimNotifyState");
static_assert(sizeof(UKuroAnimNotifyState) == 0x000048, "Wrong size on UKuroAnimNotifyState");
static_assert(offsetof(UKuroAnimNotifyState, ExportIndex) == 0x000040, "Member 'UKuroAnimNotifyState::ExportIndex' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroTrailSystem
// 0x0050 (0x0088 - 0x0038)
class UKuroTrailSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_187C[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bTickEnabled : 1;                                  // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_187D[0x47];                                    // 0x0041(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKuroTrailSystem* GetKuroTrailSystem(class UWorld* InWorld);

	TArray<class UKuroTrailDrawerComponent*> GetTrailDrawerInRadius(const struct FVector& InWorldPosition, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTrailSystem">();
	}
	static class UKuroTrailSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTrailSystem>();
	}
};
static_assert(alignof(UKuroTrailSystem) == 0x000008, "Wrong alignment on UKuroTrailSystem");
static_assert(sizeof(UKuroTrailSystem) == 0x000088, "Wrong size on UKuroTrailSystem");

// Class KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent
// 0x00C0 (0x0630 - 0x0570)
class UKuroBezierMeshComponent final : public UProceduralMeshComponent
{
public:
	uint8                                         Pad_187E[0xC0];                                    // 0x0570(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLayer(float Alpha);
	void ClearData();
	void Dissipate(float SubLayersNum);
	int32 GetLayerNum();
	int32 GetMeshHeight();
	TArray<struct FVector> GetMeshPoints();
	TArray<int32> GetMeshTriangles();
	int32 GetMeshWidth();
	TArray<struct FVector> GetPointsArray();
	void SetKeyPoint(int32 Param_Index, float X, float Y, float Z);
	void Setup(int32 Width, float InUnitLength);
	void UpdateMesh(int32 Section);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBezierMeshComponent">();
	}
	static class UKuroBezierMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBezierMeshComponent>();
	}
};
static_assert(alignof(UKuroBezierMeshComponent) == 0x000010, "Wrong alignment on UKuroBezierMeshComponent");
static_assert(sizeof(UKuroBezierMeshComponent) == 0x000630, "Wrong size on UKuroBezierMeshComponent");

// Class KuroRenderingRuntimeBPPlugin.KuroUiSceneRootActor
// 0x0000 (0x02A8 - 0x02A8)
class AKuroUiSceneRootActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroUiSceneRootActor">();
	}
	static class AKuroUiSceneRootActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroUiSceneRootActor>();
	}
};
static_assert(alignof(AKuroUiSceneRootActor) == 0x000008, "Wrong alignment on AKuroUiSceneRootActor");
static_assert(sizeof(AKuroUiSceneRootActor) == 0x0002A8, "Wrong size on AKuroUiSceneRootActor");

// Class KuroRenderingRuntimeBPPlugin.KuroBillboardComponent
// 0x0010 (0x00D0 - 0x00C0)
class UKuroBillboardComponent final : public UActorComponent
{
public:
	bool                                          IsUpdateEveryFrame;                                // 0x00C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBillboardMode                                OrientAxis;                                        // 0x00C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFixSize;                                         // 0x00C2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_187F[0x1];                                     // 0x00C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleSize;                                         // 0x00C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x00C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSize;                                           // 0x00CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize();

	void Update() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroBillboardComponent">();
	}
	static class UKuroBillboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroBillboardComponent>();
	}
};
static_assert(alignof(UKuroBillboardComponent) == 0x000008, "Wrong alignment on UKuroBillboardComponent");
static_assert(sizeof(UKuroBillboardComponent) == 0x0000D0, "Wrong size on UKuroBillboardComponent");
static_assert(offsetof(UKuroBillboardComponent, IsUpdateEveryFrame) == 0x0000C0, "Member 'UKuroBillboardComponent::IsUpdateEveryFrame' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, OrientAxis) == 0x0000C1, "Member 'UKuroBillboardComponent::OrientAxis' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, IsFixSize) == 0x0000C2, "Member 'UKuroBillboardComponent::IsFixSize' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, ScaleSize) == 0x0000C4, "Member 'UKuroBillboardComponent::ScaleSize' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, MaxDistance) == 0x0000C8, "Member 'UKuroBillboardComponent::MaxDistance' has a wrong offset!");
static_assert(offsetof(UKuroBillboardComponent, MinSize) == 0x0000CC, "Member 'UKuroBillboardComponent::MinSize' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache
// 0x6970 (0x69A0 - 0x0030)
class UKuroCharacterMaterialControllerCache final : public UObject
{
public:
	struct FKuroCharMaterialControllerFloatGroup  Rotation;                                          // 0x0030(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  TextureScaleAndOffset;                             // 0x01E0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  TextureSpeed;                                      // 0x0840(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  TextureColorTint;                                  // 0x0EA0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  TextureStrength;                                   // 0x1500(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  TextureLowerLimit;                                 // 0x16B0(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  TextureUpperLimit;                                 // 0x1860(0x01B0)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FKuroCharMaterialControllerFloatGroup> FloatParameters;                                   // 0x1A10(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCharMaterialControllerColorGroup> ColorParameters;                                   // 0x1A20(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  RimRange;                                          // 0x1A30(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  RimColor;                                          // 0x1BE0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  OutlineWidth;                                      // 0x2240(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  OutlineColor;                                      // 0x23F0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  DissolveProgress;                                  // 0x2A50(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  DissolveColorIntensity;                            // 0x2C00(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  DissolveColor;                                     // 0x2DB0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  DissolveSmooth;                                    // 0x3410(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  BaseColorTint;                                     // 0x35C0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  MainTexColorTint;                                  // 0x3C20(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  EmissionColor;                                     // 0x4280(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  EmissionIntensity;                                 // 0x48E0(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  BaseRefine;                                        // 0x4A90(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  MotionColorStart;                                  // 0x50F0(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerColorGroup  MotionColorEnd;                                    // 0x5750(0x0660)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  MotionNoiseSpeed;                                  // 0x5DB0(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  StripMaskProportion;                               // 0x5F60(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  StripMaskVScale;                                   // 0x6110(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  StripMaskVSpeed;                                   // 0x62C0(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  DitherValue;                                       // 0x6470(0x01B0)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FKuroCharMaterialControllerFloatGroup> CustomFloatParameters;                             // 0x6620(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCharMaterialControllerColorGroup> CustomColorParameters;                             // 0x6630(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  HairDisplaceProgress;                              // 0x6640(0x01B0)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCharMaterialControllerFloatGroup  HairDisplaceContrast;                              // 0x67F0(0x01B0)(Edit, NativeAccessSpecifierPublic)

public:
	struct FLinearColor GetBaseColorTint(float Factor, int32 Type);
	struct FLinearColor GetBaseRefine(float Factor, int32 Type);
	struct FLinearColor GetCustomColorParametersValue(float Factor, int32 Type, int32 Param_Index);
	float GetCustomFloatParametersValue(float Factor, int32 Type, int32 Param_Index);
	struct FLinearColor GetDissolveColor(float Factor, int32 Type);
	float GetDissolveColorIntensity(float Factor, int32 Type);
	float GetDissolveProgress(float Factor, int32 Type);
	float GetDissolveSmooth(float Factor, int32 Type);
	float GetDitherValue(float Factor, int32 Type);
	struct FLinearColor GetEmissionColor(float Factor, int32 Type);
	float GetEmissionIntensity(float Factor, int32 Type);
	float GetHairDisplaceContrast(float Factor, int32 Type);
	float GetHairDisplaceProgress(float Factor, int32 Type);
	struct FLinearColor GetMainTexColorTint(float Factor, int32 Type);
	struct FLinearColor GetMotionColorEnd(float Factor, int32 Type);
	struct FLinearColor GetMotionColorStart(float Factor, int32 Type);
	float GetMotionNoiseSpeed(float Factor, int32 Type);
	struct FLinearColor GetOutlineColor(float Factor, int32 Type);
	float GetOutlineWidth(float Factor, int32 Type);
	struct FLinearColor GetRimColor(float Factor, int32 Type);
	float GetRimRange(float Factor, int32 Type);
	float GetRotation(float Factor, int32 Type);
	float GetStripMaskProportion(float Factor, int32 Type);
	float GetStripMaskVScale(float Factor, int32 Type);
	float GetStripMaskVSpeed(float Factor, int32 Type);
	struct FLinearColor GetTextureColorTint(float Factor, int32 Type);
	float GetTextureLowerLimit(float Factor, int32 Type);
	struct FLinearColor GetTextureScaleAndOffset(float Factor, int32 Type);
	struct FLinearColor GetTextureSpeed(float Factor, int32 Type);
	float GetTextureStrength(float Factor, int32 Type);
	float GetTextureUpperLimit(float Factor, int32 Type);
	void SetBaseColorTint(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetBaseRefine(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetCustomColorParametersValue(const TArray<struct FKuroCurveLinearColor>& Start, const TArray<struct FKuroCurveLinearColor>& Loop, const TArray<struct FKuroCurveLinearColor>& End);
	void SetCustomFloatParametersValue(const TArray<struct FKuroCurveFloat>& Start, const TArray<struct FKuroCurveFloat>& Loop, const TArray<struct FKuroCurveFloat>& End);
	void SetDissolveColor(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetDissolveColorIntensity(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetDissolveProgress(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetDissolveSmooth(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetDitherValue(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetEmissionColor(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetEmissionIntensity(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetHairDisplaceContrast(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetHairDisplaceProgress(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetMainTexColorTint(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetMotionColorEnd(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetMotionColorStart(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetMotionNoiseSpeed(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetOutlineColor(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetOutlineWidth(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetRimColor(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetRimRange(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetRotation(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetStripMaskProportion(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetStripMaskVScale(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetStripMaskVSpeed(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetTextureColorTint(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetTextureLowerLimit(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetTextureScaleAndOffset(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetTextureSpeed(const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	void SetTextureStrength(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	void SetTextureUpperLimit(const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroCharacterMaterialControllerCache">();
	}
	static class UKuroCharacterMaterialControllerCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroCharacterMaterialControllerCache>();
	}
};
static_assert(alignof(UKuroCharacterMaterialControllerCache) == 0x000008, "Wrong alignment on UKuroCharacterMaterialControllerCache");
static_assert(sizeof(UKuroCharacterMaterialControllerCache) == 0x0069A0, "Wrong size on UKuroCharacterMaterialControllerCache");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, Rotation) == 0x000030, "Member 'UKuroCharacterMaterialControllerCache::Rotation' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureScaleAndOffset) == 0x0001E0, "Member 'UKuroCharacterMaterialControllerCache::TextureScaleAndOffset' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureSpeed) == 0x000840, "Member 'UKuroCharacterMaterialControllerCache::TextureSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureColorTint) == 0x000EA0, "Member 'UKuroCharacterMaterialControllerCache::TextureColorTint' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureStrength) == 0x001500, "Member 'UKuroCharacterMaterialControllerCache::TextureStrength' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureLowerLimit) == 0x0016B0, "Member 'UKuroCharacterMaterialControllerCache::TextureLowerLimit' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, TextureUpperLimit) == 0x001860, "Member 'UKuroCharacterMaterialControllerCache::TextureUpperLimit' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, FloatParameters) == 0x001A10, "Member 'UKuroCharacterMaterialControllerCache::FloatParameters' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, ColorParameters) == 0x001A20, "Member 'UKuroCharacterMaterialControllerCache::ColorParameters' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, RimRange) == 0x001A30, "Member 'UKuroCharacterMaterialControllerCache::RimRange' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, RimColor) == 0x001BE0, "Member 'UKuroCharacterMaterialControllerCache::RimColor' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, OutlineWidth) == 0x002240, "Member 'UKuroCharacterMaterialControllerCache::OutlineWidth' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, OutlineColor) == 0x0023F0, "Member 'UKuroCharacterMaterialControllerCache::OutlineColor' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DissolveProgress) == 0x002A50, "Member 'UKuroCharacterMaterialControllerCache::DissolveProgress' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DissolveColorIntensity) == 0x002C00, "Member 'UKuroCharacterMaterialControllerCache::DissolveColorIntensity' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DissolveColor) == 0x002DB0, "Member 'UKuroCharacterMaterialControllerCache::DissolveColor' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DissolveSmooth) == 0x003410, "Member 'UKuroCharacterMaterialControllerCache::DissolveSmooth' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, BaseColorTint) == 0x0035C0, "Member 'UKuroCharacterMaterialControllerCache::BaseColorTint' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, MainTexColorTint) == 0x003C20, "Member 'UKuroCharacterMaterialControllerCache::MainTexColorTint' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, EmissionColor) == 0x004280, "Member 'UKuroCharacterMaterialControllerCache::EmissionColor' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, EmissionIntensity) == 0x0048E0, "Member 'UKuroCharacterMaterialControllerCache::EmissionIntensity' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, BaseRefine) == 0x004A90, "Member 'UKuroCharacterMaterialControllerCache::BaseRefine' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, MotionColorStart) == 0x0050F0, "Member 'UKuroCharacterMaterialControllerCache::MotionColorStart' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, MotionColorEnd) == 0x005750, "Member 'UKuroCharacterMaterialControllerCache::MotionColorEnd' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, MotionNoiseSpeed) == 0x005DB0, "Member 'UKuroCharacterMaterialControllerCache::MotionNoiseSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, StripMaskProportion) == 0x005F60, "Member 'UKuroCharacterMaterialControllerCache::StripMaskProportion' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, StripMaskVScale) == 0x006110, "Member 'UKuroCharacterMaterialControllerCache::StripMaskVScale' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, StripMaskVSpeed) == 0x0062C0, "Member 'UKuroCharacterMaterialControllerCache::StripMaskVSpeed' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, DitherValue) == 0x006470, "Member 'UKuroCharacterMaterialControllerCache::DitherValue' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, CustomFloatParameters) == 0x006620, "Member 'UKuroCharacterMaterialControllerCache::CustomFloatParameters' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, CustomColorParameters) == 0x006630, "Member 'UKuroCharacterMaterialControllerCache::CustomColorParameters' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, HairDisplaceProgress) == 0x006640, "Member 'UKuroCharacterMaterialControllerCache::HairDisplaceProgress' has a wrong offset!");
static_assert(offsetof(UKuroCharacterMaterialControllerCache, HairDisplaceContrast) == 0x0067F0, "Member 'UKuroCharacterMaterialControllerCache::HairDisplaceContrast' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroEditorTickActor
// 0x0010 (0x02B8 - 0x02A8)
class AKuroEditorTickActor : public AActor
{
public:
	bool                                          bEditorTickBySelected;                             // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetActorComponentTickEnabledByFocus;              // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1880[0x2];                                     // 0x02AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KuroEditorTickActorId;                             // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1881[0x8];                                     // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EditorFocusIn();
	void EditorFocusOut();
	void EditorInit();
	void EditorTick(float DeltaSeconds);

	void EditorSetActorComponentsTickEnabled(bool bValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEditorTickActor">();
	}
	static class AKuroEditorTickActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroEditorTickActor>();
	}
};
static_assert(alignof(AKuroEditorTickActor) == 0x000008, "Wrong alignment on AKuroEditorTickActor");
static_assert(sizeof(AKuroEditorTickActor) == 0x0002B8, "Wrong size on AKuroEditorTickActor");
static_assert(offsetof(AKuroEditorTickActor, bEditorTickBySelected) == 0x0002A8, "Member 'AKuroEditorTickActor::bEditorTickBySelected' has a wrong offset!");
static_assert(offsetof(AKuroEditorTickActor, bSetActorComponentTickEnabledByFocus) == 0x0002A9, "Member 'AKuroEditorTickActor::bSetActorComponentTickEnabledByFocus' has a wrong offset!");
static_assert(offsetof(AKuroEditorTickActor, KuroEditorTickActorId) == 0x0002AC, "Member 'AKuroEditorTickActor::KuroEditorTickActorId' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroEditorTickActorSubsystem
// 0x0028 (0x0060 - 0x0038)
class UKuroEditorTickActorSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_1882[0x28];                                    // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEditorTickActorSubsystem">();
	}
	static class UKuroEditorTickActorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEditorTickActorSubsystem>();
	}
};
static_assert(alignof(UKuroEditorTickActorSubsystem) == 0x000008, "Wrong alignment on UKuroEditorTickActorSubsystem");
static_assert(sizeof(UKuroEditorTickActorSubsystem) == 0x000060, "Wrong size on UKuroEditorTickActorSubsystem");

// Class KuroRenderingRuntimeBPPlugin.KuroEffectActor
// 0x0008 (0x02B0 - 0x02A8)
class AKuroEffectActor : public AActor
{
public:
	bool                                          bEditorTickBySelected;                             // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetActorComponentTickEnabledByFocus;              // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1883[0x6];                                     // 0x02AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoHiddenInGame(bool bValue);
	void EditorFocusIn();
	void EditorFocusOut();
	void EditorInit();
	void EditorTick(float DeltaSeconds);

	void EditorSetActorComponentsTickEnabled(bool bValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectActor">();
	}
	static class AKuroEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroEffectActor>();
	}
};
static_assert(alignof(AKuroEffectActor) == 0x000008, "Wrong alignment on AKuroEffectActor");
static_assert(sizeof(AKuroEffectActor) == 0x0002B0, "Wrong size on AKuroEffectActor");
static_assert(offsetof(AKuroEffectActor, bEditorTickBySelected) == 0x0002A8, "Member 'AKuroEffectActor::bEditorTickBySelected' has a wrong offset!");
static_assert(offsetof(AKuroEffectActor, bSetActorComponentTickEnabledByFocus) == 0x0002A9, "Member 'AKuroEffectActor::bSetActorComponentTickEnabledByFocus' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroEffectMakerAN
// 0x0038 (0x0080 - 0x0048)
class UKuroEffectMakerAN final : public UKuroAnimNotify
{
public:
	uint8                                         Pad_1884[0x4];                                     // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0064(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachLocationOnly;                                // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1885[0x2];                                     // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0074(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectMakerAN">();
	}
	static class UKuroEffectMakerAN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectMakerAN>();
	}
};
static_assert(alignof(UKuroEffectMakerAN) == 0x000008, "Wrong alignment on UKuroEffectMakerAN");
static_assert(sizeof(UKuroEffectMakerAN) == 0x000080, "Wrong size on UKuroEffectMakerAN");
static_assert(offsetof(UKuroEffectMakerAN, Location) == 0x00004C, "Member 'UKuroEffectMakerAN::Location' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, Rotation) == 0x000058, "Member 'UKuroEffectMakerAN::Rotation' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, Scale) == 0x000064, "Member 'UKuroEffectMakerAN::Scale' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, Attached) == 0x000070, "Member 'UKuroEffectMakerAN::Attached' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, AttachLocationOnly) == 0x000071, "Member 'UKuroEffectMakerAN::AttachLocationOnly' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerAN, SocketName) == 0x000074, "Member 'UKuroEffectMakerAN::SocketName' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroEffectMakerANS
// 0x0038 (0x0080 - 0x0048)
class UKuroEffectMakerANS final : public UKuroAnimNotifyState
{
public:
	uint8                                         Pad_1886[0x4];                                     // 0x0048(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0064(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachLocationOnly;                                // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1887[0x2];                                     // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0074(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroEffectMakerANS">();
	}
	static class UKuroEffectMakerANS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroEffectMakerANS>();
	}
};
static_assert(alignof(UKuroEffectMakerANS) == 0x000008, "Wrong alignment on UKuroEffectMakerANS");
static_assert(sizeof(UKuroEffectMakerANS) == 0x000080, "Wrong size on UKuroEffectMakerANS");
static_assert(offsetof(UKuroEffectMakerANS, Location) == 0x00004C, "Member 'UKuroEffectMakerANS::Location' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, Rotation) == 0x000058, "Member 'UKuroEffectMakerANS::Rotation' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, Scale) == 0x000064, "Member 'UKuroEffectMakerANS::Scale' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, Attached) == 0x000070, "Member 'UKuroEffectMakerANS::Attached' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, AttachLocationOnly) == 0x000071, "Member 'UKuroEffectMakerANS::AttachLocationOnly' has a wrong offset!");
static_assert(offsetof(UKuroEffectMakerANS, SocketName) == 0x000074, "Member 'UKuroEffectMakerANS::SocketName' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroFloatingStaticMesh
// 0x0078 (0x0320 - 0x02A8)
class AKuroFloatingStaticMesh final : public AActor
{
public:
	class AKuroFloatingStaticMesh*                BindingActor;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1888[0x20];                                    // 0x02B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Movement;                                          // 0x02D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotateCenter;                                      // 0x02E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x02EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickFactorScale;                                   // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1889[0x1C];                                    // 0x0304(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroFloatingStaticMesh">();
	}
	static class AKuroFloatingStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroFloatingStaticMesh>();
	}
};
static_assert(alignof(AKuroFloatingStaticMesh) == 0x000008, "Wrong alignment on AKuroFloatingStaticMesh");
static_assert(sizeof(AKuroFloatingStaticMesh) == 0x000320, "Wrong size on AKuroFloatingStaticMesh");
static_assert(offsetof(AKuroFloatingStaticMesh, BindingActor) == 0x0002A8, "Member 'AKuroFloatingStaticMesh::BindingActor' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, Movement) == 0x0002D0, "Member 'AKuroFloatingStaticMesh::Movement' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, Frequency) == 0x0002DC, "Member 'AKuroFloatingStaticMesh::Frequency' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, RotateCenter) == 0x0002E0, "Member 'AKuroFloatingStaticMesh::RotateCenter' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, Rotation) == 0x0002EC, "Member 'AKuroFloatingStaticMesh::Rotation' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, StaticMesh) == 0x0002F8, "Member 'AKuroFloatingStaticMesh::StaticMesh' has a wrong offset!");
static_assert(offsetof(AKuroFloatingStaticMesh, TickFactorScale) == 0x000300, "Member 'AKuroFloatingStaticMesh::TickFactorScale' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.ClusteredStuffDataAsset
// 0x0138 (0x0170 - 0x0038)
class UClusteredStuffDataAsset final : public UPrimaryDataAsset
{
public:
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      FloatParameters;                                   // 0x0040(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLinearColor>        ColorParameters;                                   // 0x0090(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             VectorParameters;                                  // 0x00E0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0130(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseWorldPosition : 1;                             // 0x013C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_188A[0x3];                                     // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WorldTransform;                                    // 0x0140(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClusteredStuffDataAsset">();
	}
	static class UClusteredStuffDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClusteredStuffDataAsset>();
	}
};
static_assert(alignof(UClusteredStuffDataAsset) == 0x000010, "Wrong alignment on UClusteredStuffDataAsset");
static_assert(sizeof(UClusteredStuffDataAsset) == 0x000170, "Wrong size on UClusteredStuffDataAsset");
static_assert(offsetof(UClusteredStuffDataAsset, NiagaraSystem) == 0x000038, "Member 'UClusteredStuffDataAsset::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, FloatParameters) == 0x000040, "Member 'UClusteredStuffDataAsset::FloatParameters' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, ColorParameters) == 0x000090, "Member 'UClusteredStuffDataAsset::ColorParameters' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, VectorParameters) == 0x0000E0, "Member 'UClusteredStuffDataAsset::VectorParameters' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, Scale) == 0x000130, "Member 'UClusteredStuffDataAsset::Scale' has a wrong offset!");
static_assert(offsetof(UClusteredStuffDataAsset, WorldTransform) == 0x000140, "Member 'UClusteredStuffDataAsset::WorldTransform' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWeatherDataAsset
// 0x0B58 (0x0B90 - 0x0038)
class UKuroWeatherDataAsset final : public UDataAsset
{
public:
	bool                                          UseOnlyOverrideProperty;                           // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFixedTime;                                      // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188B[0x2];                                     // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedTime;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseFixedSunAngle;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188C[0x3];                                     // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedSunHorizonAngle;                              // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixedSunVerticalAngle;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188D[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroGISetting                         GISetting;                                         // 0x0050(0x0B40)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWeatherDataAsset">();
	}
	static class UKuroWeatherDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWeatherDataAsset>();
	}
};
static_assert(alignof(UKuroWeatherDataAsset) == 0x000010, "Wrong alignment on UKuroWeatherDataAsset");
static_assert(sizeof(UKuroWeatherDataAsset) == 0x000B90, "Wrong size on UKuroWeatherDataAsset");
static_assert(offsetof(UKuroWeatherDataAsset, UseOnlyOverrideProperty) == 0x000038, "Member 'UKuroWeatherDataAsset::UseOnlyOverrideProperty' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, UseFixedTime) == 0x000039, "Member 'UKuroWeatherDataAsset::UseFixedTime' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, FixedTime) == 0x00003C, "Member 'UKuroWeatherDataAsset::FixedTime' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, UseFixedSunAngle) == 0x000040, "Member 'UKuroWeatherDataAsset::UseFixedSunAngle' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, FixedSunHorizonAngle) == 0x000044, "Member 'UKuroWeatherDataAsset::FixedSunHorizonAngle' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, FixedSunVerticalAngle) == 0x000048, "Member 'UKuroWeatherDataAsset::FixedSunVerticalAngle' has a wrong offset!");
static_assert(offsetof(UKuroWeatherDataAsset, GISetting) == 0x000050, "Member 'UKuroWeatherDataAsset::GISetting' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroTODData
// 0x0020 (0x0058 - 0x0038)
class UKuroTODData final : public UDataAsset
{
public:
	TArray<struct FKuroTODEntryData>              EntryDatas;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UKuroWeatherDataAsset*>          TODConfigs;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTODData">();
	}
	static class UKuroTODData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTODData>();
	}
};
static_assert(alignof(UKuroTODData) == 0x000008, "Wrong alignment on UKuroTODData");
static_assert(sizeof(UKuroTODData) == 0x000058, "Wrong size on UKuroTODData");
static_assert(offsetof(UKuroTODData, EntryDatas) == 0x000038, "Member 'UKuroTODData::EntryDatas' has a wrong offset!");
static_assert(offsetof(UKuroTODData, TODConfigs) == 0x000048, "Member 'UKuroTODData::TODConfigs' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLandscapeParametersData
// 0x0010 (0x0048 - 0x0038)
class UKuroLandscapeParametersData final : public UDataAsset
{
public:
	TArray<float>                                 Parameters;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool SetLandscapeMaterialLayerParameters(class UWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLandscapeParametersData">();
	}
	static class UKuroLandscapeParametersData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLandscapeParametersData>();
	}
};
static_assert(alignof(UKuroLandscapeParametersData) == 0x000008, "Wrong alignment on UKuroLandscapeParametersData");
static_assert(sizeof(UKuroLandscapeParametersData) == 0x000048, "Wrong size on UKuroLandscapeParametersData");
static_assert(offsetof(UKuroLandscapeParametersData, Parameters) == 0x000038, "Member 'UKuroLandscapeParametersData::Parameters' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPPLensflareData
// 0x0030 (0x0068 - 0x0038)
class UKuroPPLensflareData final : public UPrimaryDataAsset
{
public:
	class FName                                   ConfigName;                                        // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188F[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroLensflareSettings                 Settings;                                          // 0x0048(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPPLensflareData">();
	}
	static class UKuroPPLensflareData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPPLensflareData>();
	}
};
static_assert(alignof(UKuroPPLensflareData) == 0x000008, "Wrong alignment on UKuroPPLensflareData");
static_assert(sizeof(UKuroPPLensflareData) == 0x000068, "Wrong size on UKuroPPLensflareData");
static_assert(offsetof(UKuroPPLensflareData, ConfigName) == 0x000038, "Member 'UKuroPPLensflareData::ConfigName' has a wrong offset!");
static_assert(offsetof(UKuroPPLensflareData, Settings) == 0x000048, "Member 'UKuroPPLensflareData::Settings' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGISettings
// 0x0070 (0x00B8 - 0x0048)
class UKuroGISettings final : public UDeveloperSettings
{
public:
	TArray<class FName>                           ThunderProfileNames;                               // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           RainProfileNames;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                LensflareDatas;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UKuroLandscapeParametersData> LandscapeParametersData;                           // 0x0078(0x0030)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UKuroPPLensflareData*>           LensflareDatasLoaded;                              // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGISettings">();
	}
	static class UKuroGISettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGISettings>();
	}
};
static_assert(alignof(UKuroGISettings) == 0x000008, "Wrong alignment on UKuroGISettings");
static_assert(sizeof(UKuroGISettings) == 0x0000B8, "Wrong size on UKuroGISettings");
static_assert(offsetof(UKuroGISettings, ThunderProfileNames) == 0x000048, "Member 'UKuroGISettings::ThunderProfileNames' has a wrong offset!");
static_assert(offsetof(UKuroGISettings, RainProfileNames) == 0x000058, "Member 'UKuroGISettings::RainProfileNames' has a wrong offset!");
static_assert(offsetof(UKuroGISettings, LensflareDatas) == 0x000068, "Member 'UKuroGISettings::LensflareDatas' has a wrong offset!");
static_assert(offsetof(UKuroGISettings, LandscapeParametersData) == 0x000078, "Member 'UKuroGISettings::LandscapeParametersData' has a wrong offset!");
static_assert(offsetof(UKuroGISettings, LensflareDatasLoaded) == 0x0000A8, "Member 'UKuroGISettings::LensflareDatasLoaded' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGISystem
// 0x0468 (0x04A0 - 0x0038)
class alignas(0x10) UKuroGISystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_1890[0x218];                                   // 0x0038(0x0218)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UObject*>             WeatherData;                                       // 0x0250(0x0050)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_1891[0x138];                                   // 0x02A0(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroWorldPartitionPreviewManager*      WorldPartitionPreviewManager;                      // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroPostprocessMaterialManager        PostprocessMaterialManager;                        // 0x03E0(0x0030)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FKuroSceneEffectActorManager           SceneEffectActorManager;                           // 0x0410(0x0028)(NativeAccessSpecifierPublic)
	uint8                                         Pad_1892[0x50];                                    // 0x0438(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroRainManager*                       RainManager;                                       // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1893[0x10];                                    // 0x0490(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKuroGISystem* GetKuroGISystem(class UWorld* InWorld);

	bool End3DUISceneRendering();
	class AKuroGlobalGI* GetKuroGlobalGIActor();
	bool IsLastTickGIActor(class AKuroGlobalGI* Actor);
	bool IsUISceneRendering();
	bool Start3DUISceneRendering(const class FString& InLevelName);

	EKuroUI3DState GetUISceneRenderingState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGISystem">();
	}
	static class UKuroGISystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGISystem>();
	}
};
static_assert(alignof(UKuroGISystem) == 0x000010, "Wrong alignment on UKuroGISystem");
static_assert(sizeof(UKuroGISystem) == 0x0004A0, "Wrong size on UKuroGISystem");
static_assert(offsetof(UKuroGISystem, WeatherData) == 0x000250, "Member 'UKuroGISystem::WeatherData' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, WorldPartitionPreviewManager) == 0x0003D8, "Member 'UKuroGISystem::WorldPartitionPreviewManager' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, PostprocessMaterialManager) == 0x0003E0, "Member 'UKuroGISystem::PostprocessMaterialManager' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, SceneEffectActorManager) == 0x000410, "Member 'UKuroGISystem::SceneEffectActorManager' has a wrong offset!");
static_assert(offsetof(UKuroGISystem, RainManager) == 0x000488, "Member 'UKuroGISystem::RainManager' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGlobalColorSplitTextures
// 0x0010 (0x0048 - 0x0038)
class UKuroGlobalColorSplitTextures final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      Textures;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGlobalColorSplitTextures">();
	}
	static class UKuroGlobalColorSplitTextures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGlobalColorSplitTextures>();
	}
};
static_assert(alignof(UKuroGlobalColorSplitTextures) == 0x000008, "Wrong alignment on UKuroGlobalColorSplitTextures");
static_assert(sizeof(UKuroGlobalColorSplitTextures) == 0x000048, "Wrong size on UKuroGlobalColorSplitTextures");
static_assert(offsetof(UKuroGlobalColorSplitTextures, Textures) == 0x000038, "Member 'UKuroGlobalColorSplitTextures::Textures' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGlobalColorMapComponent
// 0x0050 (0x0110 - 0x00C0)
class alignas(0x10) UKuroGlobalColorMapComponent final : public UActorComponent
{
public:
	class UKuroGlobalColorSplitTextures*          GlobalColorSplitTextures;                          // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SideCellNum;                                       // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizePerCell;                                       // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartWorldPosition;                                // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1896[0x38];                                    // 0x00D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateColorMap(const class UObject* WorldContextObject, const struct FVector& ViewLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGlobalColorMapComponent">();
	}
	static class UKuroGlobalColorMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGlobalColorMapComponent>();
	}
};
static_assert(alignof(UKuroGlobalColorMapComponent) == 0x000010, "Wrong alignment on UKuroGlobalColorMapComponent");
static_assert(sizeof(UKuroGlobalColorMapComponent) == 0x000110, "Wrong size on UKuroGlobalColorMapComponent");
static_assert(offsetof(UKuroGlobalColorMapComponent, GlobalColorSplitTextures) == 0x0000C0, "Member 'UKuroGlobalColorMapComponent::GlobalColorSplitTextures' has a wrong offset!");
static_assert(offsetof(UKuroGlobalColorMapComponent, SideCellNum) == 0x0000C8, "Member 'UKuroGlobalColorMapComponent::SideCellNum' has a wrong offset!");
static_assert(offsetof(UKuroGlobalColorMapComponent, SizePerCell) == 0x0000CC, "Member 'UKuroGlobalColorMapComponent::SizePerCell' has a wrong offset!");
static_assert(offsetof(UKuroGlobalColorMapComponent, StartWorldPosition) == 0x0000D0, "Member 'UKuroGlobalColorMapComponent::StartWorldPosition' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGlobalGI
// 0x1FE8 (0x2290 - 0x02A8)
class AKuroGlobalGI final : public AActor
{
public:
	bool                                          TickInEditor;                                      // 0x02A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPersistentLevelGI;                               // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPostProcessVolumeChanged;                         // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1898[0x1];                                     // 0x02AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickDeltaTime;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x02B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunHorizonAngle;                                   // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunVerticalAngle;                                  // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1899[0xC];                                     // 0x02C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroGISetting                         LerpGISetting;                                     // 0x02D0(0x0B40)(Edit, BlueprintVisible, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FKuroGISetting                         TempGISetting;                                     // 0x0E10(0x0B40)(Edit, BlueprintVisible, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FPostProcessSettings                   LerpPostProcessSetting;                            // 0x1950(0x0600)(Edit, BlueprintVisible, Transient, EditConst, NativeAccessSpecifierPublic)
	float                                         CurTimeAfterLerp;                                  // 0x1F50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSunHorizonAngle;                               // 0x1F54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LerpSunVerticalAngle;                              // 0x1F58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalWindSpeed;                                   // 0x1F5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalWindPower;                                   // 0x1F60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GlobalWindForwardDrection;                         // 0x1F64(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindTextureOffset;                                 // 0x1F70(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDayTime;                                        // 0x1F7C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDayNightEmssiveFactor;                            // 0x1F7D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189A[0x2];                                     // 0x1F7E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DayNightEmssiveSmoothFactor;                       // 0x1F80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TODNightLightLoadingTime;                          // 0x1F84(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TODDayLightLoadingTime;                            // 0x1F88(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainDensityStepSpeed;                              // 0x1F8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalRainDensityValue;                             // 0x1F90(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalSnowDensityValue;                             // 0x1F94(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainGravityStepSpeed;                              // 0x1F98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalRainGravityValue;                             // 0x1F9C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainWindPowerStepSpeed;                            // 0x1FA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharLightHorizontal;                               // 0x1FA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AtmosphereSunRotation;                             // 0x1FA8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AtmosphereSunForward;                              // 0x1FB4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AtmosphereMoonRotation;                            // 0x1FC0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AtmosphereMoonForward;                             // 0x1FCC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdatePostProcessDataThreshold;                    // 0x1FD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189B[0x4];                                     // 0x1FDC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           KuroSkyLightCubemap1;                              // 0x1FE0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureCube*                           KuroSkyLightCubemap2;                              // 0x1FE8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureCube*                           KuroSkyLightCubemap3;                              // 0x1FF0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KuroCubemapBlend12;                                // 0x1FF8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KuroCubemapBlend23;                                // 0x1FFC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KuroGlobalGIIndex;                                 // 0x2000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GIID;                                              // 0x2004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKuroInit;                                        // 0x2008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189C[0x7];                                     // 0x2009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           GIMPC;                                             // 0x2010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189D[0x20];                                    // 0x2018(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        FogTime;                                           // 0x2038(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class UClusteredStuffDataAsset*, class AKuroRuntimeTransientActor*> ClusteredStuffTransientActors;                     // 0x20C8(0x0050)(Transient, NativeAccessSpecifierPublic)
	TSet<class UClusteredStuffDataAsset*>         ClusteredStuffActive;                              // 0x2118(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<class UClusteredStuffDataAsset*>       AdditionalClusteredStuff;                          // 0x2168(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_189E[0x8];                                     // 0x2178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USunLensFlareConfig*                    DefaultSunLensflareConfig;                         // 0x2180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               StarsMat;                                          // 0x2188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MilkyWayMat;                                       // 0x2190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SkyBoxMat;                                         // 0x2198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerInCave;                                     // 0x21A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189F[0x3];                                     // 0x21A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FinalRoughnessDensity;                             // 0x21A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A0[0x10];                                    // 0x21A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroTODData*                           TODDataAsset;                                      // 0x21B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UKuroGISystem>           CachedGISystem;                                    // 0x21C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18A1[0x18];                                    // 0x21C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               LightFunctionMap_Texture;                          // 0x21E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18A2[0xA8];                                    // 0x21E8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplayShadowTintRampOffset(class USkyLightComponent* SkyLight);
	void Apply3DUISceneSkyLight(class USkyLightComponent* SkyLight);
	void ApplyAndUpdateDayNightDataLayer(float TimeOfDay, float TODLightLoadingWait);
	void ApplyClusteredStuff();
	void ApplyGIMPC();
	void ApplyGlobalGIRenderQuality(class UMaterialInstanceDynamic* DynamicMaterial);
	void ApplyKuroSkyLight(class USkyLightComponent* SkyLight, float TimeOfDay, float DefaultShadowSupplement, float DefaultReflectionAddIntensity);
	void ApplyLensflare(float DeltaTime, const struct FVector& SunForward, class UMaterialParameterCollection* Collection);
	void ApplyLightFunctionSetting(class UMaterialInstanceDynamic* DynamicMaterial, class UTexture* DefaultLightFucntionTexture);
	void ApplyMilkyWayParameters(class UMaterialInstance* MilkyWayMaterial, class UStaticMeshComponent* MilkyWayMeshComponent);
	void ApplySceneRain();
	void ApplySkyBoxSetting(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class UMaterialInstance* SkyBoxMaterial, class UStaticMeshComponent* SkyBoxMeshComponent);
	void ApplyStarsParameters(class UMaterialInstance* StarMaterial, class UStaticMeshComponent* StarMeshComponent);
	void CalLightDirectionWithLimit(float Time, float LightAngleLimit, struct FRotator* LightRotation);
	class UKuroGISystem* GetCachedGISystem();
	float GetGITime();
	void OnKuroEndUI();
	void OnKuroEndUiScene();
	void OnKuroInit();
	void OnKuroRuntimeDestroy();
	void OnKuroSetRuntimeTime(float CurrentTime);
	void OnKuroStartUI(const class FString& InName, class ULevel* InUILevel);
	void OnKuroStartUiScene(const class FString& InName, class ULevel* InUILevel);
	void OnKuroTick(float DeltaTime);
	void OnKuroTickEditor(float DeltaTime);
	void SetGITime(float Time);
	void SetSunLensflareEnabled(bool bEnable);
	void SetupSceneRain(class UKuroSceneRainEmitterConfig* FrontRainConfig, class UKuroSceneRainEmitterConfig* BackRainConfig);
	void UpdateAndApplyWeather(class AKuroRainActor* RainActor, class AKuroRainActor* SnowActor, class UTexture2D* HeightTexture);
	void UpdateAndApplyWind(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection);
	void UpdateCharLightHorizontal(const class UObject* WorldContextObject, const struct FRotator& SceneLightRot, class UMaterialParameterCollection* Collection, bool bDebugCharLightHorizontal, float DebugCharLightHorizontal, float DebugCharLightVertical);
	void UpdateLightDirection(const class UObject* WorldContextObject, class UDirectionalLightComponent* AtmoSunLight, class UDirectionalLightComponent* AtmoMoonLight);
	void UpdatePostProcessSettingData(const class UObject* WorldContextObject, float CurTime, bool bSkipLerpData);
	void UpdateTODData(const class UObject* WorldContextObject, const struct FVector& WorldPosition, float TimeSecnod);

	void ApplyCloudCardSetting(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection) const;
	void ApplyFog(const class UObject* WorldContextObject, class UExponentialHeightFogComponent* HeightFog, class UMaterialParameterCollection* Collection, float WorldZOffset, class UStaticMeshComponent* CloudOcean) const;
	void ApplyGlobalShaderParameters(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection) const;
	void ApplyLightParameters(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class UDirectionalLightComponent* SceneLight) const;
	void ApplyLightShaft(class UDirectionalLightComponent* SceneLight) const;
	void ApplySkyEffectsParameters(const class UObject* WorldContextObject, class UMaterialParameterCollection* Collection) const;
	float CalcTODTimeFactor(float StartTime, float EndTime, float CurrTime) const;
	bool K2_IsInPersistentLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGlobalGI">();
	}
	static class AKuroGlobalGI* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroGlobalGI>();
	}
};
static_assert(alignof(AKuroGlobalGI) == 0x000010, "Wrong alignment on AKuroGlobalGI");
static_assert(sizeof(AKuroGlobalGI) == 0x002290, "Wrong size on AKuroGlobalGI");
static_assert(offsetof(AKuroGlobalGI, TickInEditor) == 0x0002A8, "Member 'AKuroGlobalGI::TickInEditor' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, IsPersistentLevelGI) == 0x0002A9, "Member 'AKuroGlobalGI::IsPersistentLevelGI' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bPostProcessVolumeChanged) == 0x0002AA, "Member 'AKuroGlobalGI::bPostProcessVolumeChanged' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TickDeltaTime) == 0x0002AC, "Member 'AKuroGlobalGI::TickDeltaTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, ViewLocation) == 0x0002B0, "Member 'AKuroGlobalGI::ViewLocation' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, SunHorizonAngle) == 0x0002BC, "Member 'AKuroGlobalGI::SunHorizonAngle' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, SunVerticalAngle) == 0x0002C0, "Member 'AKuroGlobalGI::SunVerticalAngle' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LerpGISetting) == 0x0002D0, "Member 'AKuroGlobalGI::LerpGISetting' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TempGISetting) == 0x000E10, "Member 'AKuroGlobalGI::TempGISetting' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LerpPostProcessSetting) == 0x001950, "Member 'AKuroGlobalGI::LerpPostProcessSetting' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CurTimeAfterLerp) == 0x001F50, "Member 'AKuroGlobalGI::CurTimeAfterLerp' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LerpSunHorizonAngle) == 0x001F54, "Member 'AKuroGlobalGI::LerpSunHorizonAngle' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LerpSunVerticalAngle) == 0x001F58, "Member 'AKuroGlobalGI::LerpSunVerticalAngle' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GlobalWindSpeed) == 0x001F5C, "Member 'AKuroGlobalGI::GlobalWindSpeed' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GlobalWindPower) == 0x001F60, "Member 'AKuroGlobalGI::GlobalWindPower' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GlobalWindForwardDrection) == 0x001F64, "Member 'AKuroGlobalGI::GlobalWindForwardDrection' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, WindTextureOffset) == 0x001F70, "Member 'AKuroGlobalGI::WindTextureOffset' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bIsDayTime) == 0x001F7C, "Member 'AKuroGlobalGI::bIsDayTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bDayNightEmssiveFactor) == 0x001F7D, "Member 'AKuroGlobalGI::bDayNightEmssiveFactor' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, DayNightEmssiveSmoothFactor) == 0x001F80, "Member 'AKuroGlobalGI::DayNightEmssiveSmoothFactor' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TODNightLightLoadingTime) == 0x001F84, "Member 'AKuroGlobalGI::TODNightLightLoadingTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TODDayLightLoadingTime) == 0x001F88, "Member 'AKuroGlobalGI::TODDayLightLoadingTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, RainDensityStepSpeed) == 0x001F8C, "Member 'AKuroGlobalGI::RainDensityStepSpeed' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FinalRainDensityValue) == 0x001F90, "Member 'AKuroGlobalGI::FinalRainDensityValue' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FinalSnowDensityValue) == 0x001F94, "Member 'AKuroGlobalGI::FinalSnowDensityValue' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, RainGravityStepSpeed) == 0x001F98, "Member 'AKuroGlobalGI::RainGravityStepSpeed' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FinalRainGravityValue) == 0x001F9C, "Member 'AKuroGlobalGI::FinalRainGravityValue' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, RainWindPowerStepSpeed) == 0x001FA0, "Member 'AKuroGlobalGI::RainWindPowerStepSpeed' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CharLightHorizontal) == 0x001FA4, "Member 'AKuroGlobalGI::CharLightHorizontal' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AtmosphereSunRotation) == 0x001FA8, "Member 'AKuroGlobalGI::AtmosphereSunRotation' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AtmosphereSunForward) == 0x001FB4, "Member 'AKuroGlobalGI::AtmosphereSunForward' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AtmosphereMoonRotation) == 0x001FC0, "Member 'AKuroGlobalGI::AtmosphereMoonRotation' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AtmosphereMoonForward) == 0x001FCC, "Member 'AKuroGlobalGI::AtmosphereMoonForward' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, UpdatePostProcessDataThreshold) == 0x001FD8, "Member 'AKuroGlobalGI::UpdatePostProcessDataThreshold' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroSkyLightCubemap1) == 0x001FE0, "Member 'AKuroGlobalGI::KuroSkyLightCubemap1' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroSkyLightCubemap2) == 0x001FE8, "Member 'AKuroGlobalGI::KuroSkyLightCubemap2' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroSkyLightCubemap3) == 0x001FF0, "Member 'AKuroGlobalGI::KuroSkyLightCubemap3' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroCubemapBlend12) == 0x001FF8, "Member 'AKuroGlobalGI::KuroCubemapBlend12' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroCubemapBlend23) == 0x001FFC, "Member 'AKuroGlobalGI::KuroCubemapBlend23' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, KuroGlobalGIIndex) == 0x002000, "Member 'AKuroGlobalGI::KuroGlobalGIIndex' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GIID) == 0x002004, "Member 'AKuroGlobalGI::GIID' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, IsKuroInit) == 0x002008, "Member 'AKuroGlobalGI::IsKuroInit' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, GIMPC) == 0x002010, "Member 'AKuroGlobalGI::GIMPC' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FogTime) == 0x002038, "Member 'AKuroGlobalGI::FogTime' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, ClusteredStuffTransientActors) == 0x0020C8, "Member 'AKuroGlobalGI::ClusteredStuffTransientActors' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, ClusteredStuffActive) == 0x002118, "Member 'AKuroGlobalGI::ClusteredStuffActive' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, AdditionalClusteredStuff) == 0x002168, "Member 'AKuroGlobalGI::AdditionalClusteredStuff' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, DefaultSunLensflareConfig) == 0x002180, "Member 'AKuroGlobalGI::DefaultSunLensflareConfig' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, StarsMat) == 0x002188, "Member 'AKuroGlobalGI::StarsMat' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, MilkyWayMat) == 0x002190, "Member 'AKuroGlobalGI::MilkyWayMat' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, SkyBoxMat) == 0x002198, "Member 'AKuroGlobalGI::SkyBoxMat' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, bPlayerInCave) == 0x0021A0, "Member 'AKuroGlobalGI::bPlayerInCave' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, FinalRoughnessDensity) == 0x0021A4, "Member 'AKuroGlobalGI::FinalRoughnessDensity' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, TODDataAsset) == 0x0021B8, "Member 'AKuroGlobalGI::TODDataAsset' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, CachedGISystem) == 0x0021C0, "Member 'AKuroGlobalGI::CachedGISystem' has a wrong offset!");
static_assert(offsetof(AKuroGlobalGI, LightFunctionMap_Texture) == 0x0021E0, "Member 'AKuroGlobalGI::LightFunctionMap_Texture' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroHeightMapSettings
// 0x0010 (0x0048 - 0x0038)
class UKuroHeightMapSettings final : public UPrimaryDataAsset
{
public:
	class UKuroSplitTextureStreamerSettings*      StreamerSettings;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotHeight;                                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A9[0x4];                                     // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHeightMapSettings">();
	}
	static class UKuroHeightMapSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHeightMapSettings>();
	}
};
static_assert(alignof(UKuroHeightMapSettings) == 0x000008, "Wrong alignment on UKuroHeightMapSettings");
static_assert(sizeof(UKuroHeightMapSettings) == 0x000048, "Wrong size on UKuroHeightMapSettings");
static_assert(offsetof(UKuroHeightMapSettings, StreamerSettings) == 0x000038, "Member 'UKuroHeightMapSettings::StreamerSettings' has a wrong offset!");
static_assert(offsetof(UKuroHeightMapSettings, ShotHeight) == 0x000040, "Member 'UKuroHeightMapSettings::ShotHeight' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGlobalHeightMapComponent
// 0x0080 (0x0140 - 0x00C0)
class alignas(0x10) UKuroGlobalHeightMapComponent final : public UActorComponent
{
public:
	class UKuroHeightMapSettings*                 HeightMapSettings;                                 // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadNumPerSidePc;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadNumPerSideMobile;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        LoadedTextures;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_18AA[0x60];                                    // 0x00E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGlobalHeightMapComponent">();
	}
	static class UKuroGlobalHeightMapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGlobalHeightMapComponent>();
	}
};
static_assert(alignof(UKuroGlobalHeightMapComponent) == 0x000010, "Wrong alignment on UKuroGlobalHeightMapComponent");
static_assert(sizeof(UKuroGlobalHeightMapComponent) == 0x000140, "Wrong size on UKuroGlobalHeightMapComponent");
static_assert(offsetof(UKuroGlobalHeightMapComponent, HeightMapSettings) == 0x0000C0, "Member 'UKuroGlobalHeightMapComponent::HeightMapSettings' has a wrong offset!");
static_assert(offsetof(UKuroGlobalHeightMapComponent, LoadNumPerSidePc) == 0x0000C8, "Member 'UKuroGlobalHeightMapComponent::LoadNumPerSidePc' has a wrong offset!");
static_assert(offsetof(UKuroGlobalHeightMapComponent, LoadNumPerSideMobile) == 0x0000CC, "Member 'UKuroGlobalHeightMapComponent::LoadNumPerSideMobile' has a wrong offset!");
static_assert(offsetof(UKuroGlobalHeightMapComponent, LoadedTextures) == 0x0000D0, "Member 'UKuroGlobalHeightMapComponent::LoadedTextures' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGPUParticleActor
// 0x0010 (0x02B8 - 0x02A8)
class AKuroGPUParticleActor final : public AActor
{
public:
	int32                                         KuroIndex;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18AB[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroGPUParticleComponent*              GPUParticleComponent;                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGPUParticleActor">();
	}
	static class AKuroGPUParticleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroGPUParticleActor>();
	}
};
static_assert(alignof(AKuroGPUParticleActor) == 0x000008, "Wrong alignment on AKuroGPUParticleActor");
static_assert(sizeof(AKuroGPUParticleActor) == 0x0002B8, "Wrong size on AKuroGPUParticleActor");
static_assert(offsetof(AKuroGPUParticleActor, KuroIndex) == 0x0002A8, "Member 'AKuroGPUParticleActor::KuroIndex' has a wrong offset!");
static_assert(offsetof(AKuroGPUParticleActor, GPUParticleComponent) == 0x0002B0, "Member 'AKuroGPUParticleActor::GPUParticleComponent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGPUParticleComponent
// 0x00E0 (0x0670 - 0x0590)
class UKuroGPUParticleComponent final : public UStaticMeshComponent
{
public:
	class UKuroGPUParticleDA*                     GPUParticleDataAsset;                              // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClickReplay;                                       // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopAtFinalFrame;                                  // 0x0591(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoUpdate;                                        // 0x0592(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18AC[0x1];                                     // 0x0593(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SimulateFramerate;                                 // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Loop;                                              // 0x0598(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reverse;                                           // 0x0599(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18AD[0x2];                                     // 0x059A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoopIntervalTime;                                  // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkipFrameCount;                                    // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWaitTime;                                     // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomTimeScaleCurve;                           // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18AE[0x7];                                     // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        CustomTimeScaleCurve;                              // 0x05B0(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_18AF[0x30];                                    // 0x0640(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoTick(float DeltaTime);
	void ResetParticle();
	void SetGPUData(class UKuroGPUParticleDA* TargetData);
	void SetupParticle(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGPUParticleComponent">();
	}
	static class UKuroGPUParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGPUParticleComponent>();
	}
};
static_assert(alignof(UKuroGPUParticleComponent) == 0x000010, "Wrong alignment on UKuroGPUParticleComponent");
static_assert(sizeof(UKuroGPUParticleComponent) == 0x000670, "Wrong size on UKuroGPUParticleComponent");
static_assert(offsetof(UKuroGPUParticleComponent, GPUParticleDataAsset) == 0x000588, "Member 'UKuroGPUParticleComponent::GPUParticleDataAsset' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, ClickReplay) == 0x000590, "Member 'UKuroGPUParticleComponent::ClickReplay' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, StopAtFinalFrame) == 0x000591, "Member 'UKuroGPUParticleComponent::StopAtFinalFrame' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, AutoUpdate) == 0x000592, "Member 'UKuroGPUParticleComponent::AutoUpdate' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, SimulateFramerate) == 0x000594, "Member 'UKuroGPUParticleComponent::SimulateFramerate' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, Loop) == 0x000598, "Member 'UKuroGPUParticleComponent::Loop' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, Reverse) == 0x000599, "Member 'UKuroGPUParticleComponent::Reverse' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, LoopIntervalTime) == 0x00059C, "Member 'UKuroGPUParticleComponent::LoopIntervalTime' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, SkipFrameCount) == 0x0005A0, "Member 'UKuroGPUParticleComponent::SkipFrameCount' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, StartWaitTime) == 0x0005A4, "Member 'UKuroGPUParticleComponent::StartWaitTime' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, UseCustomTimeScaleCurve) == 0x0005A8, "Member 'UKuroGPUParticleComponent::UseCustomTimeScaleCurve' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleComponent, CustomTimeScaleCurve) == 0x0005B0, "Member 'UKuroGPUParticleComponent::CustomTimeScaleCurve' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGPUParticleDA
// 0x0040 (0x0078 - 0x0038)
class UKuroGPUParticleDA final : public UDataAsset
{
public:
	class FString                                 JsonDataPath;                                      // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      GPUParticleMaterial;                               // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartFrame;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndFrame;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorIntensity;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityScale;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B0[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroGPUParticleMeshInfo>       AllParticleInfos;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGPUParticleDA">();
	}
	static class UKuroGPUParticleDA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGPUParticleDA>();
	}
};
static_assert(alignof(UKuroGPUParticleDA) == 0x000008, "Wrong alignment on UKuroGPUParticleDA");
static_assert(sizeof(UKuroGPUParticleDA) == 0x000078, "Wrong size on UKuroGPUParticleDA");
static_assert(offsetof(UKuroGPUParticleDA, JsonDataPath) == 0x000038, "Member 'UKuroGPUParticleDA::JsonDataPath' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, GPUParticleMaterial) == 0x000048, "Member 'UKuroGPUParticleDA::GPUParticleMaterial' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, StartFrame) == 0x000050, "Member 'UKuroGPUParticleDA::StartFrame' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, EndFrame) == 0x000054, "Member 'UKuroGPUParticleDA::EndFrame' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, ColorIntensity) == 0x000058, "Member 'UKuroGPUParticleDA::ColorIntensity' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, VelocityScale) == 0x00005C, "Member 'UKuroGPUParticleDA::VelocityScale' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, AspectRatio) == 0x000060, "Member 'UKuroGPUParticleDA::AspectRatio' has a wrong offset!");
static_assert(offsetof(UKuroGPUParticleDA, AllParticleInfos) == 0x000068, "Member 'UKuroGPUParticleDA::AllParticleInfos' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroGPUParticleSubsystem
// 0x0030 (0x0068 - 0x0038)
class UKuroGPUParticleSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_18B1[0x30];                                    // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UKuroGPUParticleSubsystem* GetKuroGPUParticleSystem(class UWorld* InWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroGPUParticleSubsystem">();
	}
	static class UKuroGPUParticleSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroGPUParticleSubsystem>();
	}
};
static_assert(alignof(UKuroGPUParticleSubsystem) == 0x000008, "Wrong alignment on UKuroGPUParticleSubsystem");
static_assert(sizeof(UKuroGPUParticleSubsystem) == 0x000068, "Wrong size on UKuroGPUParticleSubsystem");

// Class KuroRenderingRuntimeBPPlugin.KuroHaloComponent
// 0x0020 (0x05B0 - 0x0590)
class UKuroHaloComponent final : public UStaticMeshComponent
{
public:
	FMulticastInlineDelegateProperty_             OnParameterChangedEvent;                           // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         HaloMinDrawDistance;                               // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HaloMaxDrawDistance;                               // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HaloMinDrawFadeRange;                              // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HaloMaxDrawFadeRange;                              // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightRadius;                                       // 0x05A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoxExtent;                                         // 0x05AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetRadius(float Radius);

	float GetLightRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroHaloComponent">();
	}
	static class UKuroHaloComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroHaloComponent>();
	}
};
static_assert(alignof(UKuroHaloComponent) == 0x000010, "Wrong alignment on UKuroHaloComponent");
static_assert(sizeof(UKuroHaloComponent) == 0x0005B0, "Wrong size on UKuroHaloComponent");
static_assert(offsetof(UKuroHaloComponent, OnParameterChangedEvent) == 0x000588, "Member 'UKuroHaloComponent::OnParameterChangedEvent' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, HaloMinDrawDistance) == 0x000598, "Member 'UKuroHaloComponent::HaloMinDrawDistance' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, HaloMaxDrawDistance) == 0x00059C, "Member 'UKuroHaloComponent::HaloMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, HaloMinDrawFadeRange) == 0x0005A0, "Member 'UKuroHaloComponent::HaloMinDrawFadeRange' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, HaloMaxDrawFadeRange) == 0x0005A4, "Member 'UKuroHaloComponent::HaloMaxDrawFadeRange' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, LightRadius) == 0x0005A8, "Member 'UKuroHaloComponent::LightRadius' has a wrong offset!");
static_assert(offsetof(UKuroHaloComponent, BoxExtent) == 0x0005AC, "Member 'UKuroHaloComponent::BoxExtent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLensFlare
// 0x0048 (0x0108 - 0x00C0)
class UKuroLensFlare final : public UActorComponent
{
public:
	TArray<struct FVector>                        Vertices;                                          // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Triangles;                                         // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      UVs;                                               // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   VertexColor;                                       // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UProceduralMeshComponent*               MeshComponent;                                     // 0x0100(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector2D GetViewportSize();
	void Init(class UProceduralMeshComponent* InputMeshComponent);
	void InitVecticesData(int32 LensImageLengths);
	bool IsInit();
	bool IsViewportEnable();
	void SetVertsProperties(const struct FVector2D& ViewportScale, const int32 PrimityIndex, const struct FVector2D& UVCenter, const struct FVector2D& UVSize, const struct FVector2D& LensFlareScale, const float LensFlareOffset, const float LensFlareRotation, const struct FLinearColor& LensFlareTint, const struct FVector2D& LensFlareScreenPosition, const struct FVector2D& LensFlareDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLensFlare">();
	}
	static class UKuroLensFlare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLensFlare>();
	}
};
static_assert(alignof(UKuroLensFlare) == 0x000008, "Wrong alignment on UKuroLensFlare");
static_assert(sizeof(UKuroLensFlare) == 0x000108, "Wrong size on UKuroLensFlare");
static_assert(offsetof(UKuroLensFlare, Vertices) == 0x0000C0, "Member 'UKuroLensFlare::Vertices' has a wrong offset!");
static_assert(offsetof(UKuroLensFlare, Triangles) == 0x0000D0, "Member 'UKuroLensFlare::Triangles' has a wrong offset!");
static_assert(offsetof(UKuroLensFlare, UVs) == 0x0000E0, "Member 'UKuroLensFlare::UVs' has a wrong offset!");
static_assert(offsetof(UKuroLensFlare, VertexColor) == 0x0000F0, "Member 'UKuroLensFlare::VertexColor' has a wrong offset!");
static_assert(offsetof(UKuroLensFlare, MeshComponent) == 0x000100, "Member 'UKuroLensFlare::MeshComponent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLevelSequenceActor
// 0x0010 (0x0340 - 0x0330)
class AKuroLevelSequenceActor final : public ALevelSequenceActor
{
public:
	class FName                                   Key;                                               // 0x0330(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B2[0x4];                                     // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelSequenceActor">();
	}
	static class AKuroLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroLevelSequenceActor>();
	}
};
static_assert(alignof(AKuroLevelSequenceActor) == 0x000008, "Wrong alignment on AKuroLevelSequenceActor");
static_assert(sizeof(AKuroLevelSequenceActor) == 0x000340, "Wrong size on AKuroLevelSequenceActor");
static_assert(offsetof(AKuroLevelSequenceActor, Key) == 0x000330, "Member 'AKuroLevelSequenceActor::Key' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroLevelSequenceSubsystem
// 0x0070 (0x00A8 - 0x0038)
class UKuroLevelSequenceSubsystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnLevelSequenceRegister;                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelSequenceUnRegister;                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B3[0x50];                                    // 0x0058(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetAllLevelSequences(TArray<class AKuroLevelSequenceActor*>* InAllLevelSequences);
	class AKuroLevelSequenceActor* GetLevelSequence(const class FName& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroLevelSequenceSubsystem">();
	}
	static class UKuroLevelSequenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroLevelSequenceSubsystem>();
	}
};
static_assert(alignof(UKuroLevelSequenceSubsystem) == 0x000008, "Wrong alignment on UKuroLevelSequenceSubsystem");
static_assert(sizeof(UKuroLevelSequenceSubsystem) == 0x0000A8, "Wrong size on UKuroLevelSequenceSubsystem");
static_assert(offsetof(UKuroLevelSequenceSubsystem, OnLevelSequenceRegister) == 0x000038, "Member 'UKuroLevelSequenceSubsystem::OnLevelSequenceRegister' has a wrong offset!");
static_assert(offsetof(UKuroLevelSequenceSubsystem, OnLevelSequenceUnRegister) == 0x000048, "Member 'UKuroLevelSequenceSubsystem::OnLevelSequenceUnRegister' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent
// 0x0028 (0x00E8 - 0x00C0)
class UKuroMaterialVariationComponent final : public UActorComponent
{
public:
	bool                                          bIsInitSuccess;                                    // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkeletalMeshType;                               // 0x00C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B5[0x6];                                     // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ParentStaticMeshComp;                              // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ParentSkeletalMeshComp;                            // 0x00D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroMaterialVariationRuntimeInfo> AllRuntimeMaterialInfo;                            // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	bool GetKeywordState(class FName PropertyName, int32 MaterialIndex);
	float GetMaterialFloat(class FName PropertyName, int32 MaterialIndex);
	struct FLinearColor GetMaterialLinearColor(class FName PropertyName, int32 MaterialIndex);
	class UTexture* GetMaterialTexture(class FName PropertyName, int32 MaterialIndex);
	bool InitWithSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent);
	bool InitWithStaticMeshComponent(class UStaticMeshComponent* InStaticMeshComponent);
	bool IsComponentValid();
	bool IsMaterialVariationDataValid(class UMeshComponent* CheckMeshComponent, const TArray<class UKuroMaterialVariationCollection*>& CheckCollection);
	void ReplaceMaterial(class UMaterialInterface* MatToReplace, int32 MaterialIndex);
	void RevertMaterial(int32 MaterialIndex);
	void RevertMaterialFloat(class FName PropertyName, int32 MaterialIndex);
	void RevertMaterialFloatAll(class FName PropertyName);
	void RevertMaterialLinearColor(class FName PropertyName, int32 MaterialIndex);
	void RevertMaterialLinearColorAll(class FName PropertyName);
	void RevertMaterialTexture(class FName PropertyName, int32 MaterialIndex);
	void RevertMaterialTextureAll(class FName PropertyName);
	void SetKeywordState(class FName Keyword, bool InIsEnable, int32 MaterialIndex);
	void SetKeywordStateAll(class FName Keyword, bool InIsEnable);
	void SetMaterialFloat(class FName PropertyName, float InValue, int32 MaterialIndex);
	void SetMaterialFloatAll(class FName PropertyName, float InValue);
	void SetMaterialLinearColor(class FName PropertyName, const struct FLinearColor& InValue, int32 MaterialIndex);
	void SetMaterialLinearColorAll(class FName PropertyName, const struct FLinearColor& InValue);
	void SetMaterialTexture(class FName PropertyName, class UTexture* InValue, int32 MaterialIndex);
	void SetMaterialTextureAll(class FName PropertyName, class UTexture* InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMaterialVariationComponent">();
	}
	static class UKuroMaterialVariationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMaterialVariationComponent>();
	}
};
static_assert(alignof(UKuroMaterialVariationComponent) == 0x000008, "Wrong alignment on UKuroMaterialVariationComponent");
static_assert(sizeof(UKuroMaterialVariationComponent) == 0x0000E8, "Wrong size on UKuroMaterialVariationComponent");
static_assert(offsetof(UKuroMaterialVariationComponent, bIsInitSuccess) == 0x0000C0, "Member 'UKuroMaterialVariationComponent::bIsInitSuccess' has a wrong offset!");
static_assert(offsetof(UKuroMaterialVariationComponent, bIsSkeletalMeshType) == 0x0000C1, "Member 'UKuroMaterialVariationComponent::bIsSkeletalMeshType' has a wrong offset!");
static_assert(offsetof(UKuroMaterialVariationComponent, ParentStaticMeshComp) == 0x0000C8, "Member 'UKuroMaterialVariationComponent::ParentStaticMeshComp' has a wrong offset!");
static_assert(offsetof(UKuroMaterialVariationComponent, ParentSkeletalMeshComp) == 0x0000D0, "Member 'UKuroMaterialVariationComponent::ParentSkeletalMeshComp' has a wrong offset!");
static_assert(offsetof(UKuroMaterialVariationComponent, AllRuntimeMaterialInfo) == 0x0000D8, "Member 'UKuroMaterialVariationComponent::AllRuntimeMaterialInfo' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem
// 0x0008 (0x0040 - 0x0038)
class UKuroPlayerPrefsSystem final : public UWorldSubsystem
{
public:
	class UKuroSaveGame*                          KuroSaveGame;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DeleteAll();
	void DeleteKey(const class FString& Key);
	float GetFloat(const class FString& Key, float DefaultValue);
	int32 GetInt(const class FString& Key, int32 DefaultValue);
	class FString GetString(const class FString& Key, const class FString& DefaultValue);
	bool HasKey(const class FString& Key);
	void Save();
	void SetFloat(const class FString& Key, float Value);
	void SetInt(const class FString& Key, int32 Value);
	void SetString(const class FString& Key, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPlayerPrefsSystem">();
	}
	static class UKuroPlayerPrefsSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPlayerPrefsSystem>();
	}
};
static_assert(alignof(UKuroPlayerPrefsSystem) == 0x000008, "Wrong alignment on UKuroPlayerPrefsSystem");
static_assert(sizeof(UKuroPlayerPrefsSystem) == 0x000040, "Wrong size on UKuroPlayerPrefsSystem");
static_assert(offsetof(UKuroPlayerPrefsSystem, KuroSaveGame) == 0x000038, "Member 'UKuroPlayerPrefsSystem::KuroSaveGame' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPostProcessComponent
// 0x0B80 (0x13C0 - 0x0840)
class UKuroPostProcessComponent final : public UPostProcessComponent
{
public:
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x0838(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroTODData*                           PPTODDataAsset;                                    // 0x0840(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C3[0x8];                                     // 0x0848(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroGISetting                         GISetting;                                         // 0x0850(0x0B40)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	class AVolume*                                ReferencedVolumeActor;                             // 0x1390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C4[0x28];                                    // 0x1398(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PostModify();
	void SetPPTODDataAsset(class UKuroTODData* InPPTODDataAsset);
	void SetReferencedVolumeActor(class AVolume* InReferencedVolumeActor);
	void SetWeatherDataAsset(class UKuroWeatherDataAsset* InWeatherDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPostProcessComponent">();
	}
	static class UKuroPostProcessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroPostProcessComponent>();
	}
};
static_assert(alignof(UKuroPostProcessComponent) == 0x000010, "Wrong alignment on UKuroPostProcessComponent");
static_assert(sizeof(UKuroPostProcessComponent) == 0x0013C0, "Wrong size on UKuroPostProcessComponent");
static_assert(offsetof(UKuroPostProcessComponent, WeatherDataAsset) == 0x000838, "Member 'UKuroPostProcessComponent::WeatherDataAsset' has a wrong offset!");
static_assert(offsetof(UKuroPostProcessComponent, PPTODDataAsset) == 0x000840, "Member 'UKuroPostProcessComponent::PPTODDataAsset' has a wrong offset!");
static_assert(offsetof(UKuroPostProcessComponent, GISetting) == 0x000850, "Member 'UKuroPostProcessComponent::GISetting' has a wrong offset!");
static_assert(offsetof(UKuroPostProcessComponent, ReferencedVolumeActor) == 0x001390, "Member 'UKuroPostProcessComponent::ReferencedVolumeActor' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroPostProcessVolume
// 0x0B70 (0x1480 - 0x0910)
class AKuroPostProcessVolume final : public APostProcessVolume
{
public:
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x0908(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroTODData*                           PPTODDataAsset;                                    // 0x0910(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C5[0x8];                                     // 0x0918(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroGISetting                         GISetting;                                         // 0x0920(0x0B40)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C6[0x20];                                    // 0x1460(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PostModify();
	void SetPPTODDataAsset(class UKuroTODData* InPPTODDataAsset);
	void SetWeatherDataAsset(class UKuroWeatherDataAsset* InWeatherDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroPostProcessVolume">();
	}
	static class AKuroPostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroPostProcessVolume>();
	}
};
static_assert(alignof(AKuroPostProcessVolume) == 0x000010, "Wrong alignment on AKuroPostProcessVolume");
static_assert(sizeof(AKuroPostProcessVolume) == 0x001480, "Wrong size on AKuroPostProcessVolume");
static_assert(offsetof(AKuroPostProcessVolume, WeatherDataAsset) == 0x000908, "Member 'AKuroPostProcessVolume::WeatherDataAsset' has a wrong offset!");
static_assert(offsetof(AKuroPostProcessVolume, PPTODDataAsset) == 0x000910, "Member 'AKuroPostProcessVolume::PPTODDataAsset' has a wrong offset!");
static_assert(offsetof(AKuroPostProcessVolume, GISetting) == 0x000920, "Member 'AKuroPostProcessVolume::GISetting' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRainSettings
// 0x02D0 (0x0308 - 0x0038)
class UKuroRainSettings final : public UPrimaryDataAsset
{
public:
	struct FVector                                RainBoxSize;                                       // 0x0038(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C7[0x4];                                     // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            RainMesh;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             BoxCountPositive;                                  // 0x0050(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             BoxCountNegative;                                  // 0x005C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraOffsetSize;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleCameraOffsetY;                                // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        GravityWeightCurve;                                // 0x0070(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        WindWeightCurve;                                   // 0x0100(0x0090)(Edit, NativeAccessSpecifierPublic)
	bool                                          RainDropSizeUseSpeed;                              // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C8[0x7];                                     // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveVector2D                     RaindropSizeCurve;                                 // 0x0198(0x0120)(Edit, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKuroRainMaterialFloatParameter> MaterialFloatParameters_Density;                   // 0x02C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroRainMaterialColorParameter> MaterialColorParameters_Density;                   // 0x02D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroRainMaterialFloatParameter> MaterialFloatParameters_Speed;                     // 0x02E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroRainMaterialColorParameter> MaterialColorParameters_Speed;                     // 0x02F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         FramesIntervalUpdateParameters;                    // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FramesIntervalFixRainBoxes;                        // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainSettings">();
	}
	static class UKuroRainSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRainSettings>();
	}
};
static_assert(alignof(UKuroRainSettings) == 0x000008, "Wrong alignment on UKuroRainSettings");
static_assert(sizeof(UKuroRainSettings) == 0x000308, "Wrong size on UKuroRainSettings");
static_assert(offsetof(UKuroRainSettings, RainBoxSize) == 0x000038, "Member 'UKuroRainSettings::RainBoxSize' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, RainMesh) == 0x000048, "Member 'UKuroRainSettings::RainMesh' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, BoxCountPositive) == 0x000050, "Member 'UKuroRainSettings::BoxCountPositive' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, BoxCountNegative) == 0x00005C, "Member 'UKuroRainSettings::BoxCountNegative' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, CameraOffsetSize) == 0x000068, "Member 'UKuroRainSettings::CameraOffsetSize' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, ScaleCameraOffsetY) == 0x00006C, "Member 'UKuroRainSettings::ScaleCameraOffsetY' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, GravityWeightCurve) == 0x000070, "Member 'UKuroRainSettings::GravityWeightCurve' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, WindWeightCurve) == 0x000100, "Member 'UKuroRainSettings::WindWeightCurve' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, RainDropSizeUseSpeed) == 0x000190, "Member 'UKuroRainSettings::RainDropSizeUseSpeed' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, RaindropSizeCurve) == 0x000198, "Member 'UKuroRainSettings::RaindropSizeCurve' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, Material) == 0x0002B8, "Member 'UKuroRainSettings::Material' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, MaterialFloatParameters_Density) == 0x0002C0, "Member 'UKuroRainSettings::MaterialFloatParameters_Density' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, MaterialColorParameters_Density) == 0x0002D0, "Member 'UKuroRainSettings::MaterialColorParameters_Density' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, MaterialFloatParameters_Speed) == 0x0002E0, "Member 'UKuroRainSettings::MaterialFloatParameters_Speed' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, MaterialColorParameters_Speed) == 0x0002F0, "Member 'UKuroRainSettings::MaterialColorParameters_Speed' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, FramesIntervalUpdateParameters) == 0x000300, "Member 'UKuroRainSettings::FramesIntervalUpdateParameters' has a wrong offset!");
static_assert(offsetof(UKuroRainSettings, FramesIntervalFixRainBoxes) == 0x000304, "Member 'UKuroRainSettings::FramesIntervalFixRainBoxes' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRainActor
// 0x0190 (0x0438 - 0x02A8)
class AKuroRainActor final : public AActor
{
public:
	class UKuroRainSettings*                      Settings;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BasicGravity;                                      // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C9[0xD4];                                    // 0x02B4(0x00D4)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          MeshComp;                                          // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      MaterialParameterOverrideFloat;                    // 0x0398(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FLinearColor>        MaterialParameterOverrideColor;                    // 0x03E8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	class UMaterialInstanceDynamic* GetDynamicMaterial();
	bool GetIsInit();
	void SetCurrentRain(float InDensity, float InGravity, float InWindX, float InWindY, float InWindZ);
	void SetMaterialParameterOverrideColor(class FName Param_Name, const struct FLinearColor& Value);
	void SetMaterialParameterOverrideFloat(class FName Param_Name, float Value);
	void SetupRainConfig();
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainActor">();
	}
	static class AKuroRainActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRainActor>();
	}
};
static_assert(alignof(AKuroRainActor) == 0x000008, "Wrong alignment on AKuroRainActor");
static_assert(sizeof(AKuroRainActor) == 0x000438, "Wrong size on AKuroRainActor");
static_assert(offsetof(AKuroRainActor, Settings) == 0x0002A8, "Member 'AKuroRainActor::Settings' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, BasicGravity) == 0x0002B0, "Member 'AKuroRainActor::BasicGravity' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, MeshComp) == 0x000388, "Member 'AKuroRainActor::MeshComp' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, DynamicMaterial) == 0x000390, "Member 'AKuroRainActor::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, MaterialParameterOverrideFloat) == 0x000398, "Member 'AKuroRainActor::MaterialParameterOverrideFloat' has a wrong offset!");
static_assert(offsetof(AKuroRainActor, MaterialParameterOverrideColor) == 0x0003E8, "Member 'AKuroRainActor::MaterialParameterOverrideColor' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRainActorV2
// 0x0008 (0x02C0 - 0x02B8)
class AKuroRainActorV2 final : public AKuroEditorTickActor
{
public:
	uint8                                         Pad_18CA[0x8];                                     // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UKuroRainComponent* AddRainComponent(TSubclassOf<class UKuroRainComponent> ClassType);
	void DisableRain();
	void EnableRain();
	void GetPlayerOrEditorCameraLocation(struct FVector* OutLocation);
	void RemoveRainComponent(class UKuroRainComponent* Comp);
	void SetCameraFrustum(class UKuroRainComponent* Comp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainActorV2">();
	}
	static class AKuroRainActorV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRainActorV2>();
	}
};
static_assert(alignof(AKuroRainActorV2) == 0x000008, "Wrong alignment on AKuroRainActorV2");
static_assert(sizeof(AKuroRainActorV2) == 0x0002C0, "Wrong size on AKuroRainActorV2");

// Class KuroRenderingRuntimeBPPlugin.KuroRainComponent
// 0x0010 (0x0230 - 0x0220)
class UKuroRainComponent final : public USceneComponent
{
public:
	uint8                                         Pad_18CB[0x8];                                     // 0x0218(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoPlay;                                         // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18CC[0xF];                                     // 0x0221(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddArraySpawner(int32 RenderIndex);
	int32 AddCustomRandomByNormalizedAgeProcessor(const struct FKuroCurveFloat& Curve, int32 Param_Index);
	int32 AddCustomRandomByVelocityProcessor(const struct FKuroCurveFloat& Curve, int32 Param_Index);
	int32 AddCustomRandomSetProcessor(float Value, int32 Param_Index);
	int32 AddCycleBoxProcessor(const struct FVector& Min, const struct FVector& Max, bool bKillOnZ);
	int32 AddDragProcessor(float DragSize);
	int32 AddLinearForceProcessor(const struct FVector& Force);
	int32 AddRandomSpawner(int32 RenderIndex);
	int32 AddVectorFieldForceProcessor(class UVectorFieldStatic* InVectorField, const struct FVector& InPosScale, const struct FVector& InMoveSpeed, float InForceSize);
	int32 AddWindProcessor(const struct FVector& WindVelocity);
	struct FVector GetCycleBoxProcessor_Max(int32 ProcessorID);
	struct FVector GetCycleBoxProcessor_Min(int32 ProcessorID);
	float GetDragProcessor_DragSize(int32 ProcessorID);
	int32 GetEmitterDataNum();
	bool GetIsPlaying();
	struct FVector GetLinearForceProcessor_Force(int32 ProcessorID);
	struct FVector GetWindProcessor_WindVelocity(int32 ProcessorID);
	void Init();
	void PreSolveRainParticles(float DeltaSeconds);
	void SetArraySpawnerBasic(int32 SpawnerID, int32 ArraySize, float ArrayLength, float SpawnTimeWiggle, float SpawnPositionWiggle, float LifeTimeMin, float LifeTimeMax, float ScaleMin, float ScaleMax, float BaseMassMin, float BaseMassMax);
	void SetArraySpawnerRuntime(int32 SpawnerID, const struct FVector& SpawnCenter, float SpawnRate, const struct FVector& VelocityMin, const struct FVector& VelocityMax);
	void SetCustomRandomByNormalizedAgeProcessor(int32 ProcessorID, const struct FKuroCurveFloat& Curve, int32 Param_Index);
	void SetCustomRandomByVelocityProcessor(int32 ProcessorID, const struct FKuroCurveFloat& Curve, int32 Param_Index);
	void SetCustomRandomSetProcessor(int32 ProcessorID, float Value, int32 Param_Index);
	void SetCycleBoxProcessor(int32 ProcessorID, const struct FVector& Min, const struct FVector& Max);
	void SetDragProcessor(int32 ProcessorID, float DragSize);
	void SetLifeTimeDilation(float Dilation);
	void SetLinearForceProcessor(int32 ProcessorID, const struct FVector& Force);
	void SetRandomSpawnerBasic(int32 SpawnerID, float SpawnInnerRadius, float SpawnOuterRadius, float LifeTimeMin, float LifeTimeMax, float ScaleMin, float ScaleMax, float BaseMassMin, float BaseMassMax);
	void SetRandomSpawnerRuntime(int32 SpawnerID, const struct FVector& SpawnCenter, float SpawnRate, const struct FVector& VelocityMin, const struct FVector& VelocityMax);
	void SetTimeDilation(float Dilation);
	void Setup(const TArray<class UStaticMesh*>& Meshes, const TArray<class UMaterialInterface*>& Materials);
	void SetupRainEmitters();
	void SetVectorFieldForceProcessor_Others(int32 ProcessorID, const struct FVector& InPosScale, const struct FVector& InMoveSpeed, float InForceSize);
	void SetVectorFieldForceProcessor_VectorField(int32 ProcessorID, class UVectorFieldStatic* InVectorField);
	void SetWindProcessor(int32 ProcessorID, const struct FVector& WindVelocity);
	void Start();
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainComponent">();
	}
	static class UKuroRainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRainComponent>();
	}
};
static_assert(alignof(UKuroRainComponent) == 0x000010, "Wrong alignment on UKuroRainComponent");
static_assert(sizeof(UKuroRainComponent) == 0x000230, "Wrong size on UKuroRainComponent");
static_assert(offsetof(UKuroRainComponent, bAutoPlay) == 0x000220, "Member 'UKuroRainComponent::bAutoPlay' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroRainManager
// 0x00C0 (0x00F0 - 0x0030)
class UKuroRainManager final : public UObject
{
public:
	uint8                                         Pad_18D3[0xC0];                                    // 0x0030(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRainManager">();
	}
	static class UKuroRainManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRainManager>();
	}
};
static_assert(alignof(UKuroRainManager) == 0x000008, "Wrong alignment on UKuroRainManager");
static_assert(sizeof(UKuroRainManager) == 0x0000F0, "Wrong size on UKuroRainManager");

// Class KuroRenderingRuntimeBPPlugin.KuroRenderingAsyncTaskSystem
// 0x0058 (0x0090 - 0x0038)
class UKuroRenderingAsyncTaskSystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_18D4[0x58];                                    // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRenderingAsyncTaskSystem">();
	}
	static class UKuroRenderingAsyncTaskSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRenderingAsyncTaskSystem>();
	}
};
static_assert(alignof(UKuroRenderingAsyncTaskSystem) == 0x000008, "Wrong alignment on UKuroRenderingAsyncTaskSystem");
static_assert(sizeof(UKuroRenderingAsyncTaskSystem) == 0x000090, "Wrong size on UKuroRenderingAsyncTaskSystem");

// Class KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroRenderingRuntimeBPPluginBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAdditionalClusteredStuff(class UObject* WorldContextObject, class UClusteredStuffDataAsset* Asset);
	static int32 AddPostprocessMaterial(class UObject* WorldContextObject, class UMaterialInterface* Material, float Priority);
	static bool AddWeatherDataType(class UObject* WorldContextObject, class FName Identifier, class UClass* ClassType);
	static void ClearObjectFlags(class UObject* Object, int32 Param_Flags);
	static void ClipboardCopy_EditorOnly(const class FString& Str);
	static void ClipboardPaste_EditorOnly(class FString* Dest);
	static void CopyKuroCharColorGroupArray(const TArray<struct FKuroCharMaterialControllerColorGroup>& Target, const TArray<struct FKuroCurveLinearColor>& Start, const TArray<struct FKuroCurveLinearColor>& Loop, const TArray<struct FKuroCurveLinearColor>& End);
	static void CopyKuroCharColorParameter(struct FKuroCharMaterialControllerColorParameter* Target, const class FName& ParameterName, const struct FKuroCurveLinearColor& ParameterValue);
	static void CopyKuroCharFloatGroup(struct FKuroCharMaterialControllerFloatGroup* Target, const struct FKuroCurveFloat& Start, const struct FKuroCurveFloat& Loop, const struct FKuroCurveFloat& End);
	static void CopyKuroCharFloatGroupArray(const TArray<struct FKuroCharMaterialControllerFloatGroup>& Target, const TArray<struct FKuroCurveFloat>& Start, const TArray<struct FKuroCurveFloat>& Loop, const TArray<struct FKuroCurveFloat>& End);
	static void CopyKuroCharFloatParameter(struct FKuroCharMaterialControllerFloatParameter* Target, const class FName& ParameterName, const struct FKuroCurveFloat& ParameterValue);
	static void CopyKuroCharLinearColorGroup(struct FKuroCharMaterialControllerColorGroup* Target, const struct FKuroCurveLinearColor& Start, const struct FKuroCurveLinearColor& Loop, const struct FKuroCurveLinearColor& End);
	static class AActor* CreateGITransientActor(class UObject* WorldContextObject, class FName IdName, bool bAttachToPlayer, bool bAttachToEditorCamera, class FName EditorFolderPath);
	static void DeleteAll(const class UObject* WorldContextObject);
	static void DeleteKey(const class UObject* WorldContextObject, const class FString& Key);
	static void DestroyGITransientActor(class UObject* WorldContextObject, class FName IdName);
	static void FreezeWorldLevelStreaming(const class UObject* WorldContextObject);
	static void GetActorForwardVectorRef(class AActor* Actor, struct FVector* RefForwardVector);
	static void GetActorForwardVectorRefXYZ(class AActor* Actor, float* X, float* Y, float* Z);
	static void GetActorLocationRef(class AActor* Actor, struct FVector* RefLocation);
	static void GetActorLocationRefXYZ(class AActor* Actor, float* X, float* Y, float* Z);
	static class AActor* GetActorOfClass(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass);
	static void GetActorsInLevel(const class ULevel* InLevel, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors);
	static float GetAndAddCurveFloatSampleTask(int64 LastFrameHandle, const struct FKuroCurveFloat& Curve, float Time, float Default, int64* OutHandle);
	static struct FVector2D GetAndroidRawResolution();
	static TArray<struct FAssetData> GetAssetsByPath(class FName PackagePath, bool bRecursive, bool bIncludeOnlyOnDiskAssets);
	static struct FQuat GetBoneDirection(class USkeletalMeshComponent* SkeletalMeshComponent, class FName BoneName);
	static void GetCacheCameraInfo(class APlayerCameraManager* Owner, struct FMinimalViewInfo* Inout);
	static bool GetCaveOrRoomState(const class UObject* WorldContextObject, class FString* EnClosetDataLayer, class FString* EnCloseSubDataLayer, ECaveOrRoomLoadType* OutLoadType, float* OutLoadCoef);
	static int32 GetCharacterSectionCount(class USkeletalMesh* Mesh);
	static TArray<int32> GetCharacterSectionInfo(class USkeletalMesh* Mesh, int32 SectionIndex);
	static int32 GetCharacterSectionMaterialIndex(class USkeletalMesh* SkeletalMesh, int32 SectionIndex);
	static struct FLinearColor GetColorFromGroup(struct FKuroCharMaterialControllerColorGroup* Target, const float Factor, const int32 Type);
	static class UPhysicalMaterial* GetComponentPhysicalMaterial(class UPrimitiveComponent* Component);
	static float GetCVarFloat(const class FString& CVarKey);
	static int32 GetDeviceHardwareLevel();
	static class FString GetDeviceProfileBaseProfileName();
	static int32 GetDeviceProfileDeviceScore();
	static class FString GetDeviceProfileDeviceType();
	static float GetFloat(const class UObject* WorldContextObject, const class FString& Key, float DefaultValue);
	static float GetFloatGromGroup(struct FKuroCharMaterialControllerFloatGroup* Target, const float Factor, const int32 Type);
	static struct FVector2D GetGameResolution();
	static struct FVector2D GetGameViewportSize();
	static class AActor* GetGITransientActor(class UObject* WorldContextObject, class FName IdName);
	static class AActor* GetGlobalGIActor(const class UObject* WorldContextObject);
	static int32 GetInt(const class UObject* WorldContextObject, const class FString& Key, int32 DefaultValue);
	static class UKuroLandscapeParametersData* GetKuroLandscapeParametersDataAsset();
	static class ULevel* GetLevel(const class UWorld* World);
	static TArray<class AActor*> GetLevelActors(class ULevel* InLevel);
	static bool GetLevelEditorCameraLocationAndForward(const class UObject* WorldContextObject, struct FVector* Position, struct FRotator* Rotation);
	static bool GetLevelEditorViewPortSize(const class UObject* WorldContextObject, struct FVector2D* ViewPortSize);
	static void GetNiagaraParticleCount(class UNiagaraComponent* NiagaraComponent, int32* ActiveEmitters, int32* ActiveParticles);
	static int32 GetObjectMaskedFlags(class UObject* Object, int32 Mask);
	static int32 GetOverlappingBoxCountForAllFoliageActors(const class UObject* WorldContextObject, const class UFoliageType* FoliageType, const struct FBox& Box, int32 Max);
	static void GetPcLightCullParameters(class ULightComponent* LightComponent, float* LightMinDistance, float* LightMaxDistance, float* LightMinFade, float* LightMaxFade);
	static int32 GetPhysicalGBRam();
	static bool GetPostProcessGIDataDebugInfo(const class UObject* WorldContextObject, const struct FVector& WorldPosition, TArray<struct FPostprocessGIDebugInfo>* OutDAResult, TArray<struct FPostprocessGIDebugInfo>* OutOverrideResult);
	static bool GetPostProcessGIDataDebugNames(const class UObject* WorldContextObject, TArray<class FName>* OutDANames);
	static bool GetPostProcessGIDataNames(const class UObject* WorldContextObject, const struct FVector& WorldPosition, TArray<class FString>* OutDANames);
	static class FString GetRHIDeviceName();
	static class FString GetRHIDriverVersion();
	static class FString GetRHIName();
	static class FString GetRHIVendorName();
	static void GetSceneColorContainLGUIShotNow();
	static void GetSceneColorShotNow();
	static class AActor* GetSceneInteractionLevelActor(class ULevel* InLevel);
	static int32 GetSkeletalMaterialCount(class USkeletalMesh* Skel);
	static class UMaterialInterface* GetSkeletalMaterialInterface(class USkeletalMesh* Skel, int32 MaterialIndex);
	static class FString GetSkeletalMaterialSlotName(class USkeletalMesh* Skel, int32 MaterialIndex);
	static bool GetSpaceStateByPosition(const class UObject* WorldContextObject, const struct FVector& InPoisition, ECaveOrRoom* OutSpaceType, class FString* OutEnClosetDataLayer, class FString* OutEnCloseSubDataLayer);
	static bool GetStreamingCells(const class UObject* WorldContextObject, const struct FWorldPartitionStreamingQuerySource& QuerySource, TArray<struct FWorldPartitionRuntimeSpatialHashCell>* OutCells);
	static class FString GetString(const class UObject* WorldContextObject, const class FString& Key, const class FString& DefaultValue);
	static class UWorldSubsystem* GetSubsystem(const class UObject* WorldContextObject, TSubclassOf<class UWorldSubsystem> WorldSubsystemClass);
	static void GetVectorParameterValueRef(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, struct FLinearColor* RefLinearColor);
	static void GetVectorParameterValueRefRGBA(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, float* RefLinearColorR, float* RefLinearColorG, float* RefLinearColorB, float* RefLinearColorA);
	static class UObject* GetWeatherDataRef(class UObject* WorldContextObject, class FName Identifier);
	static class UWorld* GetWorld(const class UObject* WorldContextObject);
	static EKuroFeatureLevel GetWorldFeatureLevel(const class UObject* WorldContextObject);
	static class UWorldPartition* GetWorldPartition(const class UObject* WorldContextObject);
	static TArray<class FString> GetWorldPartitionAllDataLayerNames(const class UObject* WorldContextObject);
	static void GetWorldPartitionDataLayerNameByLabel(const class UObject* WorldContextObject, const class FName& InDataLayerLabel, class FName* OutDataLayerNamme);
	static class AWorldSettings* GetWorldSetting(const class UObject* WorldContextObject);
	static EBP_EWorldType GetWorldType(const class UObject* WorldContextObject);
	static void GetWpWorldBound(const class UObject* WorldContextObject, struct FVector* BoundMin, struct FVector* BoundMax);
	static void HasAllObjectFlags(class UObject* Object, int32 Param_Flags);
	static void HasAnyObjectFlags(class UObject* Object, int32 Param_Flags);
	static bool HasKey(const class UObject* WorldContextObject, const class FString& Key);
	static struct FLinearColor HSP2RGB(const struct FLinearColor& Hsp);
	static bool IsCurrentPlatformPC(class AActor* Actor);
	static bool IsDistanceCull(const class UObject* WorldContextObject, class UNiagaraEffectType* EffectType, const struct FVector& Location);
	static bool IsEditorOnlyActor(const class AActor* Actor);
	static bool IsNiagaraComplete(class UNiagaraComponent* NiagaraComponent);
	static bool IsParticleComplete(class UParticleSystemComponent* ParticleSystemComponent);
	static bool IsPositionInCaveOrRoom(const class UObject* WorldContextObject, const struct FVector& InPoisition);
	static bool IsPostprocessMaterialActive(class UObject* WorldContextObject, int32 Handle);
	static bool IsUsingNotSeparateCache();
	static bool IsUsingParallaxCorrect();
	static bool IsWorldPartitionDataLayerEnable(const class UObject* WorldContextObject, class FName DataLayerName);
	static bool IsWorldPartitionWorld(class UObject* WorldContextObject);
	static bool IsWpPlayerInCaveOrRoom(const class UObject* WorldContextObject);
	static void KuroMarkPackageDirty(class UObject* Object);
	static class UActorSequencePlayer* MakeSequencePlayer(class UActorSequenceComponent* SequenceComponent, const struct FMovieSceneSequencePlaybackSettings& PlaybackSettings);
	static bool MaterialHasParameter_EditorOnly(class UMaterialInterface* MaterialInterface, const class FString& ParameterName);
	static void MessageNotify_EditorOnly(const class FText& Message, const class FName Tile);
	static void MoveCurveColorValueToOtherTime(class UCurveLinearColor* Curve, float SrcTime, float TargetTime);
	static void MoveCurveFloatValueToOtherTime(class UCurveFloat* Curve, float SrcTime, float TargetTime);
	static struct FVector2D PackLinearColorRGBToVector2D(const struct FLinearColor& Color);
	static bool ProjectWorldToScreenWithLevelEditorViewPort(const class UObject* WorldContextObject, const struct FVector& WorldPosition, struct FVector4* Result);
	static bool ProjectWorldToScreenWithLevelEditorViewPortFloatRef(const class UObject* WorldContextObject, const struct FVector& WorldPosition, float* ResultX, float* ResultY, float* ResultZ, float* ResultW);
	static void ReleaseGetSceneColorShotBefore();
	static void RemoveAdditionalClusteredStuff(class UObject* WorldContextObject, class UClusteredStuffDataAsset* Asset);
	static void RemovePostprocessMaterial(class UObject* WorldContextObject, int32 Handle);
	static void RerunConstructionScripts(class AActor* Actor);
	static void ResetParticleSystem(class UParticleSystemComponent* ParticleSystemComponent);
	static void ResumeSomeWeatherAfterTeleport(class UObject* WorldContextObject);
	static struct FLinearColor RGB2HSP(const struct FLinearColor& Rgb);
	static void Save(const class UObject* WorldContextObject);
	static void SetActorUISceneRendering(class AActor* Actor, bool IsUISceneRendering);
	static void SetClusteredStuffVisible(class UObject* WorldContextObject, bool Visible);
	static void SetCVarFloat(const class FString& CVarKey, float Value);
	static void SetCVarInt32(const class FString& CVarKey, int32 Value);
	static void SetFloat(const class UObject* WorldContextObject, const class FString& Key, float Value);
	static void SetGITransientActorAttachment(class UObject* WorldContextObject, class FName IdName, bool bAttachToPlayer, bool bAttachToEditorCamera);
	static bool SetGlobalGITime(const class UObject* WorldContextObject, float Time);
	static void SetInt(const class UObject* WorldContextObject, const class FString& Key, int32 Value);
	static void SetIntsDataToRenderTarget(class UTextureRenderTarget2D* TextureRenderTarget, const TArray<int32>& WriteData);
	static void SetIsUsingInCaveOrIndoorShadow(const class UObject* WorldContextObject, bool IsUsing, float MobileCSMDistanceInCave, float MobileCSMDistanceOutCave);
	static bool SetLevelEditorCameraLocation(const class UObject* WorldContextObject, const struct FVector& Position);
	static void SetNiagaraSkeletalMeshComponentWithoutWarning(class UNiagaraComponent* NiagaraSystem, const class FString& OverrideName, class USkeletalMeshComponent* SkeletalMeshComponent);
	static void SetNiagaraSplineComponent(class UNiagaraComponent* NiagaraSystem, const class FString& OverrideName, class USplineComponent* SplineComponent);
	static void SetObjectFlags(class UObject* Object, int32 Param_Flags);
	static void SetSceneKuroMainPlayerLocation(const class UObject* WorldContextObject, int32 PlayerIndex);
	static void SetSceneRenderingState(class UObject* WorldContextObject, bool bSceneVisible);
	static void SetString(const class UObject* WorldContextObject, const class FString& Key, const class FString& Value);
	static void SetSunLensflareEnabled(class UObject* WorldContextObject, bool bEnabled);
	static void SetTransformLocationInArray(TArray<struct FTransform>* TransformArray, int32 Param_Index, const struct FVector& Location);
	static void SetupVolumeSize(class AVolume* Volume, const struct FBox& Bounds);
	static void SetUsingInCaveOrIndoorShadow(class UDirectionalLightComponent* LightComp, bool IsUsing, float MobileCSMDistanceOld, float MobileCSMDistanceNew);
	static void SetVectorParameterValueRef(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, class FName ParameterName, struct FLinearColor* RefLinearColor);
	static void SetWorldPartitionDataLayerState(const class UObject* WorldContextObject, class FName DataLayerName, bool IsActivate);
	static void SetWorldPartitionStreamingEnable(const class UObject* WorldContextObject, bool bStreamingEnable);
	static void SortStringArray(const TArray<class FString>& InStringArray, const ESearchCase SearchCase, const bool Descending);
	static class AActor* SpawnActorFromClass(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bTemporaryEditorActor);
	static class AActor* SpawnTransientActor(class UObject* WorldContextObject, const class FName& Param_Name, const class FName& FolderPath);
	static void StopSomeWeatherBeforeTeleport(class UObject* WorldContextObject);
	static void UnFreezeWorldLevelStreaming(const class UObject* WorldContextObject);
	static struct FLinearColor UnpackVector2DToLinearColorRGB(const struct FVector2D& Vector2D);
	static void UpdateEffectTransform(const bool ForceUpdate, class USceneComponent* SceneComponent, const struct FKuroCurveVector& LocationCurve, const struct FKuroCurveVector& RotationCurve, const struct FKuroCurveVector& ScaleCurve, const float Time);
	static void UpdateEffectTransformLocation(const bool ForceUpdate, class USceneComponent* SceneComponent, const struct FKuroCurveVector& LocationCurve, const float Time);
	static void UpdateFoliageDataLayer(const class UObject* WorldContextObject, const int32 InMobileLevel);
	static void UpdateOrAddCurveColorValue(class UCurveLinearColor* Curve, float InTime, const struct FLinearColor& InValue);
	static void UpdateOrAddCurveFloatValue(class UCurveFloat* Curve, float InTime, float InValue);
	static void WpBeginAdjustLoadRange(const class UObject* WorldContextObject, float InAdjustValue, ECaveOrRoomLoadType InLoadType, bool bUseCustomCoef);
	static void WpBeginEnterCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer);
	static void WpBeginLeaveCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer);
	static void WpCancelAdjustLoadRange(const class UObject* WorldContextObject);
	static void WpEnterCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer, float InAdjustValue, ECaveOrRoomLoadType LoadType, bool bUseCustomCoef);
	static void WpLeaveCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer);
	static void WpPEnterCaveOrRoom(const class UObject* WorldContextObject, const class FName& EncloseDataLayer, const class FName& EncloseSubDataLayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRenderingRuntimeBPPluginBPLibrary">();
	}
	static class UKuroRenderingRuntimeBPPluginBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroRenderingRuntimeBPPluginBPLibrary>();
	}
};
static_assert(alignof(UKuroRenderingRuntimeBPPluginBPLibrary) == 0x000008, "Wrong alignment on UKuroRenderingRuntimeBPPluginBPLibrary");
static_assert(sizeof(UKuroRenderingRuntimeBPPluginBPLibrary) == 0x000030, "Wrong size on UKuroRenderingRuntimeBPPluginBPLibrary");

// Class KuroRenderingRuntimeBPPlugin.KuroRuntimeTransientActor
// 0x0010 (0x02B8 - 0x02A8)
class AKuroRuntimeTransientActor final : public AActor
{
public:
	uint8                                         Pad_1934[0x10];                                    // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroRuntimeTransientActor">();
	}
	static class AKuroRuntimeTransientActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroRuntimeTransientActor>();
	}
};
static_assert(alignof(AKuroRuntimeTransientActor) == 0x000008, "Wrong alignment on AKuroRuntimeTransientActor");
static_assert(sizeof(AKuroRuntimeTransientActor) == 0x0002B8, "Wrong size on AKuroRuntimeTransientActor");

// Class KuroRenderingRuntimeBPPlugin.KuroSaveGame
// 0x00F0 (0x0120 - 0x0030)
class UKuroSaveGame final : public USaveGame
{
public:
	TMap<class FString, int32>                    IntMap;                                            // 0x0030(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, float>                    FloatMap;                                          // 0x0080(0x0050)(NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            StringMap;                                         // 0x00D0(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSaveGame">();
	}
	static class UKuroSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSaveGame>();
	}
};
static_assert(alignof(UKuroSaveGame) == 0x000008, "Wrong alignment on UKuroSaveGame");
static_assert(sizeof(UKuroSaveGame) == 0x000120, "Wrong size on UKuroSaveGame");
static_assert(offsetof(UKuroSaveGame, IntMap) == 0x000030, "Member 'UKuroSaveGame::IntMap' has a wrong offset!");
static_assert(offsetof(UKuroSaveGame, FloatMap) == 0x000080, "Member 'UKuroSaveGame::FloatMap' has a wrong offset!");
static_assert(offsetof(UKuroSaveGame, StringMap) == 0x0000D0, "Member 'UKuroSaveGame::StringMap' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneEffectActor
// 0x0008 (0x02B8 - 0x02B0)
class AKuroSceneEffectActor final : public AKuroEffectActor
{
public:
	bool                                          bIsSceneEffectHidden;                              // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1935[0x7];                                     // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveHideSceneEffectActor();
	void OnReceiveShowSceneEffectActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneEffectActor">();
	}
	static class AKuroSceneEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSceneEffectActor>();
	}
};
static_assert(alignof(AKuroSceneEffectActor) == 0x000008, "Wrong alignment on AKuroSceneEffectActor");
static_assert(sizeof(AKuroSceneEffectActor) == 0x0002B8, "Wrong size on AKuroSceneEffectActor");
static_assert(offsetof(AKuroSceneEffectActor, bIsSceneEffectHidden) == 0x0002B0, "Member 'AKuroSceneEffectActor::bIsSceneEffectHidden' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActor
// 0x0000 (0x02A8 - 0x02A8)
class AKuroSceneInteractionActor final : public AActor
{
public:
	void OnSetState(EKuroSceneInteractionState TargetState, const bool NeedTransition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneInteractionActor">();
	}
	static class AKuroSceneInteractionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSceneInteractionActor>();
	}
};
static_assert(alignof(AKuroSceneInteractionActor) == 0x000008, "Wrong alignment on AKuroSceneInteractionActor");
static_assert(sizeof(AKuroSceneInteractionActor) == 0x0002A8, "Wrong size on AKuroSceneInteractionActor");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneInteractionInfo
// 0x0048 (0x0078 - 0x0030)
class UKuroSceneInteractionInfo final : public UObject
{
public:
	struct FVector                                Location;                                          // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandleId;                                          // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroSceneInteractionState                    CurrentState;                                      // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LoadingLevelComplete;                              // 0x005D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1936[0x2];                                     // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AKuroSceneInteractionActor*             InteractionActor;                                  // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreamingDynamic*                 LevelStreaming;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1937[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelShown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneInteractionInfo">();
	}
	static class UKuroSceneInteractionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneInteractionInfo>();
	}
};
static_assert(alignof(UKuroSceneInteractionInfo) == 0x000008, "Wrong alignment on UKuroSceneInteractionInfo");
static_assert(sizeof(UKuroSceneInteractionInfo) == 0x000078, "Wrong size on UKuroSceneInteractionInfo");
static_assert(offsetof(UKuroSceneInteractionInfo, Location) == 0x000030, "Member 'UKuroSceneInteractionInfo::Location' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, Rotation) == 0x00003C, "Member 'UKuroSceneInteractionInfo::Rotation' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, LevelName) == 0x000048, "Member 'UKuroSceneInteractionInfo::LevelName' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, HandleId) == 0x000058, "Member 'UKuroSceneInteractionInfo::HandleId' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, CurrentState) == 0x00005C, "Member 'UKuroSceneInteractionInfo::CurrentState' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, LoadingLevelComplete) == 0x00005D, "Member 'UKuroSceneInteractionInfo::LoadingLevelComplete' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, InteractionActor) == 0x000060, "Member 'UKuroSceneInteractionInfo::InteractionActor' has a wrong offset!");
static_assert(offsetof(UKuroSceneInteractionInfo, LevelStreaming) == 0x000068, "Member 'UKuroSceneInteractionInfo::LevelStreaming' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem
// 0x0060 (0x0098 - 0x0038)
class UKuroSceneInteractionActorSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_1938[0x10];                                    // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UKuroSceneInteractionInfo*> AllSceneInteractionInfos;                          // 0x0048(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	void BindActorToLevelSequenceActor(class AActor* ActorToBind, class ALevelSequenceActor* LevelSequenceActor, const class FString& BindingName);
	int32 CreateSceneInteractionLevel(const class FString& InLevelName, const EKuroSceneInteractionState InitState, const struct FVector& Location, const struct FRotator& Rotation);
	bool DestroySceneInteractionLevel(const int32 HandleId);
	EKuroSceneInteractionState GetCurrentState(const int32 HandleId);
	void SetSequenceWithTargetLevelActor(class ALevelSequenceActor* LevelSequenceActor, class ULevelSequence* InSequence, class AActor* TargetLevelActor);
	bool SwitchToState(const int32 HandleId, const EKuroSceneInteractionState TargetState, const bool NeedTransition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneInteractionActorSystem">();
	}
	static class UKuroSceneInteractionActorSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneInteractionActorSystem>();
	}
};
static_assert(alignof(UKuroSceneInteractionActorSystem) == 0x000008, "Wrong alignment on UKuroSceneInteractionActorSystem");
static_assert(sizeof(UKuroSceneInteractionActorSystem) == 0x000098, "Wrong size on UKuroSceneInteractionActorSystem");
static_assert(offsetof(UKuroSceneInteractionActorSystem, AllSceneInteractionInfos) == 0x000048, "Member 'UKuroSceneInteractionActorSystem::AllSceneInteractionInfos' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneRainEmitterConfig
// 0x0058 (0x0090 - 0x0038)
class UKuroSceneRainEmitterConfig final : public UPrimaryDataAsset
{
public:
	TArray<struct FKuroRainActorSpawnProperties>  SpawnProperties;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                CycleBoxExtent;                                    // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragSize;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindSize;                                          // 0x005C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVectorFieldStatic*                     VectorField;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorFieldPosScale;                               // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorFieldMoveSpeed;                              // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VectorFieldForceSize;                              // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenterBiasByWind;                                  // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneRainEmitterConfig">();
	}
	static class UKuroSceneRainEmitterConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSceneRainEmitterConfig>();
	}
};
static_assert(alignof(UKuroSceneRainEmitterConfig) == 0x000008, "Wrong alignment on UKuroSceneRainEmitterConfig");
static_assert(sizeof(UKuroSceneRainEmitterConfig) == 0x000090, "Wrong size on UKuroSceneRainEmitterConfig");
static_assert(offsetof(UKuroSceneRainEmitterConfig, SpawnProperties) == 0x000038, "Member 'UKuroSceneRainEmitterConfig::SpawnProperties' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, CycleBoxExtent) == 0x000048, "Member 'UKuroSceneRainEmitterConfig::CycleBoxExtent' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, DragSize) == 0x000054, "Member 'UKuroSceneRainEmitterConfig::DragSize' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, Gravity) == 0x000058, "Member 'UKuroSceneRainEmitterConfig::Gravity' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, WindSize) == 0x00005C, "Member 'UKuroSceneRainEmitterConfig::WindSize' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, VectorField) == 0x000068, "Member 'UKuroSceneRainEmitterConfig::VectorField' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, VectorFieldPosScale) == 0x000070, "Member 'UKuroSceneRainEmitterConfig::VectorFieldPosScale' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, VectorFieldMoveSpeed) == 0x00007C, "Member 'UKuroSceneRainEmitterConfig::VectorFieldMoveSpeed' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, VectorFieldForceSize) == 0x000088, "Member 'UKuroSceneRainEmitterConfig::VectorFieldForceSize' has a wrong offset!");
static_assert(offsetof(UKuroSceneRainEmitterConfig, CenterBiasByWind) == 0x00008C, "Member 'UKuroSceneRainEmitterConfig::CenterBiasByWind' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSceneRainActor
// 0x01C0 (0x0470 - 0x02B0)
class alignas(0x10) AKuroSceneRainActor final : public AKuroEffectActor
{
public:
	class UKuroSceneRainEmitterConfig*            RainConfig_Front;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroSceneRainEmitterConfig*            RainConfig_Back;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroRainComponent*                     RainComponent_Front;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKuroRainComponent*                     RainComponent_Back;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_193D[0x1A0];                                   // 0x02D0(0x01A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentRain(float InDensity, float InGravity, const struct FVector& InWindSpeed);
	void StartRain();
	void StopRain();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSceneRainActor">();
	}
	static class AKuroSceneRainActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroSceneRainActor>();
	}
};
static_assert(alignof(AKuroSceneRainActor) == 0x000010, "Wrong alignment on AKuroSceneRainActor");
static_assert(sizeof(AKuroSceneRainActor) == 0x000470, "Wrong size on AKuroSceneRainActor");
static_assert(offsetof(AKuroSceneRainActor, RainConfig_Front) == 0x0002B0, "Member 'AKuroSceneRainActor::RainConfig_Front' has a wrong offset!");
static_assert(offsetof(AKuroSceneRainActor, RainConfig_Back) == 0x0002B8, "Member 'AKuroSceneRainActor::RainConfig_Back' has a wrong offset!");
static_assert(offsetof(AKuroSceneRainActor, RainComponent_Front) == 0x0002C0, "Member 'AKuroSceneRainActor::RainComponent_Front' has a wrong offset!");
static_assert(offsetof(AKuroSceneRainActor, RainComponent_Back) == 0x0002C8, "Member 'AKuroSceneRainActor::RainComponent_Back' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroSplitTextureStreamerSettings
// 0x0020 (0x0058 - 0x0038)
class UKuroSplitTextureStreamerSettings final : public UPrimaryDataAsset
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      SplitTextureReferences;                            // 0x0038(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         SideCellNum;                                       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizePerCell;                                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartWorldPosition;                                // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroSplitTextureStreamerSettings">();
	}
	static class UKuroSplitTextureStreamerSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroSplitTextureStreamerSettings>();
	}
};
static_assert(alignof(UKuroSplitTextureStreamerSettings) == 0x000008, "Wrong alignment on UKuroSplitTextureStreamerSettings");
static_assert(sizeof(UKuroSplitTextureStreamerSettings) == 0x000058, "Wrong size on UKuroSplitTextureStreamerSettings");
static_assert(offsetof(UKuroSplitTextureStreamerSettings, SplitTextureReferences) == 0x000038, "Member 'UKuroSplitTextureStreamerSettings::SplitTextureReferences' has a wrong offset!");
static_assert(offsetof(UKuroSplitTextureStreamerSettings, SideCellNum) == 0x000048, "Member 'UKuroSplitTextureStreamerSettings::SideCellNum' has a wrong offset!");
static_assert(offsetof(UKuroSplitTextureStreamerSettings, SizePerCell) == 0x00004C, "Member 'UKuroSplitTextureStreamerSettings::SizePerCell' has a wrong offset!");
static_assert(offsetof(UKuroSplitTextureStreamerSettings, StartWorldPosition) == 0x000050, "Member 'UKuroSplitTextureStreamerSettings::StartWorldPosition' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroTrailDrawerComponent
// 0x0000 (0x0220 - 0x0220)
class UKuroTrailDrawerComponent final : public USceneComponent
{
public:
	int32                                         KuroIndex;                                         // 0x0218(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShouldTick;                                        // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnDrawerBegin();
	void OnDrawerEnd(const EEndPlayReason EndPlayReason);
	void OnDrawerTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTrailDrawerComponent">();
	}
	static class UKuroTrailDrawerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTrailDrawerComponent>();
	}
};
static_assert(alignof(UKuroTrailDrawerComponent) == 0x000010, "Wrong alignment on UKuroTrailDrawerComponent");
static_assert(sizeof(UKuroTrailDrawerComponent) == 0x000220, "Wrong size on UKuroTrailDrawerComponent");
static_assert(offsetof(UKuroTrailDrawerComponent, KuroIndex) == 0x000218, "Member 'UKuroTrailDrawerComponent::KuroIndex' has a wrong offset!");
static_assert(offsetof(UKuroTrailDrawerComponent, ShouldTick) == 0x00021C, "Member 'UKuroTrailDrawerComponent::ShouldTick' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroTrailSensorComponent
// 0x0010 (0x0230 - 0x0220)
class UKuroTrailSensorComponent final : public USceneComponent
{
public:
	float                                         TickTimeInterval;                                  // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KuroIndex;                                         // 0x021C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, DuplicateTransient, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193E[0x10];                                    // 0x0220(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSensorBegin();
	void OnSensorEnd(const EEndPlayReason EndPlayReason);
	void OnSensorTick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroTrailSensorComponent">();
	}
	static class UKuroTrailSensorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroTrailSensorComponent>();
	}
};
static_assert(alignof(UKuroTrailSensorComponent) == 0x000010, "Wrong alignment on UKuroTrailSensorComponent");
static_assert(sizeof(UKuroTrailSensorComponent) == 0x000230, "Wrong size on UKuroTrailSensorComponent");
static_assert(offsetof(UKuroTrailSensorComponent, TickTimeInterval) == 0x000218, "Member 'UKuroTrailSensorComponent::TickTimeInterval' has a wrong offset!");
static_assert(offsetof(UKuroTrailSensorComponent, KuroIndex) == 0x00021C, "Member 'UKuroTrailSensorComponent::KuroIndex' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem
// 0x00C0 (0x00F8 - 0x0038)
class UKuroUiSceneSystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_193F[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(const class FString& ScenePath)> OnKuroUiSceneLoadComplete;                         // 0x0040(0x0014)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& ScenePath)> OnKuroUiSceneUnLoadComplete;                       // 0x0054(0x0014)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& ScenePath)> OnKuroUiSceneVisibleComplete;                      // 0x0068(0x0014)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const class FString& ScenePath)> OnKuroUiSceneInVisibleComplete;                    // 0x007C(0x0014)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TMap<class FString, class UKuroUiSceneInfo*>  AllStreamingLevelInfo;                             // 0x0090(0x0050)(Edit, NativeAccessSpecifierPrivate)
	class FString                                 CurrentShowScenePath;                              // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LevelLoadingCount;                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         LastGlobalGiActorId;                               // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UKuroUiSceneSystem* GetKuroUiSceneSystem(class UWorld* InWorld);

	bool EndUiSceneRendering();
	class FString GetCurrentUiSceneRenderingSceneName();
	EKuroUiSceneLoadingState GetUiSceneLoadingState(const class FString& ScenePath);
	class AKuroUiSceneRootActor* GetUiSceneRootActor(const class FString& ScenePath);
	TMap<class FString, EKuroUiSceneLoadingState> GetUiSceneStates();
	struct FVector GetUiSceneWorldPositionOffset(const class FString& ScenePath);
	void InvokeSceneVisible(const class FString& ScenePath);
	void PreloadUiScene(const class FString& ScenePath, const struct FVector& WorldPositionOffset);
	bool StartUiSceneRendering(const class FString& ScenePath);
	bool UnloadUiScene(const class FString& ScenePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroUiSceneSystem">();
	}
	static class UKuroUiSceneSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroUiSceneSystem>();
	}
};
static_assert(alignof(UKuroUiSceneSystem) == 0x000008, "Wrong alignment on UKuroUiSceneSystem");
static_assert(sizeof(UKuroUiSceneSystem) == 0x0000F8, "Wrong size on UKuroUiSceneSystem");
static_assert(offsetof(UKuroUiSceneSystem, OnKuroUiSceneLoadComplete) == 0x000040, "Member 'UKuroUiSceneSystem::OnKuroUiSceneLoadComplete' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, OnKuroUiSceneUnLoadComplete) == 0x000054, "Member 'UKuroUiSceneSystem::OnKuroUiSceneUnLoadComplete' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, OnKuroUiSceneVisibleComplete) == 0x000068, "Member 'UKuroUiSceneSystem::OnKuroUiSceneVisibleComplete' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, OnKuroUiSceneInVisibleComplete) == 0x00007C, "Member 'UKuroUiSceneSystem::OnKuroUiSceneInVisibleComplete' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, AllStreamingLevelInfo) == 0x000090, "Member 'UKuroUiSceneSystem::AllStreamingLevelInfo' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, CurrentShowScenePath) == 0x0000E0, "Member 'UKuroUiSceneSystem::CurrentShowScenePath' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, LevelLoadingCount) == 0x0000F0, "Member 'UKuroUiSceneSystem::LevelLoadingCount' has a wrong offset!");
static_assert(offsetof(UKuroUiSceneSystem, LastGlobalGiActorId) == 0x0000F4, "Member 'UKuroUiSceneSystem::LastGlobalGiActorId' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldInfo
// 0x0070 (0x0318 - 0x02A8)
class AKuroWorldInfo final : public AInfo
{
public:
	struct FKuroLandscapeInfo                     M_LandscapeInfo;                                   // 0x02A8(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1945[0x8];                                     // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKuroStreamingLevelInfo>        M_StreamingLevelInfoList;                          // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class AKuroWorldInfo* BP_GetInstance(const class UObject* WorldContextObject, bool AutoCreate);

	int32 GetSLInfo(const class FName& PackageName, struct FKuroStreamingLevelInfo* LandscapeInfo);

	void GetLandscapeInfo(struct FKuroLandscapeInfo* LandscapeInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldInfo">();
	}
	static class AKuroWorldInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroWorldInfo>();
	}
};
static_assert(alignof(AKuroWorldInfo) == 0x000008, "Wrong alignment on AKuroWorldInfo");
static_assert(sizeof(AKuroWorldInfo) == 0x000318, "Wrong size on AKuroWorldInfo");
static_assert(offsetof(AKuroWorldInfo, M_LandscapeInfo) == 0x0002A8, "Member 'AKuroWorldInfo::M_LandscapeInfo' has a wrong offset!");
static_assert(offsetof(AKuroWorldInfo, M_StreamingLevelInfoList) == 0x000308, "Member 'AKuroWorldInfo::M_StreamingLevelInfoList' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.KuroWorldPartitionPreviewManager
// 0x0000 (0x0030 - 0x0030)
class UKuroWorldPartitionPreviewManager final : public UObject
{
public:
	void AddPreviewActorType(TSubclassOf<class AActor> Param_Class);
	void RemovePreviewActorType(TSubclassOf<class AActor> Param_Class);
	void SetPreviewMobile(bool PreviewMobile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWorldPartitionPreviewManager">();
	}
	static class UKuroWorldPartitionPreviewManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroWorldPartitionPreviewManager>();
	}
};
static_assert(alignof(UKuroWorldPartitionPreviewManager) == 0x000008, "Wrong alignment on UKuroWorldPartitionPreviewManager");
static_assert(sizeof(UKuroWorldPartitionPreviewManager) == 0x000030, "Wrong size on UKuroWorldPartitionPreviewManager");

// Class KuroRenderingRuntimeBPPlugin.KuroWuYinQuActorBase
// 0x0010 (0x02B8 - 0x02A8)
class AKuroWuYinQuActorBase final : public AActor
{
public:
	class FName                                   Key;                                               // 0x02A8(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1947[0x4];                                     // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroWuYinQuActorBase">();
	}
	static class AKuroWuYinQuActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroWuYinQuActorBase>();
	}
};
static_assert(alignof(AKuroWuYinQuActorBase) == 0x000008, "Wrong alignment on AKuroWuYinQuActorBase");
static_assert(sizeof(AKuroWuYinQuActorBase) == 0x0002B8, "Wrong size on AKuroWuYinQuActorBase");
static_assert(offsetof(AKuroWuYinQuActorBase, Key) == 0x0002A8, "Member 'AKuroWuYinQuActorBase::Key' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.LensflareSamplerActor
// 0x0048 (0x02F0 - 0x02A8)
class ALensflareSamplerActor final : public AActor
{
public:
	float                                         VisibleRadius;                                     // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OccludeRadius;                                     // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessThreshold;                               // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessThresholdRange;                          // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USunLensFlareConfig*                    Config;                                            // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentSceneSampleIndex;                           // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentDistanceFactor;                             // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        SceneComponent;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LensflareGhostComponent;                           // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LensflareGlareComponent;                           // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   LensflareHaloComponent;                            // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1948[0x8];                                     // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LensflareSamplerActor">();
	}
	static class ALensflareSamplerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALensflareSamplerActor>();
	}
};
static_assert(alignof(ALensflareSamplerActor) == 0x000008, "Wrong alignment on ALensflareSamplerActor");
static_assert(sizeof(ALensflareSamplerActor) == 0x0002F0, "Wrong size on ALensflareSamplerActor");
static_assert(offsetof(ALensflareSamplerActor, VisibleRadius) == 0x0002A8, "Member 'ALensflareSamplerActor::VisibleRadius' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, OccludeRadius) == 0x0002AC, "Member 'ALensflareSamplerActor::OccludeRadius' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, BrightnessThreshold) == 0x0002B0, "Member 'ALensflareSamplerActor::BrightnessThreshold' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, BrightnessThresholdRange) == 0x0002B4, "Member 'ALensflareSamplerActor::BrightnessThresholdRange' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, Config) == 0x0002B8, "Member 'ALensflareSamplerActor::Config' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, CurrentSceneSampleIndex) == 0x0002C0, "Member 'ALensflareSamplerActor::CurrentSceneSampleIndex' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, CurrentDistanceFactor) == 0x0002C4, "Member 'ALensflareSamplerActor::CurrentDistanceFactor' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, SceneComponent) == 0x0002C8, "Member 'ALensflareSamplerActor::SceneComponent' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, LensflareGhostComponent) == 0x0002D0, "Member 'ALensflareSamplerActor::LensflareGhostComponent' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, LensflareGlareComponent) == 0x0002D8, "Member 'ALensflareSamplerActor::LensflareGlareComponent' has a wrong offset!");
static_assert(offsetof(ALensflareSamplerActor, LensflareHaloComponent) == 0x0002E0, "Member 'ALensflareSamplerActor::LensflareHaloComponent' has a wrong offset!");

// Class KuroRenderingRuntimeBPPlugin.ThunderGenerator
// 0x0238 (0x04E0 - 0x02A8)
class AThunderGenerator final : public AActor
{
public:
	float                                         PointLightHeight;                                  // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1949[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UKuroWeatherDataAsset*                  WeatherDataAsset;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceHeightMin;                                    // 0x02B8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceHeightMax;                                    // 0x02BC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistributionFactor;                                // 0x02C0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GenerateIntervalMin;                               // 0x02C4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GenerateIntervalMax;                               // 0x02C8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GenerateChance;                                    // 0x02CC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderPlayInnerRange;                             // 0x02D0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderPlayRange;                                  // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKuroCurveFloat                        PointLightCurve;                                   // 0x02D8(0x0090)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	struct FKuroCurveFloat                        PointLightRadiusCurve;                             // 0x0368(0x0090)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	struct FKuroCurveFloat                        PostProcessCurve;                                  // 0x03F8(0x0090)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         NiagaraSystem;                                     // 0x0488(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0490(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPointLightComponent*                   PointLightComponent;                               // 0x0498(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKuroPostProcessComponent*              KuroPostProcessComponent;                          // 0x04A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AKuroGlobalGI*                          CachedGlobalGI;                                    // 0x04A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderAge;                                        // 0x04B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackAge;                                         // 0x04B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bThunderActive;                                    // 0x04B8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EKuroThunderType                              CurrentThunderType;                                // 0x04B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194A[0x2];                                     // 0x04BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThunderAttackChance;                               // 0x04BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderCloudIntensity;                             // 0x04C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThunderPostProcessIntensity;                       // 0x04C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194B[0x18];                                    // 0x04C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SpawnThunderInWorld(class UObject* WorldContextObject, const struct FVector& Location, bool bAttack);

	bool CalculateThunderPosition(const struct FTransform& CameraTransform, struct FVector* OutPosition);
	void DisableThunder();
	void EnableThunder();
	void OnReceiveThunderAttack(const struct FVector& Location, bool bAttack);
	void OnThunderTypeChanged();
	void OnUpdateThunderEffect(float DeltaSeconds);
	void SpawnThunder(const struct FVector& HitLocation, bool bAttack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThunderGenerator">();
	}
	static class AThunderGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThunderGenerator>();
	}
};
static_assert(alignof(AThunderGenerator) == 0x000008, "Wrong alignment on AThunderGenerator");
static_assert(sizeof(AThunderGenerator) == 0x0004E0, "Wrong size on AThunderGenerator");
static_assert(offsetof(AThunderGenerator, PointLightHeight) == 0x0002A8, "Member 'AThunderGenerator::PointLightHeight' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, WeatherDataAsset) == 0x0002B0, "Member 'AThunderGenerator::WeatherDataAsset' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, TraceHeightMin) == 0x0002B8, "Member 'AThunderGenerator::TraceHeightMin' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, TraceHeightMax) == 0x0002BC, "Member 'AThunderGenerator::TraceHeightMax' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, DistributionFactor) == 0x0002C0, "Member 'AThunderGenerator::DistributionFactor' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, GenerateIntervalMin) == 0x0002C4, "Member 'AThunderGenerator::GenerateIntervalMin' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, GenerateIntervalMax) == 0x0002C8, "Member 'AThunderGenerator::GenerateIntervalMax' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, GenerateChance) == 0x0002CC, "Member 'AThunderGenerator::GenerateChance' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderPlayInnerRange) == 0x0002D0, "Member 'AThunderGenerator::ThunderPlayInnerRange' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderPlayRange) == 0x0002D4, "Member 'AThunderGenerator::ThunderPlayRange' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, PointLightCurve) == 0x0002D8, "Member 'AThunderGenerator::PointLightCurve' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, PointLightRadiusCurve) == 0x000368, "Member 'AThunderGenerator::PointLightRadiusCurve' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, PostProcessCurve) == 0x0003F8, "Member 'AThunderGenerator::PostProcessCurve' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, NiagaraSystem) == 0x000488, "Member 'AThunderGenerator::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, NiagaraComponent) == 0x000490, "Member 'AThunderGenerator::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, PointLightComponent) == 0x000498, "Member 'AThunderGenerator::PointLightComponent' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, KuroPostProcessComponent) == 0x0004A0, "Member 'AThunderGenerator::KuroPostProcessComponent' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, CachedGlobalGI) == 0x0004A8, "Member 'AThunderGenerator::CachedGlobalGI' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderAge) == 0x0004B0, "Member 'AThunderGenerator::ThunderAge' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, AttackAge) == 0x0004B4, "Member 'AThunderGenerator::AttackAge' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, bThunderActive) == 0x0004B8, "Member 'AThunderGenerator::bThunderActive' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, CurrentThunderType) == 0x0004B9, "Member 'AThunderGenerator::CurrentThunderType' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderAttackChance) == 0x0004BC, "Member 'AThunderGenerator::ThunderAttackChance' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderCloudIntensity) == 0x0004C0, "Member 'AThunderGenerator::ThunderCloudIntensity' has a wrong offset!");
static_assert(offsetof(AThunderGenerator, ThunderPostProcessIntensity) == 0x0004C4, "Member 'AThunderGenerator::ThunderPostProcessIntensity' has a wrong offset!");

}

