#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroUtility

#include "Basic.hpp"

#include "KuroUtility_classes.hpp"
#include "KuroUtility_parameters.hpp"


namespace SDK
{

// Function KuroUtility.AsyncLoadState.AsyncLoadClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          UserData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncLoadState::AsyncLoadClass(const class FString& InPath, class UObject* UserData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncLoadState", "AsyncLoadClass");

	Params::AsyncLoadState_AsyncLoadClass Parms{};

	Parms.InPath = std::move(InPath);
	Parms.UserData = UserData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.AsyncLoadState.AsyncLoadObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          UserData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncLoadState::AsyncLoadObject(const class FString& InPath, class UObject* UserData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncLoadState", "AsyncLoadObject");

	Params::AsyncLoadState_AsyncLoadObject Parms{};

	Parms.InPath = std::move(InPath);
	Parms.UserData = UserData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.AddCommonAsset
// (Final, Native, Public)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHoldPreloadObject::AddCommonAsset(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "AddCommonAsset");

	Params::HoldPreloadObject_AddCommonAsset Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.AddEntityAsset
// (Final, Native, Public)
// Parameters:
// int32                                   EntityId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHoldPreloadObject::AddEntityAsset(const int32 EntityId, class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "AddEntityAsset");

	Params::HoldPreloadObject_AddEntityAsset Parms{};

	Parms.EntityId = EntityId;
	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.HoldPreloadObject.Clear
// (Final, Native, Public)

void UHoldPreloadObject::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.ClearCommonAsset
// (Final, Native, Public)

void UHoldPreloadObject::ClearCommonAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "ClearCommonAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.ClearEntityAssetMap
// (Final, Native, Public)

void UHoldPreloadObject::ClearEntityAssetMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "ClearEntityAssetMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.HoldPreloadObject.GetCommonAssetArray
// (Final, Native, Public)
// Parameters:
// TArray<class UObject*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObject*> UHoldPreloadObject::GetCommonAssetArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "GetCommonAssetArray");

	Params::HoldPreloadObject_GetCommonAssetArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.HoldPreloadObject.GetEntityAssetArray
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                                   EntityId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  OutAssets                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHoldPreloadObject::GetEntityAssetArray(const int32 EntityId, TArray<class UObject*>* OutAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "GetEntityAssetArray");

	Params::HoldPreloadObject_GetEntityAssetArray Parms{};

	Parms.EntityId = EntityId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAssets != nullptr)
		*OutAssets = std::move(Parms.OutAssets);

	return Parms.ReturnValue;
}


// Function KuroUtility.HoldPreloadObject.RemoveEntityAssets
// (Final, Native, Public)
// Parameters:
// int32                                   EntityId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHoldPreloadObject::RemoveEntityAssets(const int32 EntityId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HoldPreloadObject", "RemoveEntityAssets");

	Params::HoldPreloadObject_RemoveEntityAssets Parms{};

	Parms.EntityId = EntityId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActor.ReceiveKuroActorBack
// (Event, Protected, BlueprintEvent)

void AKuroActor::ReceiveKuroActorBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroActor", "ReceiveKuroActorBack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function KuroUtility.KuroActor.ReceiveKuroActorGet
// (Event, Protected, BlueprintEvent)

void AKuroActor::ReceiveKuroActorGet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroActor", "ReceiveKuroActorGet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function KuroUtility.KuroActorComponent.EditorTickComponent
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorComponent::EditorTickComponent(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroActorComponent", "EditorTickComponent");

	Params::KuroActorComponent_EditorTickComponent Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function KuroUtility.KuroActorManager.ClearAcquiredComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroActorManager::ClearAcquiredComponents(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ClearAcquiredComponents");

	Params::KuroActorManager_ClearAcquiredComponents Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.DestroyActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::DestroyActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "DestroyActor");

	Params::KuroActorManager_DestroyActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.GetAllAcquiredComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroActorManager::GetAllAcquiredComponents(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "GetAllAcquiredComponents");

	Params::KuroActorManager_GetAllAcquiredComponents Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.GetResourceSizeBytes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsExclusive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroActorManager::GetResourceSizeBytes(class AActor* Actor, bool IsExclusive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "GetResourceSizeBytes");

	Params::KuroActorManager_GetResourceSizeBytes Parms{};

	Parms.Actor = Actor;
	Parms.IsExclusive = IsExclusive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.InitActorManager
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroActorManager::InitActorManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "InitActorManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.IsActorPoolEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroActorManager::IsActorPoolEnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "IsActorPoolEnable");

	Params::KuroActorManager_IsActorPoolEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.IsPooledActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroActorManager::IsPooledActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "IsPooledActor");

	Params::KuroActorManager_IsPooledActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.RegisterActorSkipProperties
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UClass*                           Param_Class                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPropertyPair>            Properties                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroActorManager::RegisterActorSkipProperties(class UClass* Param_Class, const TArray<struct FPropertyPair>& Properties)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "RegisterActorSkipProperties");

	Params::KuroActorManager_RegisterActorSkipProperties Parms{};

	Parms.Param_Class = Param_Class;
	Parms.Properties = std::move(Properties);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.ResetActorToDefault
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroActorManager::ResetActorToDefault(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetActorToDefault");

	Params::KuroActorManager_ResetActorToDefault Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.ResetDelegates
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::ResetDelegates(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetDelegates");

	Params::KuroActorManager_ResetDelegates Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.ResetUberGraph
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::ResetUberGraph(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetUberGraph");

	Params::KuroActorManager_ResetUberGraph Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.ResetUObjectByCDO
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::ResetUObjectByCDO(class UObject* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "ResetUObjectByCDO");

	Params::KuroActorManager_ResetUObjectByCDO Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroActorManager.SpawnActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ESpawnActorCollisionHandlingMethod      CollisionHandlingOverride                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAsPoolActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroActorManager::SpawnActor(const class UObject* WorldContextObject, const TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, class APawn* Instigator, bool bAsPoolActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "SpawnActor");

	Params::KuroActorManager_SpawnActor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.CollisionHandlingOverride = CollisionHandlingOverride;
	Parms.Owner = Owner;
	Parms.Instigator = Instigator;
	Parms.bAsPoolActor = bAsPoolActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroActorManager.UnregisterComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  Componet                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroActorManager::UnregisterComponent(class UActorComponent* Componet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroActorManager", "UnregisterComponent");

	Params::KuroActorManager_UnregisterComponent Parms{};

	Parms.Componet = Componet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroApplicationLibrary.AddApplicationLifetimeDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 Type)>             InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroApplicationLibrary::AddApplicationLifetimeDelegate(const TDelegate<void(int32 Type)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroApplicationLibrary", "AddApplicationLifetimeDelegate");

	Params::KuroApplicationLibrary_AddApplicationLifetimeDelegate Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroApplicationLibrary.AddEditorPreEndPIEDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(bool bSimulateInEditor)> InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroApplicationLibrary::AddEditorPreEndPIEDelegate(const TDelegate<void(bool bSimulateInEditor)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroApplicationLibrary", "AddEditorPreEndPIEDelegate");

	Params::KuroApplicationLibrary_AddEditorPreEndPIEDelegate Parms{};

	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroApplicationLibrary.Test
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroApplicationLibrary::Test(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroApplicationLibrary", "Test");

	Params::KuroApplicationLibrary_Test Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroApplicationLibrary.UnBind
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroApplicationLibrary::UnBind()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroApplicationLibrary", "UnBind");

	Params::KuroApplicationLibrary_UnBind Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroCollectActorComponent.GetActorWithTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollectActorType                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroCollectActorComponent::GetActorWithTag(class FName Tag, ECollectActorType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroCollectActorComponent", "GetActorWithTag");

	Params::KuroCollectActorComponent_GetActorWithTag Parms{};

	Parms.Tag = Tag;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroCompressLibrary.CompressFileOrFolder
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DestPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float Rate)>             OnProgress                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<class FString>& SuccessedPaths)>OnCompressComplete                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFail                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int64                                   MaxSingleFileReadSize                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroCompressLibrary::CompressFileOrFolder(const class FString& Path, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, int64 MaxSingleFileReadSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroCompressLibrary", "CompressFileOrFolder");

	Params::KuroCompressLibrary_CompressFileOrFolder Parms{};

	Parms.Path = std::move(Path);
	Parms.DestPath = std::move(DestPath);
	Parms.OnProgress = OnProgress;
	Parms.OnCompressComplete = OnCompressComplete;
	Parms.OnFail = OnFail;
	Parms.MaxSingleFileReadSize = MaxSingleFileReadSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroCompressLibrary.CompressFilesOrFoldersAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Paths                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           DestPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float Rate)>             OnProgress                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<class FString>& SuccessedPaths)>OnCompressComplete                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFail                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAutoIncludeFilesUnderFolder                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   MaxSingleFileReadSize                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroCompressLibrary::CompressFilesOrFoldersAsync(const TArray<class FString>& Paths, const class FString& DestPath, const TDelegate<void(float Rate)>& OnProgress, const TDelegate<void(TArray<class FString>& SuccessedPaths)>& OnCompressComplete, const TDelegate<void()>& OnFail, bool bAutoIncludeFilesUnderFolder, int64 MaxSingleFileReadSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroCompressLibrary", "CompressFilesOrFoldersAsync");

	Params::KuroCompressLibrary_CompressFilesOrFoldersAsync Parms{};

	Parms.Paths = std::move(Paths);
	Parms.DestPath = std::move(DestPath);
	Parms.OnProgress = OnProgress;
	Parms.OnCompressComplete = OnCompressComplete;
	Parms.OnFail = OnFail;
	Parms.bAutoIncludeFilesUnderFolder = bAutoIncludeFilesUnderFolder;
	Parms.MaxSingleFileReadSize = MaxSingleFileReadSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroMathLibrary.BitwiseLeftShift
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bit                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::BitwiseLeftShift(int64 Source, int32 Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "BitwiseLeftShift");

	Params::KuroMathLibrary_BitwiseLeftShift Parms{};

	Parms.Source = Source;
	Parms.Bit = Bit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.BitwiseRightShift
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bit                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::BitwiseRightShift(int64 Source, int32 Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "BitwiseRightShift");

	Params::KuroMathLibrary_BitwiseRightShift Parms{};

	Parms.Source = Source;
	Parms.Bit = Bit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.IntBitwiseAnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMathLibrary::IntBitwiseAnd(int32 Num1, int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "IntBitwiseAnd");

	Params::KuroMathLibrary_IntBitwiseAnd Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.IntBitwiseNot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMathLibrary::IntBitwiseNot(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "IntBitwiseNot");

	Params::KuroMathLibrary_IntBitwiseNot Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.IntBitwiseOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMathLibrary::IntBitwiseOr(int32 Num1, int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "IntBitwiseOr");

	Params::KuroMathLibrary_IntBitwiseOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.IntBitwiseXOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroMathLibrary::IntBitwiseXOr(int32 Num1, int32 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "IntBitwiseXOr");

	Params::KuroMathLibrary_IntBitwiseXOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.KuroStringToInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           StringNum                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::KuroStringToInt64(const class FString& StringNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "KuroStringToInt64");

	Params::KuroMathLibrary_KuroStringToInt64 Parms{};

	Parms.StringNum = std::move(StringNum);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.LongBitwiseAnd
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::LongBitwiseAnd(int64 Num1, int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "LongBitwiseAnd");

	Params::KuroMathLibrary_LongBitwiseAnd Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.LongBitwiseNot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::LongBitwiseNot(int64 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "LongBitwiseNot");

	Params::KuroMathLibrary_LongBitwiseNot Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.LongBitwiseOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::LongBitwiseOr(int64 Num1, int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "LongBitwiseOr");

	Params::KuroMathLibrary_LongBitwiseOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.LongBitwiseXOr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Num1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   Num2                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UKuroMathLibrary::LongBitwiseXOr(int64 Num1, int64 Num2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "LongBitwiseXOr");

	Params::KuroMathLibrary_LongBitwiseXOr Parms{};

	Parms.Num1 = Num1;
	Parms.Num2 = Num2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.Max
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroMathLibrary::Max(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "Max");

	Params::KuroMathLibrary_Max Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMathLibrary.Min
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroMathLibrary::Min(const struct FVector2D& A, const struct FVector2D& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMathLibrary", "Min");

	Params::KuroMathLibrary_Min Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.HandleSkeletalMeshComponentStreaming
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartForceStreamIn                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMeshTextureFunctionLibrary::HandleSkeletalMeshComponentStreaming(class USkeletalMesh* SkeletalMesh, const bool bStartForceStreamIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "HandleSkeletalMeshComponentStreaming");

	Params::KuroMeshTextureFunctionLibrary_HandleSkeletalMeshComponentStreaming Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.bStartForceStreamIn = bStartForceStreamIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.IsSkeletalMeshComponentStreamingComplete
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::IsSkeletalMeshComponentStreamingComplete(class USkeletalMesh* SkeletalMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "IsSkeletalMeshComponentStreamingComplete");

	Params::KuroMeshTextureFunctionLibrary_IsSkeletalMeshComponentStreamingComplete Parms{};

	Parms.SkeletalMesh = SkeletalMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroMeshTextureFunctionLibrary.IsStaticMeshComponentStreamingComplete
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMeshTextureFunctionLibrary::IsStaticMeshComponentStreamingComplete(class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMeshTextureFunctionLibrary", "IsStaticMeshComponentStreamingComplete");

	Params::KuroMeshTextureFunctionLibrary_IsStaticMeshComponentStreamingComplete Parms{};

	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroPhysicsLibrary.GetHitPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              TraceComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKuroHitResult*                   HitResult                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroPhysicsLibrary::GetHitPoint(const struct FVector& StartLocation, const struct FVector& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPhysicsLibrary", "GetHitPoint");

	Params::KuroPhysicsLibrary_GetHitPoint Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.Actor = Actor;
	Parms.TraceComp = TraceComp;
	Parms.HitResult = HitResult;
	Parms.DrawDuration = DrawDuration;
	Parms.ForceTrace = ForceTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroPhysicsLibrary.GetSphereHitPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              TraceComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKuroHitResult*                   HitResult                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceTrace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroPhysicsLibrary::GetSphereHitPoint(const struct FVector& StartLocation, const struct FVector& EndLocation, class AActor* Actor, class UPrimitiveComponent* TraceComp, float Radius, class UKuroHitResult* HitResult, float DrawDuration, bool ForceTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroPhysicsLibrary", "GetSphereHitPoint");

	Params::KuroPhysicsLibrary_GetSphereHitPoint Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.Actor = Actor;
	Parms.TraceComp = TraceComp;
	Parms.Radius = Radius;
	Parms.HitResult = HitResult;
	Parms.DrawDuration = DrawDuration;
	Parms.ForceTrace = ForceTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroSilenceGameMode.GameInitialized
// (Final, Native, Public, BlueprintCallable)

void AKuroSilenceGameMode::GameInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroSilenceGameMode", "GameInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticAndroidLibrary.AddAndroidScreenChangeDelegate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Handler                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroStaticAndroidLibrary::AddAndroidScreenChangeDelegate(const TDelegate<void()>& Handler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "AddAndroidScreenChangeDelegate");

	Params::KuroStaticAndroidLibrary_AddAndroidScreenChangeDelegate Parms{};

	Parms.Handler = Handler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticAndroidLibrary.ClearAndroidScreenChangeDelegate
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroStaticAndroidLibrary::ClearAndroidScreenChangeDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "ClearAndroidScreenChangeDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticAndroidLibrary.GetDeviceIsEmulator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticAndroidLibrary::GetDeviceIsEmulator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "GetDeviceIsEmulator");

	Params::KuroStaticAndroidLibrary_GetDeviceIsEmulator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticAndroidLibrary.GetDeviceIsRooted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticAndroidLibrary::GetDeviceIsRooted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticAndroidLibrary", "GetDeviceIsRooted");

	Params::KuroStaticAndroidLibrary_GetDeviceIsRooted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticiOSLibrary.GetDeviceJailbroken
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticiOSLibrary::GetDeviceJailbroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticiOSLibrary", "GetDeviceJailbroken");

	Params::KuroStaticiOSLibrary_GetDeviceJailbroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.AddToRoot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::AddToRoot(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "AddToRoot");

	Params::KuroStaticLibrary_AddToRoot Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ApplyChangeToBlueprint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ApplyChangeToBlueprint(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ApplyChangeToBlueprint");

	Params::KuroStaticLibrary_ApplyChangeToBlueprint Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ClearPlayerInputCache
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PC                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ClearPlayerInputCache(class APlayerController** PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ClearPlayerInputCache");

	Params::KuroStaticLibrary_ClearPlayerInputCache Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PC != nullptr)
		*PC = Parms.PC;
}


// Function KuroUtility.KuroStaticLibrary.ConvertToObjectType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// ECollisionChannel                       InCollisionChannel                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectTypeQuery                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EObjectTypeQuery UKuroStaticLibrary::ConvertToObjectType(const ECollisionChannel InCollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ConvertToObjectType");

	Params::KuroStaticLibrary_ConvertToObjectType Parms{};

	Parms.InCollisionChannel = InCollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ConvertToTraceType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// ECollisionChannel                       InCollisionChannel                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETraceTypeQuery UKuroStaticLibrary::ConvertToTraceType(const ECollisionChannel InCollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ConvertToTraceType");

	Params::KuroStaticLibrary_ConvertToTraceType Parms{};

	Parms.InCollisionChannel = InCollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.CopyFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SourcePath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DstPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::CopyFile(const class FString& SourcePath, const class FString& DstPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "CopyFile");

	Params::KuroStaticLibrary_CopyFile Parms{};

	Parms.SourcePath = std::move(SourcePath);
	Parms.DstPath = std::move(DstPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.CountCurFrame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::CountCurFrame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "CountCurFrame");

	Params::KuroStaticLibrary_CountCurFrame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.CountCurMemory
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroStaticLibrary::CountCurMemory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "CountCurMemory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.DeleteFile
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequireExists                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEvenReadOnly                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bQuiet                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::DeleteFile(const class FString& Path, const bool bRequireExists, const bool bEvenReadOnly, const bool bQuiet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DeleteFile");

	Params::KuroStaticLibrary_DeleteFile Parms{};

	Parms.Path = std::move(Path);
	Parms.bRequireExists = bRequireExists;
	Parms.bEvenReadOnly = bEvenReadOnly;
	Parms.bQuiet = bQuiet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.DeleteFolder
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequireExists                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTree                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::DeleteFolder(const class FString& Path, const bool bRequireExists, const bool bTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DeleteFolder");

	Params::KuroStaticLibrary_DeleteFolder Parms{};

	Parms.Path = std::move(Path);
	Parms.bRequireExists = bRequireExists;
	Parms.bTree = bTree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.DestroyObject
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::DestroyObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DestroyObject");

	Params::KuroStaticLibrary_DestroyObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.DirectoryExists
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::DirectoryExists(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "DirectoryExists");

	Params::KuroStaticLibrary_DirectoryExists Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.EncompassesPoint
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class AVolume*                          Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::EncompassesPoint(class AVolume* Volume, const struct FVector& Point, float SphereRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "EncompassesPoint");

	Params::KuroStaticLibrary_EncompassesPoint Parms{};

	Parms.Volume = Volume;
	Parms.Point = std::move(Point);
	Parms.SphereRadius = SphereRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ExecProcess
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Params_0                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnCode                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutStd                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutErr                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::ExecProcess(const class FString& URL, const class FString& Params_0, int32* ReturnCode, class FString* OutStd, class FString* OutErr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ExecProcess");

	Params::KuroStaticLibrary_ExecProcess Parms{};

	Parms.URL = std::move(URL);
	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReturnCode != nullptr)
		*ReturnCode = Parms.ReturnCode;

	if (OutStd != nullptr)
		*OutStd = std::move(Parms.OutStd);

	if (OutErr != nullptr)
		*OutErr = std::move(Parms.OutErr);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ExecuteFunctionByName
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FunctionName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Result                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::ExecuteFunctionByName(class UObject* Object, const class FString& FunctionName, class FString* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ExecuteFunctionByName");

	Params::KuroStaticLibrary_ExecuteFunctionByName Parms{};

	Parms.Object = Object;
	Parms.FunctionName = std::move(FunctionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ExitGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ExitGame(bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ExitGame");

	Params::KuroStaticLibrary_ExitGame Parms{};

	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.FileExists
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::FileExists(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "FileExists");

	Params::KuroStaticLibrary_FileExists Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ForceGarbageCollection
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// bool                                    bFullPurge                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::ForceGarbageCollection(bool bFullPurge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ForceGarbageCollection");

	Params::KuroStaticLibrary_ForceGarbageCollection Parms{};

	Parms.bFullPurge = bFullPurge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.FromUnixTimestamp
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Timestamp                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UKuroStaticLibrary::FromUnixTimestamp(const int32 Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "FromUnixTimestamp");

	Params::KuroStaticLibrary_FromUnixTimestamp Parms{};

	Parms.Timestamp = Timestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetActorCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticLibrary::GetActorCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetActorCount");

	Params::KuroStaticLibrary_GetActorCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetAnimAssets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimBlueprint*                   InAnimBlueprint                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UAnimationAsset*>            OutAnimationAssets                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimAssets(const class UAnimBlueprint* InAnimBlueprint, TSet<class UAnimationAsset*>* OutAnimationAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimAssets");

	Params::KuroStaticLibrary_GetAnimAssets Parms{};

	Parms.InAnimBlueprint = InAnimBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimationAssets != nullptr)
		*OutAnimationAssets = std::move(Parms.OutAnimationAssets);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimAssetsByAnimBlueprintClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        InAnimClass                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UAnimationAsset*>            OutAnimationAssets                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimAssetsByAnimBlueprintClass(const TSubclassOf<class UAnimInstance>& InAnimClass, TSet<class UAnimationAsset*>* OutAnimationAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimAssetsByAnimBlueprintClass");

	Params::KuroStaticLibrary_GetAnimAssetsByAnimBlueprintClass Parms{};

	Parms.InAnimClass = InAnimClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimationAssets != nullptr)
		*OutAnimationAssets = std::move(Parms.OutAnimationAssets);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimAssetsByAnimInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    InAnimInstance                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UAnimationAsset*>            OutAnimationAssets                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimAssetsByAnimInstance(const class UAnimInstance* InAnimInstance, TSet<class UAnimationAsset*>* OutAnimationAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimAssetsByAnimInstance");

	Params::KuroStaticLibrary_GetAnimAssetsByAnimInstance Parms{};

	Parms.InAnimInstance = InAnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimationAssets != nullptr)
		*OutAnimationAssets = std::move(Parms.OutAnimationAssets);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimMontageNotifies
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         OutNotifies                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimMontageNotifies(const class UAnimMontage* AnimMontage, TArray<struct FAnimNotifyEvent>* OutNotifies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimMontageNotifies");

	Params::KuroStaticLibrary_GetAnimMontageNotifies Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNotifies != nullptr)
		*OutNotifies = std::move(Parms.OutNotifies);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimSequenceNotifies
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimSequence                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         OutNotifies                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimSequenceNotifies(const class UAnimSequenceBase* AnimSequence, TArray<struct FAnimNotifyEvent>* OutNotifies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimSequenceNotifies");

	Params::KuroStaticLibrary_GetAnimSequenceNotifies Parms{};

	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNotifies != nullptr)
		*OutNotifies = std::move(Parms.OutNotifies);
}


// Function KuroUtility.KuroStaticLibrary.GetAnimSequencesByAnimMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UAnimSequenceBase*>        OutAnimSequences                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetAnimSequencesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class UAnimSequenceBase*>* OutAnimSequences)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAnimSequencesByAnimMontage");

	Params::KuroStaticLibrary_GetAnimSequencesByAnimMontage Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimSequences != nullptr)
		*OutAnimSequences = std::move(Parms.OutAnimSequences);
}


// Function KuroUtility.KuroStaticLibrary.GetAvailablePhysicalGB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetAvailablePhysicalGB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAvailablePhysicalGB");

	Params::KuroStaticLibrary_GetAvailablePhysicalGB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetAvailableVirtualGB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetAvailableVirtualGB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetAvailableVirtualGB");

	Params::KuroStaticLibrary_GetAvailableVirtualGB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetBatteryLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticLibrary::GetBatteryLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetBatteryLevel");

	Params::KuroStaticLibrary_GetBatteryLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetBlueprintCallstack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetBlueprintCallstack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetBlueprintCallstack");

	Params::KuroStaticLibrary_GetBlueprintCallstack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetCameraShakeInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCameraShakeBase>     CameraShakeClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCameraShakeInfo                 OutInfo                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::GetCameraShakeInfo(TSubclassOf<class UCameraShakeBase> CameraShakeClass, struct FCameraShakeInfo* OutInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCameraShakeInfo");

	Params::KuroStaticLibrary_GetCameraShakeInfo Parms{};

	Parms.CameraShakeClass = CameraShakeClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInfo != nullptr)
		*OutInfo = std::move(Parms.OutInfo);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetCharacterAnimClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               InActorClass                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimInstance>        OutAnimClass                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetCharacterAnimClass(const TSubclassOf<class AActor>& InActorClass, TSubclassOf<class UAnimInstance>* OutAnimClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCharacterAnimClass");

	Params::KuroStaticLibrary_GetCharacterAnimClass Parms{};

	Parms.InActorClass = InActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAnimClass != nullptr)
		*OutAnimClass = Parms.OutAnimClass;
}


// Function KuroUtility.KuroStaticLibrary.GetCreatureGenDirectoryByMap
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MapID                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Exist                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Directory                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetCreatureGenDirectoryByMap(const class FString& Path, const int32 MapID, bool* Exist, class FString* Directory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCreatureGenDirectoryByMap");

	Params::KuroStaticLibrary_GetCreatureGenDirectoryByMap Parms{};

	Parms.Path = std::move(Path);
	Parms.MapID = MapID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Exist != nullptr)
		*Exist = Parms.Exist;

	if (Directory != nullptr)
		*Directory = std::move(Parms.Directory);
}


// Function KuroUtility.KuroStaticLibrary.GetCultureRegion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetCultureRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCultureRegion");

	Params::KuroStaticLibrary_GetCultureRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetCurCPUFrequency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetCurCPUFrequency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetCurCPUFrequency");

	Params::KuroStaticLibrary_GetCurCPUFrequency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetDefaultObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Param_Class                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKuroStaticLibrary::GetDefaultObject(class UClass* Param_Class)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetDefaultObject");

	Params::KuroStaticLibrary_GetDefaultObject Parms{};

	Parms.Param_Class = Param_Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetDeviceCPU
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetDeviceCPU()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetDeviceCPU");

	Params::KuroStaticLibrary_GetDeviceCPU Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetDirectories
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::GetDirectories(const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetDirectories");

	Params::KuroStaticLibrary_GetDirectories Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetFiles
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Extension                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::GetFiles(const class FString& Path, const class FString& Extension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetFiles");

	Params::KuroStaticLibrary_GetFiles Parms{};

	Parms.Path = std::move(Path);
	Parms.Extension = std::move(Extension);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetFilesRecursive
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Files                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Directories                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::GetFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetFilesRecursive");

	Params::KuroStaticLibrary_GetFilesRecursive Parms{};

	Parms.Path = std::move(Path);
	Parms.Filter = std::move(Filter);
	Parms.Files = Files;
	Parms.Directories = Directories;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetFirstLocationFromSeqTrack
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovieScene3DTransformTrack*      TransformTrack                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKuroStaticLibrary::GetFirstLocationFromSeqTrack(class UMovieScene3DTransformTrack* TransformTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetFirstLocationFromSeqTrack");

	Params::KuroStaticLibrary_GetFirstLocationFromSeqTrack Parms{};

	Parms.TransformTrack = TransformTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetFrameInfo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKuroStaticLibrary::GetFrameInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetFrameInfo");

	Params::KuroStaticLibrary_GetFrameInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetGPUFrameTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetGPUFrameTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetGPUFrameTime");

	Params::KuroStaticLibrary_GetGPUFrameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetGPUInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetGPUInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetGPUInfo");

	Params::KuroStaticLibrary_GetGPUInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetLevelPath
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetLevelPath(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetLevelPath");

	Params::KuroStaticLibrary_GetLevelPath Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetLevelPrefabShowActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroStaticLibrary::GetLevelPrefabShowActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetLevelPrefabShowActor");

	Params::KuroStaticLibrary_GetLevelPrefabShowActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetLLMInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetLLMInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetLLMInfo");

	Params::KuroStaticLibrary_GetLLMInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetLocalHostAddresses
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   OutAddresses                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendPort                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetLocalHostAddresses(TArray<class FString>* OutAddresses, const bool bAppendPort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetLocalHostAddresses");

	Params::KuroStaticLibrary_GetLocalHostAddresses Parms{};

	Parms.bAppendPort = bAppendPort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAddresses != nullptr)
		*OutAddresses = std::move(Parms.OutAddresses);
}


// Function KuroUtility.KuroStaticLibrary.GetNavPointData
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   YNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Dis                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          QueryExtent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>FilterClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UKuroStaticLibrary::GetNavPointData(class UObject* WorldContextObject, int32 XNumber, int32 YNumber, int32 Dis, class ANavigationData* NavData, const struct FVector& Point, const struct FVector& QueryExtent, TSubclassOf<class UNavigationQueryFilter> FilterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetNavPointData");

	Params::KuroStaticLibrary_GetNavPointData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.XNumber = XNumber;
	Parms.YNumber = YNumber;
	Parms.Dis = Dis;
	Parms.NavData = NavData;
	Parms.Point = std::move(Point);
	Parms.QueryExtent = std::move(QueryExtent);
	Parms.FilterClass = FilterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetPeakUsedPhysicalGB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetPeakUsedPhysicalGB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetPeakUsedPhysicalGB");

	Params::KuroStaticLibrary_GetPeakUsedPhysicalGB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetPeakUsedVirtualGB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetPeakUsedVirtualGB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetPeakUsedVirtualGB");

	Params::KuroStaticLibrary_GetPeakUsedVirtualGB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetPIEStartTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetPIEStartTimeInSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetPIEStartTimeInSeconds");

	Params::KuroStaticLibrary_GetPIEStartTimeInSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetPlatformTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetPlatformTimeInSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetPlatformTimeInSeconds");

	Params::KuroStaticLibrary_GetPlatformTimeInSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetRawFrameTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetRawFrameTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetRawFrameTime");

	Params::KuroStaticLibrary_GetRawFrameTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetRawGameThreadTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetRawGameThreadTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetRawGameThreadTime");

	Params::KuroStaticLibrary_GetRawGameThreadTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetRawRenderThreadTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetRawRenderThreadTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetRawRenderThreadTime");

	Params::KuroStaticLibrary_GetRawRenderThreadTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetRawRHITTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetRawRHITTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetRawRHITTime");

	Params::KuroStaticLibrary_GetRawRHITTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetSequenceTracksForObjectBindingID
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroStaticLibrary::GetSequenceTracksForObjectBindingID(const class ALevelSequenceActor* Actor, class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetSequenceTracksForObjectBindingID");

	Params::KuroStaticLibrary_GetSequenceTracksForObjectBindingID Parms{};

	Parms.Actor = Actor;
	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetSlotNamesByAnimMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutSlotNames                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::GetSlotNamesByAnimMontage(const class UAnimMontage* AnimMontage, TArray<class FName>* OutSlotNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetSlotNamesByAnimMontage");

	Params::KuroStaticLibrary_GetSlotNamesByAnimMontage Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSlotNames != nullptr)
		*OutSlotNames = std::move(Parms.OutSlotNames);
}


// Function KuroUtility.KuroStaticLibrary.GetSplineRotationAtSplinePoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKuroStaticLibrary::GetSplineRotationAtSplinePoint(class USplineComponent* Spline, int32 PointIndex, ESplineCoordinateSpace CoordinateSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetSplineRotationAtSplinePoint");

	Params::KuroStaticLibrary_GetSplineRotationAtSplinePoint Parms{};

	Parms.Spline = Spline;
	Parms.PointIndex = PointIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetStatUnitInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::GetStatUnitInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetStatUnitInfo");

	Params::KuroStaticLibrary_GetStatUnitInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetTotalMemoryGB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticLibrary::GetTotalMemoryGB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetTotalMemoryGB");

	Params::KuroStaticLibrary_GetTotalMemoryGB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetTrackByClass
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// TArray<class UMovieSceneTrack*>         Tracks                                                 (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UMovieSceneTrack>     Param_Class                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMovieSceneTrack*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMovieSceneTrack* UKuroStaticLibrary::GetTrackByClass(const TArray<class UMovieSceneTrack*>& Tracks, TSubclassOf<class UMovieSceneTrack> Param_Class)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetTrackByClass");

	Params::KuroStaticLibrary_GetTrackByClass Parms{};

	Parms.Tracks = std::move(Tracks);
	Parms.Param_Class = Param_Class;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetUsedMemoryGB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetUsedMemoryGB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetUsedMemoryGB");

	Params::KuroStaticLibrary_GetUsedMemoryGB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetUsedPhysicalGB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetUsedPhysicalGB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetUsedPhysicalGB");

	Params::KuroStaticLibrary_GetUsedPhysicalGB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetUsedVirtualGB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetUsedVirtualGB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetUsedVirtualGB");

	Params::KuroStaticLibrary_GetUsedVirtualGB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.GetUseMemoryProportion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroStaticLibrary::GetUseMemoryProportion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "GetUseMemoryProportion");

	Params::KuroStaticLibrary_GetUseMemoryProportion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.HashStringWithSHA1
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::HashStringWithSHA1(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "HashStringWithSHA1");

	Params::KuroStaticLibrary_HashStringWithSHA1 Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IcmpPing
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           IpAddress                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& Address, float Time, int32 ResponseState)>InDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::IcmpPing(const class FString& IpAddress, float Timeout, const TDelegate<void(const class FString& Address, float Time, int32 ResponseState)>& InDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IcmpPing");

	Params::KuroStaticLibrary_IcmpPing Parms{};

	Parms.IpAddress = std::move(IpAddress);
	Parms.Timeout = Timeout;
	Parms.InDelegate = InDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.IsAsyncLoadingThreadEnabled
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsAsyncLoadingThreadEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsAsyncLoadingThreadEnabled");

	Params::KuroStaticLibrary_IsAsyncLoadingThreadEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsBuildShipping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsBuildShipping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsBuildShipping");

	Params::KuroStaticLibrary_IsBuildShipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsBuildTest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsBuildTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsBuildTest");

	Params::KuroStaticLibrary_IsBuildTest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsEditor
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsEditor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsEditor");

	Params::KuroStaticLibrary_IsEditor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsImplementInterface
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UClass*                           InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           InInterfaceClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsImplementInterface(class UClass* InClass, class UClass* InInterfaceClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsImplementInterface");

	Params::KuroStaticLibrary_IsImplementInterface Parms{};

	Parms.InClass = InClass;
	Parms.InInterfaceClass = InInterfaceClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsModuleLoaded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ModelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsModuleLoaded(const class FString& ModelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsModuleLoaded");

	Params::KuroStaticLibrary_IsModuleLoaded Parms{};

	Parms.ModelName = std::move(ModelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsObjectClassByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ClassName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsObjectClassByName(class UObject* Object, class FName ClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsObjectClassByName");

	Params::KuroStaticLibrary_IsObjectClassByName Parms{};

	Parms.Object = Object;
	Parms.ClassName = ClassName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.IsWorldTearingDown
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::IsWorldTearingDown(const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "IsWorldTearingDown");

	Params::KuroStaticLibrary_IsWorldTearingDown Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.KuroFormatText
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Format                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Parameters                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroStaticLibrary::KuroFormatText(const class FString& Format, const TArray<class FString>& Parameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "KuroFormatText");

	Params::KuroStaticLibrary_KuroFormatText Parms{};

	Parms.Format = std::move(Format);
	Parms.Parameters = std::move(Parameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.LoadFilesRecursive
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filter                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Files                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Directories                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::LoadFilesRecursive(const class FString& Path, const class FString& Filter, bool Files, bool Directories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "LoadFilesRecursive");

	Params::KuroStaticLibrary_LoadFilesRecursive Parms{};

	Parms.Path = std::move(Path);
	Parms.Filter = std::move(Filter);
	Parms.Files = Files;
	Parms.Directories = Directories;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.LoadFileToString
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Result                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::LoadFileToString(class FString* Result, const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "LoadFileToString");

	Params::KuroStaticLibrary_LoadFileToString Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.LoadFileToStringArray
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           FileRevisionPath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UKuroStaticLibrary::LoadFileToStringArray(const class FString& FileRevisionPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "LoadFileToStringArray");

	Params::KuroStaticLibrary_LoadFileToStringArray Parms{};

	Parms.FileRevisionPath = std::move(FileRevisionPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.MakeDirectory
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTree                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::MakeDirectory(const class FString& Path, const bool bTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "MakeDirectory");

	Params::KuroStaticLibrary_MakeDirectory Parms{};

	Parms.Path = std::move(Path);
	Parms.bTree = bTree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.PerceptionConfigureSense
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAIPerceptionComponent*           AIPerception                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAISenseConfig*                   AISenseConfig                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::PerceptionConfigureSense(class UAIPerceptionComponent* AIPerception, class UAISenseConfig* AISenseConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "PerceptionConfigureSense");

	Params::KuroStaticLibrary_PerceptionConfigureSense Parms{};

	Parms.AIPerception = AIPerception;
	Parms.AISenseConfig = AISenseConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.RegisterCustomCommandProcessor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& Command)>Processor                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::RegisterCustomCommandProcessor(const class FString& Category, const TDelegate<void(const class FString& Command)>& Processor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "RegisterCustomCommandProcessor");

	Params::KuroStaticLibrary_RegisterCustomCommandProcessor Parms{};

	Parms.Category = std::move(Category);
	Parms.Processor = Processor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.RemoveFromRoot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::RemoveFromRoot(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "RemoveFromRoot");

	Params::KuroStaticLibrary_RemoveFromRoot Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SaveStringToFile
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           SaveText                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FileName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWithBom                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::SaveStringToFile(const class FString& SaveText, const class FString& FileName, const bool bWithBom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SaveStringToFile");

	Params::KuroStaticLibrary_SaveStringToFile Parms{};

	Parms.SaveText = std::move(SaveText);
	Parms.FileName = std::move(FileName);
	Parms.bWithBom = bWithBom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.SetActorModify
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetActorModify(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetActorModify");

	Params::KuroStaticLibrary_SetActorModify Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetActorPermanent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPermanent                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWithAllChildren                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetActorPermanent(class AActor* Actor, const bool bIsPermanent, const bool bWithAllChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetActorPermanent");

	Params::KuroStaticLibrary_SetActorPermanent Parms{};

	Parms.Actor = Actor;
	Parms.bIsPermanent = bIsPermanent;
	Parms.bWithAllChildren = bWithAllChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetBaseAndSaveBaseLocation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCharacterMovementComponent*      CharacterMovementComp                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              NewBase                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetBaseAndSaveBaseLocation(class UCharacterMovementComponent* CharacterMovementComp, class UPrimitiveComponent* NewBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetBaseAndSaveBaseLocation");

	Params::KuroStaticLibrary_SetBaseAndSaveBaseLocation Parms{};

	Parms.CharacterMovementComp = CharacterMovementComp;
	Parms.NewBase = NewBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetEditorWidgetSkipTick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipTick                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetEditorWidgetSkipTick(bool bSkipTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetEditorWidgetSkipTick");

	Params::KuroStaticLibrary_SetEditorWidgetSkipTick Parms{};

	Parms.bSkipTick = bSkipTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetGameThreadAffinity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInFighting                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetGameThreadAffinity(bool bIsInFighting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetGameThreadAffinity");

	Params::KuroStaticLibrary_SetGameThreadAffinity Parms{};

	Parms.bIsInFighting = bIsInFighting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetMontageANIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetMontageANIndex(const class UAnimMontage* AnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetMontageANIndex");

	Params::KuroStaticLibrary_SetMontageANIndex Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetSplinePointsWithType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplinePointType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetSplinePointsWithType(class USplineComponent* Spline, const TArray<struct FVector>& Points, ESplineCoordinateSpace CoordinateSpace, ESplinePointType Type, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetSplinePointsWithType");

	Params::KuroStaticLibrary_SetSplinePointsWithType Parms{};

	Parms.Spline = Spline;
	Parms.Points = std::move(Points);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.Type = Type;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SetStaticMeshVelocity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          NewVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::SetStaticMeshVelocity(const TArray<class AActor*>& Actors, const struct FVector& NewVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SetStaticMeshVelocity");

	Params::KuroStaticLibrary_SetStaticMeshVelocity Parms{};

	Parms.Actors = std::move(Actors);
	Parms.NewVelocity = std::move(NewVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.SpawnActorFromAnother
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Parent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroStaticLibrary::SpawnActorFromAnother(class AActor* Actor, class AActor* Parent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "SpawnActorFromAnother");

	Params::KuroStaticLibrary_SpawnActorFromAnother Parms{};

	Parms.Actor = Actor;
	Parms.Parent = Parent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.StopAllMontagesBySlotName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    UAnimInstance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSlotName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlendOutTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::StopAllMontagesBySlotName(class UAnimInstance* UAnimInstance, const class FName InSlotName, const float InBlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "StopAllMontagesBySlotName");

	Params::KuroStaticLibrary_StopAllMontagesBySlotName Parms{};

	Parms.UAnimInstance = UAnimInstance;
	Parms.InSlotName = InSlotName;
	Parms.InBlendOutTime = InBlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroStaticLibrary.ToggleSequenceNodeActiveByTag
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ALevelSequenceActor*              Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroStaticLibrary::ToggleSequenceNodeActiveByTag(const class ALevelSequenceActor* Actor, class FName TagName, bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ToggleSequenceNodeActiveByTag");

	Params::KuroStaticLibrary_ToggleSequenceNodeActiveByTag Parms{};

	Parms.Actor = Actor;
	Parms.TagName = TagName;
	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.ToUnixTimestamp
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        InDataTime                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroStaticLibrary::ToUnixTimestamp(const struct FDateTime& InDataTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "ToUnixTimestamp");

	Params::KuroStaticLibrary_ToUnixTimestamp Parms{};

	Parms.InDataTime = std::move(InDataTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroStaticLibrary.UnRegisterCustomCommandProcessor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroStaticLibrary::UnRegisterCustomCommandProcessor(const class FString& Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticLibrary", "UnRegisterCustomCommandProcessor");

	Params::KuroStaticLibrary_UnRegisterCustomCommandProcessor Parms{};

	Parms.Category = std::move(Category);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.ClearAllProgressCallback
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroTencentCOSLibrary::ClearAllProgressCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "ClearAllProgressCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.EnableAuthorization
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::EnableAuthorization(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "EnableAuthorization");

	Params::KuroTencentCOSLibrary_EnableAuthorization Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.EnableAutoSendWhenExit
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroTencentCOSLibrary::EnableAutoSendWhenExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "EnableAutoSendWhenExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.GetAllFileNumNeedToSend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroTencentCOSLibrary::GetAllFileNumNeedToSend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "GetAllFileNumNeedToSend");

	Params::KuroTencentCOSLibrary_GetAllFileNumNeedToSend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTencentCOSLibrary.GetSendedFileNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroTencentCOSLibrary::GetSendedFileNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "GetSendedFileNum");

	Params::KuroTencentCOSLibrary_GetSendedFileNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTencentCOSLibrary.InterruptSending
// (Final, Native, Static, Public, BlueprintCallable)

void UKuroTencentCOSLibrary::InterruptSending()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "InterruptSending");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.IsSending
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTencentCOSLibrary::IsSending()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "IsSending");

	Params::KuroTencentCOSLibrary_IsSending Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTencentCOSLibrary.SendFileToTencentCOS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RemoteURI                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SecretID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SecretKey                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           BucketName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SendFileToTencentCOS(const class FString& Path, const class FString& RemoteURI, const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SendFileToTencentCOS");

	Params::KuroTencentCOSLibrary_SendFileToTencentCOS Parms{};

	Parms.Path = std::move(Path);
	Parms.RemoteURI = std::move(RemoteURI);
	Parms.SecretID = std::move(SecretID);
	Parms.SecretKey = std::move(SecretKey);
	Parms.BucketName = std::move(BucketName);
	Parms.Region = std::move(Region);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SendLogToTencentCOS
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 State, float Rate)>OnProgress                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SendLogToTencentCOS(const TDelegate<void(int32 State, float Rate)>& OnProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SendLogToTencentCOS");

	Params::KuroTencentCOSLibrary_SendLogToTencentCOS Parms{};

	Parms.OnProgress = OnProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetAdmissibleValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   SingleLogSizeInMb                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetAdmissibleValue(int32 SingleLogSizeInMb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetAdmissibleValue");

	Params::KuroTencentCOSLibrary_SetAdmissibleValue Parms{};

	Parms.SingleLogSizeInMb = SingleLogSizeInMb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetFilesToSend
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   FilePaths                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetFilesToSend(const TArray<class FString>& FilePaths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetFilesToSend");

	Params::KuroTencentCOSLibrary_SetFilesToSend Parms{};

	Parms.FilePaths = std::move(FilePaths);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetHandleFunc
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(TArray<class FString>& FileNames)>PrepareFunc                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<class FString>& SendedFiles)>PostSend                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetHandleFunc(const TDelegate<void(TArray<class FString>& FileNames)>& PrepareFunc, const TDelegate<void(TArray<class FString>& SendedFiles)>& PostSend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetHandleFunc");

	Params::KuroTencentCOSLibrary_SetHandleFunc Parms{};

	Parms.PrepareFunc = PrepareFunc;
	Parms.PostSend = PostSend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetIsAutoSend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsAutoSend                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetIsAutoSend(bool bIsAutoSend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetIsAutoSend");

	Params::KuroTencentCOSLibrary_SetIsAutoSend Parms{};

	Parms.bIsAutoSend = bIsAutoSend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetSendLogConfig
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SecretID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SecretKey                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           BucketName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetSendLogConfig(const class FString& SecretID, const class FString& SecretKey, const class FString& BucketName, const class FString& Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetSendLogConfig");

	Params::KuroTencentCOSLibrary_SetSendLogConfig Parms{};

	Parms.SecretID = std::move(SecretID);
	Parms.SecretKey = std::move(SecretKey);
	Parms.BucketName = std::move(BucketName);
	Parms.Region = std::move(Region);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTencentCOSLibrary.SetSendLogZipName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ZipFileName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTencentCOSLibrary::SetSendLogZipName(const class FString& ZipFileName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroTencentCOSLibrary", "SetSendLogZipName");

	Params::KuroTencentCOSLibrary_SetSendLogZipName Parms{};

	Parms.ZipFileName = std::move(ZipFileName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickableManager.CreateTickableFunc
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float DeltaSeconds)>     TickableHandler                                        (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UKuroTickableManager::CreateTickableFunc(class UObject* InOwner, TDelegate<void(float DeltaSeconds)> TickableHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickableManager", "CreateTickableFunc");

	Params::KuroTickableManager_CreateTickableFunc Parms{};

	Parms.InOwner = InOwner;
	Parms.TickableHandler = TickableHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickableManager.RemoveTickableFunc
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickableManager::RemoveTickableFunc(class UObject* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickableManager", "RemoveTickableFunc");

	Params::KuroTickableManager_RemoveTickableFunc Parms{};

	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTriggerVolumeManager.GetKuroTriggerVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActorKey                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UKuroTriggerVolumeManager::GetKuroTriggerVolume(class FName ActorKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTriggerVolumeManager", "GetKuroTriggerVolume");

	Params::KuroTriggerVolumeManager_GetKuroTriggerVolume Parms{};

	Parms.ActorKey = ActorKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.LoadMapNotify.BindBeginLoadMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& MapName)>BeginLoadMapHandler                                    (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindBeginLoadMap(TDelegate<void(const class FString& MapName)> BeginLoadMapHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindBeginLoadMap");

	Params::LoadMapNotify_BindBeginLoadMap Parms{};

	Parms.BeginLoadMapHandler = BeginLoadMapHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindBeginTravelLoadMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& MapName)>BeginTravelLoadMapHandler                              (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindBeginTravelLoadMap(TDelegate<void(const class FString& MapName)> BeginTravelLoadMapHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindBeginTravelLoadMap");

	Params::LoadMapNotify_BindBeginTravelLoadMap Parms{};

	Parms.BeginTravelLoadMapHandler = BeginTravelLoadMapHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindEndLoadMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& MapName)>EndLoadMapHandler                                      (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindEndLoadMap(TDelegate<void(const class FString& MapName)> EndLoadMapHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindEndLoadMap");

	Params::LoadMapNotify_BindEndLoadMap Parms{};

	Parms.EndLoadMapHandler = EndLoadMapHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindEndLoadTransitionMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       EndLoadTransitionMapHandler                            (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindEndLoadTransitionMap(TDelegate<void()> EndLoadTransitionMapHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindEndLoadTransitionMap");

	Params::LoadMapNotify_BindEndLoadTransitionMap Parms{};

	Parms.EndLoadTransitionMapHandler = EndLoadTransitionMapHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindLoadStreamLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 LinkId, class FName& LevelName, class ULevelStreaming* StreamingLevel)>LoadStreamLevelHandler                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindLoadStreamLevel(const TDelegate<void(int32 LinkId, class FName& LevelName, class ULevelStreaming* StreamingLevel)> LoadStreamLevelHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindLoadStreamLevel");

	Params::LoadMapNotify_BindLoadStreamLevel Parms{};

	Parms.LoadStreamLevelHandler = LoadStreamLevelHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.BindUnLoadStreamLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(int32 LinkId, class FName& LevelName)>UnLoadStreamLevelHandler                               (ConstParm, Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ULoadMapNotify::BindUnLoadStreamLevel(const TDelegate<void(int32 LinkId, class FName& LevelName)> UnLoadStreamLevelHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "BindUnLoadStreamLevel");

	Params::LoadMapNotify_BindUnLoadStreamLevel Parms{};

	Parms.UnLoadStreamLevelHandler = UnLoadStreamLevelHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.Clear
// (Final, Native, Public, BlueprintCallable)

void ULoadMapNotify::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.LoadStreamLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Path                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMakeVisibleAfterLoad                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBlockOnLoad                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULoadMapNotify::LoadStreamLevel(const class FName& Path, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "LoadStreamLevel");

	Params::LoadMapNotify_LoadStreamLevel Parms{};

	Parms.Path = Path;
	Parms.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	Parms.bShouldBlockOnLoad = bShouldBlockOnLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.LoadMapNotify.OnLoadStreamLevel
// (Final, Native, Private)
// Parameters:
// int32                                   LinkID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadMapNotify::OnLoadStreamLevel(const int32 LinkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "OnLoadStreamLevel");

	Params::LoadMapNotify_OnLoadStreamLevel Parms{};

	Parms.LinkID = LinkID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.OnUnLoadStreamLevel
// (Final, Native, Private)
// Parameters:
// int32                                   LinkID                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadMapNotify::OnUnLoadStreamLevel(const int32 LinkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "OnUnLoadStreamLevel");

	Params::LoadMapNotify_OnUnLoadStreamLevel Parms{};

	Parms.LinkID = LinkID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.LoadMapNotify.UnloadStreamLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             Path                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBlockOnLoad                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULoadMapNotify::UnloadStreamLevel(const class FName& Path, bool bShouldBlockOnLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMapNotify", "UnloadStreamLevel");

	Params::LoadMapNotify_UnloadStreamLevel Parms{};

	Parms.Path = Path;
	Parms.bShouldBlockOnLoad = bShouldBlockOnLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTickManager.AddPrerequisiteActorComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ActorComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::AddPrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "AddPrerequisiteActorComponent");

	Params::KuroTickManager_AddPrerequisiteActorComponent Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.ActorComp = ActorComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.AddTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float DeltaSeconds)>     TickHandler                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTickManager::AddTick(const ETickingGroup TickingGroup, const TDelegate<void(float DeltaSeconds)> TickHandler)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "AddTick");

	Params::KuroTickManager_AddTick Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.TickHandler = TickHandler;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTickManager.CleanSkeletalMeshProxyTickFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkelComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::CleanSkeletalMeshProxyTickFunction(class USkeletalMeshComponent* SkelComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "CleanSkeletalMeshProxyTickFunction");

	Params::KuroTickManager_CleanSkeletalMeshProxyTickFunction Parms{};

	Parms.SkelComp = SkelComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.ClearTick
// (Final, Native, Public, BlueprintCallable)

void UKuroTickManager::ClearTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "ClearTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.RemovePrerequisiteActorComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ActorComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::RemovePrerequisiteActorComponent(const ETickingGroup TickingGroup, class UActorComponent* ActorComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "RemovePrerequisiteActorComponent");

	Params::KuroTickManager_RemovePrerequisiteActorComponent Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.ActorComp = ActorComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroUtility.KuroTickManager.RemoveTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroTickManager::RemoveTick(const ETickingGroup TickingGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "RemoveTick");

	Params::KuroTickManager_RemoveTick Parms{};

	Parms.TickingGroup = TickingGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroUtility.KuroTickManager.SetSkeletalMeshProxyTickFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETickingGroup                           TickingGroup                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           SkelComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroTickManager::SetSkeletalMeshProxyTickFunction(const ETickingGroup TickingGroup, class USkeletalMeshComponent* SkelComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroTickManager", "SetSkeletalMeshProxyTickFunction");

	Params::KuroTickManager_SetSkeletalMeshProxyTickFunction Parms{};

	Parms.TickingGroup = TickingGroup;
	Parms.SkelComp = SkelComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

