#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroNetwork

#include "Basic.hpp"

#include "KuroNetwork_classes.hpp"
#include "KuroNetwork_parameters.hpp"


namespace SDK
{

// Function KuroNetwork.KuroHttp.CompressAndPostDataAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, class FString>      HeaderParam                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ECompressMethod                         CompressMethod                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArrayBuffer                     Buffer                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(bool Successed)>         PostHandle                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::CompressAndPostDataAsync(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, ECompressMethod CompressMethod, const struct FArrayBuffer& Buffer, TDelegate<void(bool Successed)> PostHandle, float InTimeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "CompressAndPostDataAsync");

	Params::KuroHttp_CompressAndPostDataAsync Parms{};

	Parms.URL = std::move(URL);
	Parms.HeaderParam = std::move(HeaderParam);
	Parms.CompressMethod = CompressMethod;
	Parms.Buffer = std::move(Buffer);
	Parms.PostHandle = PostHandle;
	Parms.InTimeout = InTimeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.CompressDataAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FArrayBuffer                     InBuffer                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ECompressMethod                         CompressMethod                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<uint8>& Data, int32 SizeNeededForDecompress)>OnCompressed                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroHttp::CompressDataAsync(const struct FArrayBuffer& InBuffer, ECompressMethod CompressMethod, const TDelegate<void(TArray<uint8>& Data, int32 SizeNeededForDecompress)>& OnCompressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "CompressDataAsync");

	Params::KuroHttp_CompressDataAsync Parms{};

	Parms.InBuffer = std::move(InBuffer);
	Parms.CompressMethod = CompressMethod;
	Parms.OnCompressed = OnCompressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.CompressStringAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECompressMethod                         CompressMethod                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(TArray<uint8>& Data, int32 SizeNeededForDecompress)>OnCompressed                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroHttp::CompressStringAsync(const class FString& InString, ECompressMethod CompressMethod, const TDelegate<void(TArray<uint8>& Data, int32 SizeNeededForDecompress)>& OnCompressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "CompressStringAsync");

	Params::KuroHttp_CompressStringAsync Parms{};

	Parms.InString = std::move(InString);
	Parms.CompressMethod = CompressMethod;
	Parms.OnCompressed = OnCompressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.Get
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, class FString>      HeaderParam                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success, int32 Code, const class FString& Data)>Handle                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::Get(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handle, float InTimeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "Get");

	Params::KuroHttp_Get Parms{};

	Parms.URL = std::move(URL);
	Parms.HeaderParam = std::move(HeaderParam);
	Parms.Handle = Handle;
	Parms.InTimeout = InTimeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.GetDefaultHeader
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<class FString, class FString>      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, class FString> UKuroHttp::GetDefaultHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "GetDefaultHeader");

	Params::KuroHttp_GetDefaultHeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroHttp.Post
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, class FString>      HeaderParam                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Content                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success, int32 Code, const class FString& Data)>Handle                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::Post(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const class FString& Content, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handle, float InTimeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "Post");

	Params::KuroHttp_Post Parms{};

	Parms.URL = std::move(URL);
	Parms.HeaderParam = std::move(HeaderParam);
	Parms.Content = std::move(Content);
	Parms.Handle = Handle;
	Parms.InTimeout = InTimeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.PostWithData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, class FString>      HeaderParam                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<uint8>                           Content                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success, int32 Code, const class FString& Data)>Handle                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::PostWithData(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const TArray<uint8>& Content, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handle, float InTimeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "PostWithData");

	Params::KuroHttp_PostWithData Parms{};

	Parms.URL = std::move(URL);
	Parms.HeaderParam = std::move(HeaderParam);
	Parms.Content = std::move(Content);
	Parms.Handle = Handle;
	Parms.InTimeout = InTimeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.PostWithFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, class FString>      HeaderParam                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success, int32 Code, const class FString& Data)>Handle                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttp::PostWithFile(const class FString& URL, const TMap<class FString, class FString>& HeaderParam, const class FString& FilePath, TDelegate<void(bool Success, int32 Code, const class FString& Data)> Handle, float InTimeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "PostWithFile");

	Params::KuroHttp_PostWithFile Parms{};

	Parms.URL = std::move(URL);
	Parms.HeaderParam = std::move(HeaderParam);
	Parms.FilePath = std::move(FilePath);
	Parms.Handle = Handle;
	Parms.InTimeout = InTimeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttp.UnCompressDataToStringAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Data                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// ECompressMethod                         CompressMethod                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PresumedUnCompressedSize                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& String)>OnDecompressed                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UKuroHttp::UnCompressDataToStringAsync(const TArray<uint8>& Data, ECompressMethod CompressMethod, int32 PresumedUnCompressedSize, TDelegate<void(const class FString& String)> OnDecompressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroHttp", "UnCompressDataToStringAsync");

	Params::KuroHttp_UnCompressDataToStringAsync Parms{};

	Parms.Data = std::move(Data);
	Parms.CompressMethod = CompressMethod;
	Parms.PresumedUnCompressedSize = PresumedUnCompressedSize;
	Parms.OnDecompressed = OnDecompressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttpServerRequestProxy.GetHeader
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   OutHeader                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroHttpServerRequestProxy::GetHeader(const class FString& Key, TArray<class FString>* OutHeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRequestProxy", "GetHeader");

	Params::KuroHttpServerRequestProxy_GetHeader Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHeader != nullptr)
		*OutHeader = std::move(Parms.OutHeader);

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroHttpServerRequestProxy.GetRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroHttpServerRequestProxy::GetRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRequestProxy", "GetRequest");

	Params::KuroHttpServerRequestProxy_GetRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroHttpServerRequestProxy.Response
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Json                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttpServerRequestProxy::Response(const class FString& Json, const bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRequestProxy", "Response");

	Params::KuroHttpServerRequestProxy_Response Parms{};

	Parms.Json = std::move(Json);
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttpServerRouterProxy.BindRoute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ModuleName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttpServerRouterProxy::BindRoute(const class FString& ModuleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRouterProxy", "BindRoute");

	Params::KuroHttpServerRouterProxy_BindRoute Parms{};

	Parms.ModuleName = std::move(ModuleName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttpServerRouterProxy.CreateRouter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Port                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroHttpServerRouterProxy::CreateRouter(const int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRouterProxy", "CreateRouter");

	Params::KuroHttpServerRouterProxy_CreateRouter Parms{};

	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroHttpServerRouterProxy.StartServer
// (Final, Native, Public, BlueprintCallable)

void UKuroHttpServerRouterProxy::StartServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroHttpServerRouterProxy", "StartServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetEnType
// (Final, Native, Public)
// Parameters:
// uint8                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int16                                   MsgId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetEnType(uint8 Type, int16 MsgId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetEnType");

	Params::KuroKcpClient_SetEnType Parms{};

	Parms.Type = Type;
	Parms.MsgId = MsgId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetK
// (Final, Native, Public, HasOutParams)
// Parameters:
// uint8                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArrayBuffer                     KeyBuffer                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroKcpClient::SetK(uint8 Type, const struct FArrayBuffer& KeyBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetK");

	Params::KuroKcpClient_SetK Parms{};

	Parms.Type = Type;
	Parms.KeyBuffer = std::move(KeyBuffer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.KuroKcpClient.SetKcpMtu
// (Final, Native, Public)
// Parameters:
// int32                                   Mtu                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpMtu(int32 Mtu)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpMtu");

	Params::KuroKcpClient_SetKcpMtu Parms{};

	Parms.Mtu = Mtu;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetKcpNoDelay
// (Final, Native, Public)
// Parameters:
// int32                                   NoDelay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Resend                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Nc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpNoDelay(int32 NoDelay, int32 Interval, int32 Resend, int32 Nc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpNoDelay");

	Params::KuroKcpClient_SetKcpNoDelay Parms{};

	Parms.NoDelay = NoDelay;
	Parms.Interval = Interval;
	Parms.Resend = Resend;
	Parms.Nc = Nc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetKcpSegmentSize
// (Final, Native, Public)
// Parameters:
// int32                                   SegmentSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpSegmentSize(int32 SegmentSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpSegmentSize");

	Params::KuroKcpClient_SetKcpSegmentSize Parms{};

	Parms.SegmentSize = SegmentSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetKcpStream
// (Final, Native, Public)
// Parameters:
// bool                                    bStream                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpStream(bool bStream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpStream");

	Params::KuroKcpClient_SetKcpStream Parms{};

	Parms.bStream = bStream;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.SetKcpWndSize
// (Final, Native, Public)
// Parameters:
// int32                                   SndWnd                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RcvWnd                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::SetKcpWndSize(int32 SndWnd, int32 RcvWnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "SetKcpWndSize");

	Params::KuroKcpClient_SetKcpWndSize Parms{};

	Parms.SndWnd = SndWnd;
	Parms.RcvWnd = RcvWnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroKcpClient.TickOutside
// (Final, Native, Public)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroKcpClient::TickOutside(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroKcpClient", "TickOutside");

	Params::KuroKcpClient_TickOutside Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroNetwork.KuroNetworkChange.GetNetworkType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UKuroNetworkChange::GetNetworkType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroNetworkChange", "GetNetworkType");

	Params::KuroNetworkChange_GetNetworkType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.SendHttpRequest.HttpRequest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHttpMethod                             Method                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PostBody                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USendHttpRequest*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendHttpRequest* USendHttpRequest::HttpRequest(const class FString& URL, EHttpMethod Method, const class FString& PostBody)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SendHttpRequest", "HttpRequest");

	Params::SendHttpRequest_HttpRequest Parms{};

	Parms.URL = std::move(URL);
	Parms.Method = Method;
	Parms.PostBody = std::move(PostBody);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroNetwork.SendHttpRequest.HttpRequestEx
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHttpMethod                             Method                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PostBody                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           HeaderParam                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USendHttpRequest*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendHttpRequest* USendHttpRequest::HttpRequestEx(const class FString& URL, EHttpMethod Method, const class FString& PostBody, const class FString& HeaderParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SendHttpRequest", "HttpRequestEx");

	Params::SendHttpRequest_HttpRequestEx Parms{};

	Parms.URL = std::move(URL);
	Parms.Method = Method;
	Parms.PostBody = std::move(PostBody);
	Parms.HeaderParam = std::move(HeaderParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

