#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroGameplay

#include "Basic.hpp"

#include "KuroGameplay_classes.hpp"
#include "KuroGameplay_parameters.hpp"


namespace SDK
{

// Function KuroGameplay.KuroEffectLibrary.AddSceneComponent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           Param_Class                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeferredFinish                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UKuroEffectLibrary::AddSceneComponent(class AActor* Actor, class UClass* Param_Class, class USceneComponent* Parent, bool bDeferredFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "AddSceneComponent");

	Params::KuroEffectLibrary_AddSceneComponent Parms{};

	Parms.Actor = Actor;
	Parms.Param_Class = Param_Class;
	Parms.Parent = Parent;
	Parms.bDeferredFinish = bDeferredFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.AddSceneComponentWithTransform
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           Param_Class                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeferredFinish                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UKuroEffectLibrary::AddSceneComponentWithTransform(class AActor* Actor, class UClass* Param_Class, class USceneComponent* Parent, bool bDeferredFinish, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "AddSceneComponentWithTransform");

	Params::KuroEffectLibrary_AddSceneComponentWithTransform Parms{};

	Parms.Actor = Actor;
	Parms.Param_Class = Param_Class;
	Parms.Parent = Parent;
	Parms.bDeferredFinish = bDeferredFinish;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.EqualWorld
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroEffectLibrary::EqualWorld(class UWorld* World, class UWorld* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "EqualWorld");

	Params::KuroEffectLibrary_EqualWorld Parms{};

	Parms.World = World;
	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.GetActorDefaultAttachComponent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UKuroEffectLibrary::GetActorDefaultAttachComponent(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "GetActorDefaultAttachComponent");

	Params::KuroEffectLibrary_GetActorDefaultAttachComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// EKuroNiagaraEffectRegularType           EffectRegularType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroEffectLibrary::GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance(EKuroNiagaraEffectRegularType EffectRegularType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance");

	Params::KuroEffectLibrary_GetNiagaraEffectRegularTypeScalabilitySettingsMaxDistance Parms{};

	Parms.EffectRegularType = EffectRegularType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.GetNiagaraSystemEffectRegularType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UNiagaraSystem*                   NiagaraSystem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKuroNiagaraEffectRegularType           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EKuroNiagaraEffectRegularType UKuroEffectLibrary::GetNiagaraSystemEffectRegularType(class UNiagaraSystem* NiagaraSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "GetNiagaraSystemEffectRegularType");

	Params::KuroEffectLibrary_GetNiagaraSystemEffectRegularType Parms{};

	Parms.NiagaraSystem = NiagaraSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.InitModelNiagaraSpec
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUIScene                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReceivesDecals                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TranslucencySortPriority                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::InitModelNiagaraSpec(class UNiagaraComponent* NiagaraComponent, bool bUIScene, bool bReceivesDecals, int32 TranslucencySortPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "InitModelNiagaraSpec");

	Params::KuroEffectLibrary_InitModelNiagaraSpec Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.bUIScene = bUIScene;
	Parms.bReceivesDecals = bReceivesDecals;
	Parms.TranslucencySortPriority = TranslucencySortPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.IsNiagaraComponentHasBound
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroEffectLibrary::IsNiagaraComponentHasBound(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "IsNiagaraComponentHasBound");

	Params::KuroEffectLibrary_IsNiagaraComponentHasBound Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.RegisterOnSystemFinished
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::RegisterOnSystemFinished(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "RegisterOnSystemFinished");

	Params::KuroEffectLibrary_RegisterOnSystemFinished Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.RegisterOnSystemPaused
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::RegisterOnSystemPaused(class UNiagaraComponent* NiagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "RegisterOnSystemPaused");

	Params::KuroEffectLibrary_RegisterOnSystemPaused Parms{};

	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.SetNiagaraFrameDeltaTime
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroEffectLibrary::SetNiagaraFrameDeltaTime(class UNiagaraComponent* NiagaraComponent, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "SetNiagaraFrameDeltaTime");

	Params::KuroEffectLibrary_SetNiagaraFrameDeltaTime Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroEffectLibrary.SetOnSystemFinishedDelegate
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(class UNiagaraComponent* NiagaraComponent)>Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::SetOnSystemFinishedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "SetOnSystemFinishedDelegate");

	Params::KuroEffectLibrary_SetOnSystemFinishedDelegate Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.SetOnSystemPausedDelegate
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(class UNiagaraComponent* NiagaraComponent, bool IsPaused)>Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::SetOnSystemPausedDelegate(const TDelegate<void(class UNiagaraComponent* NiagaraComponent, bool IsPaused)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "SetOnSystemPausedDelegate");

	Params::KuroEffectLibrary_SetOnSystemPausedDelegate Parms{};

	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelLightSpec
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UEffectModelLight*                EffectModelLight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPointLightComponent*             LightComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultMaxLightRadius                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::UpdateEffectModelLightSpec(class UEffectModelLight* EffectModelLight, class UPointLightComponent* LightComponent, bool bForceUpdate, float Time, float DefaultMaxLightRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "UpdateEffectModelLightSpec");

	Params::KuroEffectLibrary_UpdateEffectModelLightSpec Parms{};

	Parms.EffectModelLight = EffectModelLight;
	Parms.LightComponent = LightComponent;
	Parms.bForceUpdate = bForceUpdate;
	Parms.Time = Time;
	Parms.DefaultMaxLightRadius = DefaultMaxLightRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelNiagaraSpec
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UEffectModelNiagara*              EffectModelNiagara                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ExtraState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::UpdateEffectModelNiagaraSpec(class UEffectModelNiagara* EffectModelNiagara, class UNiagaraComponent* NiagaraComponent, bool bForceUpdate, float Time, int32 ExtraState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "UpdateEffectModelNiagaraSpec");

	Params::KuroEffectLibrary_UpdateEffectModelNiagaraSpec Parms{};

	Parms.EffectModelNiagara = EffectModelNiagara;
	Parms.NiagaraComponent = NiagaraComponent;
	Parms.bForceUpdate = bForceUpdate;
	Parms.Time = Time;
	Parms.ExtraState = ExtraState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelPostProcessMaterial
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UEffectModelPostProcess*          EffectModelPostProcess                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         DynMaterial                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroEffectLibrary::UpdateEffectModelPostProcessMaterial(class UEffectModelPostProcess* EffectModelPostProcess, class UMaterialInstanceDynamic* DynMaterial, bool bForceUpdate, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "UpdateEffectModelPostProcessMaterial");

	Params::KuroEffectLibrary_UpdateEffectModelPostProcessMaterial Parms{};

	Parms.EffectModelPostProcess = EffectModelPostProcess;
	Parms.DynMaterial = DynMaterial;
	Parms.bForceUpdate = bForceUpdate;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroEffectLibrary.UpdateEffectModelPostProcessSpec
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UEffectModelPostProcess*          EffectModelPostProcess                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKuroPostProcessComponent*        PostProcessComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           EffectActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LastScreenUV                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UKuroEffectLibrary::UpdateEffectModelPostProcessSpec(class UEffectModelPostProcess* EffectModelPostProcess, class UKuroPostProcessComponent* PostProcessComponent, bool bForceUpdate, float Time, class APlayerController* Controller, class ACharacter* Character, class AActor* EffectActor, const struct FVector2D& LastScreenUV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroEffectLibrary", "UpdateEffectModelPostProcessSpec");

	Params::KuroEffectLibrary_UpdateEffectModelPostProcessSpec Parms{};

	Parms.EffectModelPostProcess = EffectModelPostProcess;
	Parms.PostProcessComponent = PostProcessComponent;
	Parms.bForceUpdate = bForceUpdate;
	Parms.Time = Time;
	Parms.Controller = Controller;
	Parms.Character = Character;
	Parms.EffectActor = EffectActor;
	Parms.LastScreenUV = std::move(LastScreenUV);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayLibrary.GetEntityIdByBaseItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroLevelPlayLibrary::GetEntityIdByBaseItem(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "GetEntityIdByBaseItem");

	Params::KuroLevelPlayLibrary_GetEntityIdByBaseItem Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroLevelPlayLibrary.RegisterBaseItemInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           BaseItemClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           EntityIdName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroLevelPlayLibrary::RegisterBaseItemInfo(class UClass* BaseItemClass, const class FString& EntityIdName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroLevelPlayLibrary", "RegisterBaseItemInfo");

	Params::KuroLevelPlayLibrary_RegisterBaseItemInfo Parms{};

	Parms.BaseItemClass = BaseItemClass;
	Parms.EntityIdName = std::move(EntityIdName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.AfterTickOutside
// (Final, Native, Public)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::AfterTickOutside(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "AfterTickOutside");

	Params::GameBudgetAllocator_AfterTickOutside Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetCamera
// (Final, Native, Public)
// Parameters:
// class AActor*                           ActorActAsCamera                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetCamera(class AActor* ActorActAsCamera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetCamera");

	Params::GameBudgetAllocator_SetCamera Parms{};

	Parms.ActorActAsCamera = ActorActAsCamera;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetDefaultTickIntervalDetailConfig
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameBudgetAllocatorGroupConfig  Config                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// uint32                                  MaxTickInterval                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  TickReductionStartSize                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  TickReductionIntervalSize                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetDefaultTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetDefaultTickIntervalDetailConfig");

	Params::GameBudgetAllocator_SetDefaultTickIntervalDetailConfig Parms{};

	Parms.MaxTickInterval = MaxTickInterval;
	Parms.TickReductionStartSize = TickReductionStartSize;
	Parms.TickReductionIntervalSize = TickReductionIntervalSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Config != nullptr)
		*Config = std::move(Parms.Config);
}


// Function KuroGameplay.GameBudgetAllocator.SetGlobalMode
// (Final, Native, Public)
// Parameters:
// EGameBudgetAllocatorGlobalMode          Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetGlobalMode(EGameBudgetAllocatorGlobalMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetGlobalMode");

	Params::GameBudgetAllocator_SetGlobalMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetGroupConfig
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             GroupName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameBudgetAllocatorGroupConfig  Config                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetGroupConfig(class FName GroupName, const struct FGameBudgetAllocatorGroupConfig& Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetGroupConfig");

	Params::GameBudgetAllocator_SetGroupConfig Parms{};

	Parms.GroupName = GroupName;
	Parms.Config = std::move(Config);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetMaximumFrameRate
// (Final, Native, Public)
// Parameters:
// uint32                                  MaxFPS                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetMaximumFrameRate(uint32 MaxFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetMaximumFrameRate");

	Params::GameBudgetAllocator_SetMaximumFrameRate Parms{};

	Parms.MaxFPS = MaxFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.SetTickIntervalDetailConfig
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameBudgetAllocatorGroupConfig  Config                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// EGameBudgetAllocatorGlobalMode          GlobalMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameBudgetAllocatorActorMode           ActorMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  MaxTickInterval                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  TickReductionStartSize                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint16                                  TickReductionIntervalSize                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::SetTickIntervalDetailConfig(struct FGameBudgetAllocatorGroupConfig* Config, EGameBudgetAllocatorGlobalMode GlobalMode, EGameBudgetAllocatorActorMode ActorMode, uint32 MaxTickInterval, uint16 TickReductionStartSize, uint16 TickReductionIntervalSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "SetTickIntervalDetailConfig");

	Params::GameBudgetAllocator_SetTickIntervalDetailConfig Parms{};

	Parms.GlobalMode = GlobalMode;
	Parms.ActorMode = ActorMode;
	Parms.MaxTickInterval = MaxTickInterval;
	Parms.TickReductionStartSize = TickReductionStartSize;
	Parms.TickReductionIntervalSize = TickReductionIntervalSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Config != nullptr)
		*Config = std::move(Parms.Config);
}


// Function KuroGameplay.GameBudgetAllocator.TickOutside
// (Final, Native, Public)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::TickOutside(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "TickOutside");

	Params::GameBudgetAllocator_TickOutside Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.GameBudgetAllocator.UpdateMinUpdateFIFOBudgetTime
// (Final, Native, Public)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameBudgetAllocator::UpdateMinUpdateFIFOBudgetTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameBudgetAllocator", "UpdateMinUpdateFIFOBudgetTime");

	Params::GameBudgetAllocator_UpdateMinUpdateFIFOBudgetTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroMultilBgProgressBar.SetFillColorAndOpacity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMultilBgProgressBar::SetFillColorAndOpacity(const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMultilBgProgressBar", "SetFillColorAndOpacity");

	Params::KuroMultilBgProgressBar_SetFillColorAndOpacity Parms{};

	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroMultilBgProgressBar.SetIsMarquee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbIsMarquee                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMultilBgProgressBar::SetIsMarquee(bool InbIsMarquee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMultilBgProgressBar", "SetIsMarquee");

	Params::KuroMultilBgProgressBar_SetIsMarquee Parms{};

	Parms.InbIsMarquee = InbIsMarquee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroMultilBgProgressBar.SetMiddlePercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMultilBgProgressBar::SetMiddlePercent(float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMultilBgProgressBar", "SetMiddlePercent");

	Params::KuroMultilBgProgressBar_SetMiddlePercent Parms{};

	Parms.InPercent = InPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroMultilBgProgressBar.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroMultilBgProgressBar::SetPercent(float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMultilBgProgressBar", "SetPercent");

	Params::KuroMultilBgProgressBar_SetPercent Parms{};

	Parms.InPercent = InPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroResourceManager.GetAsset
// (Final, Native, Public)
// Parameters:
// int32                                   HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKuroResourceManager::GetAsset(const int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "GetAsset");

	Params::KuroResourceManager_GetAsset Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroResourceManager.LoadAsyncWithId
// (Final, Native, Public)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroResourceManager::LoadAsyncWithId(const class FString& Path, const int32 HandleId, const int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "LoadAsyncWithId");

	Params::KuroResourceManager_LoadAsyncWithId Parms{};

	Parms.Path = std::move(Path);
	Parms.HandleId = HandleId;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroResourceManager.Release
// (Final, Native, Public)
// Parameters:
// int32                                   HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroResourceManager::Release(const int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "Release");

	Params::KuroResourceManager_Release Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroResourceManager.SyncLoad
// (Final, Native, Public)
// Parameters:
// int32                                   HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroResourceManager::SyncLoad(const int32 HandleId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "SyncLoad");

	Params::KuroResourceManager_SyncLoad Parms{};

	Parms.HandleId = HandleId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroResourceManager.WaitComplete
// (Final, Native, Public)
// Parameters:
// int32                                   HandleId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroResourceManager::WaitComplete(const int32 HandleId, const float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "WaitComplete");

	Params::KuroResourceManager_WaitComplete Parms{};

	Parms.HandleId = HandleId;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroResourceManager.GetLoadedAsset
// (Final, Native, Public, Const)
// Parameters:
// class FString                           Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKuroResourceManager::GetLoadedAsset(const class FString& Path) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroResourceManager", "GetLoadedAsset");

	Params::KuroResourceManager_GetLoadedAsset Parms{};

	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindBindingById
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGuid                            BindingId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSequencerBindingRuntimeProxy    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSequencerBindingRuntimeProxy UKuroSequenceRuntimeFunctionLibrary::FindBindingById(class UMovieSceneSequence* Sequence, const struct FGuid& BindingId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "FindBindingById");

	Params::KuroSequenceRuntimeFunctionLibrary_FindBindingById Parms{};

	Parms.Sequence = Sequence;
	Parms.BindingId = std::move(BindingId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindMasterTracksByType
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UMovieSceneTrack>     TrackType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroSequenceRuntimeFunctionLibrary::FindMasterTracksByType(class UMovieSceneSequence* Sequence, TSubclassOf<class UMovieSceneTrack> TrackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "FindMasterTracksByType");

	Params::KuroSequenceRuntimeFunctionLibrary_FindMasterTracksByType Parms{};

	Parms.Sequence = Sequence;
	Parms.TrackType = TrackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.FindTracksByType
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequencerBindingRuntimeProxy    InBinding                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class UMovieSceneTrack>     TrackType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroSequenceRuntimeFunctionLibrary::FindTracksByType(const struct FSequencerBindingRuntimeProxy& InBinding, TSubclassOf<class UMovieSceneTrack> TrackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "FindTracksByType");

	Params::KuroSequenceRuntimeFunctionLibrary_FindTracksByType Parms{};

	Parms.InBinding = std::move(InBinding);
	Parms.TrackType = TrackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetEndFrame
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSection*               Section                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::GetEndFrame(class UMovieSceneSection* Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetEndFrame");

	Params::KuroSequenceRuntimeFunctionLibrary_GetEndFrame Parms{};

	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetFadeAmountAt
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneFadeSection*           Section                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameTime                       Frame                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UKuroSequenceRuntimeFunctionLibrary::GetFadeAmountAt(class UMovieSceneFadeSection* Section, const struct FFrameTime& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetFadeAmountAt");

	Params::KuroSequenceRuntimeFunctionLibrary_GetFadeAmountAt Parms{};

	Parms.Section = Section;
	Parms.Frame = std::move(Frame);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetFrameTransform
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UMovieSceneTrack*                 Track                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameTime                       Frame                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UKuroSequenceRuntimeFunctionLibrary::GetFrameTransform(class UMovieSceneTrack* Track, const struct FFrameTime& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetFrameTransform");

	Params::KuroSequenceRuntimeFunctionLibrary_GetFrameTransform Parms{};

	Parms.Track = Track;
	Parms.Frame = std::move(Frame);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetMasterTracks
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroSequenceRuntimeFunctionLibrary::GetMasterTracks(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetMasterTracks");

	Params::KuroSequenceRuntimeFunctionLibrary_GetMasterTracks Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetObjectTemplate
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequencerBindingRuntimeProxy    InBinding                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UKuroSequenceRuntimeFunctionLibrary::GetObjectTemplate(const struct FSequencerBindingRuntimeProxy& InBinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetObjectTemplate");

	Params::KuroSequenceRuntimeFunctionLibrary_GetObjectTemplate Parms{};

	Parms.InBinding = std::move(InBinding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetPlaybackEnd
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::GetPlaybackEnd(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetPlaybackEnd");

	Params::KuroSequenceRuntimeFunctionLibrary_GetPlaybackEnd Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetPlaybackStart
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::GetPlaybackStart(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetPlaybackStart");

	Params::KuroSequenceRuntimeFunctionLibrary_GetPlaybackStart Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetSections
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneTrack*                 Track                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneSection*>       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneSection*> UKuroSequenceRuntimeFunctionLibrary::GetSections(class UMovieSceneTrack* Track)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetSections");

	Params::KuroSequenceRuntimeFunctionLibrary_GetSections Parms{};

	Parms.Track = Track;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetSpawnables
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSequencerBindingRuntimeProxy>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSequencerBindingRuntimeProxy> UKuroSequenceRuntimeFunctionLibrary::GetSpawnables(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetSpawnables");

	Params::KuroSequenceRuntimeFunctionLibrary_GetSpawnables Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetStartFrame
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSection*               Section                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKuroSequenceRuntimeFunctionLibrary::GetStartFrame(class UMovieSceneSection* Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetStartFrame");

	Params::KuroSequenceRuntimeFunctionLibrary_GetStartFrame Parms{};

	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.GetTracks
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSequencerBindingRuntimeProxy    InBinding                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class UMovieSceneTrack*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMovieSceneTrack*> UKuroSequenceRuntimeFunctionLibrary::GetTracks(const struct FSequencerBindingRuntimeProxy& InBinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "GetTracks");

	Params::KuroSequenceRuntimeFunctionLibrary_GetTracks Parms{};

	Parms.InBinding = std::move(InBinding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.HandleSeqTexStreaming
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class ULevelSequence*                   LevelSequences                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartForceStreamIn                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSequenceRuntimeFunctionLibrary::HandleSeqTexStreaming(const class ULevelSequence* LevelSequences, const bool bStartForceStreamIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "HandleSeqTexStreaming");

	Params::KuroSequenceRuntimeFunctionLibrary_HandleSeqTexStreaming Parms{};

	Parms.LevelSequences = LevelSequences;
	Parms.bStartForceStreamIn = bStartForceStreamIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.MuteTrackByTag
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsMuted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSequenceRuntimeFunctionLibrary::MuteTrackByTag(class UMovieSceneSequence* Sequence, class FName Tag, bool bIsMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "MuteTrackByTag");

	Params::KuroSequenceRuntimeFunctionLibrary_MuteTrackByTag Parms{};

	Parms.Sequence = Sequence;
	Parms.Tag = Tag;
	Parms.bIsMuted = bIsMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.ResetMovieSceneCompiledData
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSequence*              Sequence                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroSequenceRuntimeFunctionLibrary::ResetMovieSceneCompiledData(class UMovieSceneSequence* Sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "ResetMovieSceneCompiledData");

	Params::KuroSequenceRuntimeFunctionLibrary_ResetMovieSceneCompiledData Parms{};

	Parms.Sequence = Sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.KuroSequenceRuntimeFunctionLibrary.SectionContains
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UMovieSceneSection*               Section                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrameTime                       Frame                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroSequenceRuntimeFunctionLibrary::SectionContains(class UMovieSceneSection* Section, const struct FFrameTime& Frame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroSequenceRuntimeFunctionLibrary", "SectionContains");

	Params::KuroSequenceRuntimeFunctionLibrary_SectionContains Parms{};

	Parms.Section = Section;
	Parms.Frame = std::move(Frame);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroGameplay.KuroStaticMeshLibrary.MergeSimpleCollisions
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             TemplateComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               LocalTransforms                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKuroStaticMeshLibrary::MergeSimpleCollisions(class UStaticMeshComponent* TemplateComponent, const TArray<struct FTransform>& LocalTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroStaticMeshLibrary", "MergeSimpleCollisions");

	Params::KuroStaticMeshLibrary_MergeSimpleCollisions Parms{};

	Parms.TemplateComponent = TemplateComponent;
	Parms.LocalTransforms = std::move(LocalTransforms);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.AddStatistics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FrameCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Tag                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MeasureMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UserDefineMessage                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerformanceStatisticsLibrary::AddStatistics(class FName SectionName, int32 FrameCount, const class FString& Tag, int32 MeasureMode, float Time, const class FString& UserDefineMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "AddStatistics");

	Params::PerformanceStatisticsLibrary_AddStatistics Parms{};

	Parms.SectionName = SectionName;
	Parms.FrameCount = FrameCount;
	Parms.Tag = std::move(Tag);
	Parms.MeasureMode = MeasureMode;
	Parms.Time = Time;
	Parms.UserDefineMessage = std::move(UserDefineMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.Clear
// (Final, Native, Static, Public, BlueprintCallable)

void UPerformanceStatisticsLibrary::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.Export
// (Final, Native, Static, Public, BlueprintCallable)

void UPerformanceStatisticsLibrary::Export()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "Export");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.ReadAllSectionsFromDirectory
// (Final, Native, Static, Public, BlueprintCallable)

void UPerformanceStatisticsLibrary::ReadAllSectionsFromDirectory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "ReadAllSectionsFromDirectory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroGameplay.PerformanceStatisticsLibrary.ReadSectionFromFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerformanceStatisticsLibrary::ReadSectionFromFile(class FString* FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "ReadSectionFromFile");

	Params::PerformanceStatisticsLibrary_ReadSectionFromFile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FilePath != nullptr)
		*FilePath = std::move(Parms.FilePath);
}


// Function KuroGameplay.PerformanceStatisticsLibrary.StatisticsFromRawDataFiles
// (Final, Native, Static, Public, BlueprintCallable)

void UPerformanceStatisticsLibrary::StatisticsFromRawDataFiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerformanceStatisticsLibrary", "StatisticsFromRawDataFiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

