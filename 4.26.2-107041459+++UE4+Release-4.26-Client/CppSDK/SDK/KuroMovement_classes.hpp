#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroMovement

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "KuroMovement_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class KuroMovement.KuroClimbObject
// 0x01E0 (0x0210 - 0x0030)
class UKuroClimbObject final : public UObject
{
public:
	uint8                                         Pad_17E4[0x1E0];                                   // 0x0030(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ClimbBlock();
	void ConfirmMove();
	void ExitClimb();
	struct FVector GetSafetyLocation();
	struct FVector GetSecondMoveOffset();
	void InitBase(class UShapeComponent* InShapeComp, ECollisionChannel InClimbChannel, const TArray<struct FVector>& BaseLocations, float InSphereRadius, float InActorToWallDist, float InDetectLength, float InSafetyHalfHeight, float InSafetyRadius);
	void InitBlockUps(const struct FVector& InBlockUpOffset, float InBlockUpDetectRadius, float InBlockUpDetectDistance, float InBlockUpBackDistance, float InBlockUpBackMin, const struct FVector& InBlockUpFinalMove, float BlockUpVerticalRangeMin, float BlockUpVerticalRangeMax);
	void InitClimbSafety(float InRadius, float InHalfHeight, float InMaxOffset);
	void InitSprintVault(float InForwardBlockHeight, float InForwardBlockRadius, float InForwardBlockDistanceMin, float InForwardBlockDistanceMax, const struct FVector& InSprintVaultMoveOffset, float InHeightMin, float InHeightMax, float InSprintVaultLongNeedDistance, float InSprintVaultLongHeight, ETraceTypeQuery InBlockChannel, float SprintVaultLongMin, float SprintVaultLongMax, float SprintVaultBlockMaxAngle);
	void InitUpArrives(const TArray<struct FVector>& InUpArriveMoveOffsets, const TArray<float>& InHeightMins, const TArray<float>& InHeightMaxs);
	bool NeedFollowHangOnStartingClimb();
	bool ProcessClimbing(const struct FVector& MoveSpeed, float DeltaTime, bool IsTryMove, float DebugDrawDuration, struct FTransform* OutTrans);
	void SyncFromOther(class UKuroClimbObject* Other);
	EClimbingArriveType TryClimbingArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans, bool NeedTryBlockUp);
	ESprintVaultType TrySprintVault(float DebugDrawDuration, struct FTransform* OutTrans, float* OutLongOffset);
	bool TryStartClimb(const struct FTransform& Trans, float DebugDrawDuration, struct FTransform* OutTrans);
	EClimbingArriveType TryUpArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroClimbObject">();
	}
	static class UKuroClimbObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroClimbObject>();
	}
};
static_assert(alignof(UKuroClimbObject) == 0x000008, "Wrong alignment on UKuroClimbObject");
static_assert(sizeof(UKuroClimbObject) == 0x000210, "Wrong size on UKuroClimbObject");

// Class KuroMovement.KuroDebugMovementComponent
// 0x01A0 (0x0680 - 0x04E0)
class UKuroDebugMovementComponent final : public UPrimitiveComponent
{
public:
	int32                                         DrawDebugCount;                                    // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowLog : 1;                                      // 0x04E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EKDMDrawDebugType                             bDrawDebug;                                        // 0x04E5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F1[0x19A];                                   // 0x04E6(0x019A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FString KuroDebugMovementBaseRecordToString(const struct FBaseRecord& Record);

	class FString GetFrameCountInfo();
	const TArray<struct FSingleFrameDebugInfo> GetRecentRecords();
	void RecordModifyInfo(const class FString& Context, const struct FVector& CustomVector, EKDMRecordType Type);
	void Resigter();
	void SetDebug(bool bDebug, bool bDetial);
	void UnResigter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroDebugMovementComponent">();
	}
	static class UKuroDebugMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroDebugMovementComponent>();
	}
};
static_assert(alignof(UKuroDebugMovementComponent) == 0x000010, "Wrong alignment on UKuroDebugMovementComponent");
static_assert(sizeof(UKuroDebugMovementComponent) == 0x000680, "Wrong size on UKuroDebugMovementComponent");
static_assert(offsetof(UKuroDebugMovementComponent, DrawDebugCount) == 0x0004E0, "Member 'UKuroDebugMovementComponent::DrawDebugCount' has a wrong offset!");
static_assert(offsetof(UKuroDebugMovementComponent, bDrawDebug) == 0x0004E5, "Member 'UKuroDebugMovementComponent::bDrawDebug' has a wrong offset!");

// Class KuroMovement.KuroMoveTrigger
// 0x0008 (0x02B0 - 0x02A8)
class AKuroMoveTrigger : public AActor
{
public:
	ETriggerAreaType                              AreaType;                                          // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17F4[0x7];                                     // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnEnterOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMoveTrigger">();
	}
	static class AKuroMoveTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveTrigger>();
	}
};
static_assert(alignof(AKuroMoveTrigger) == 0x000008, "Wrong alignment on AKuroMoveTrigger");
static_assert(sizeof(AKuroMoveTrigger) == 0x0002B0, "Wrong size on AKuroMoveTrigger");
static_assert(offsetof(AKuroMoveTrigger, AreaType) == 0x0002A8, "Member 'AKuroMoveTrigger::AreaType' has a wrong offset!");

// Class KuroMovement.KuroMoveBoxTrigger
// 0x0008 (0x02B8 - 0x02B0)
class AKuroMoveBoxTrigger final : public AKuroMoveTrigger
{
public:
	class UBoxComponent*                          BoxCollision;                                      // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMoveBoxTrigger">();
	}
	static class AKuroMoveBoxTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveBoxTrigger>();
	}
};
static_assert(alignof(AKuroMoveBoxTrigger) == 0x000008, "Wrong alignment on AKuroMoveBoxTrigger");
static_assert(sizeof(AKuroMoveBoxTrigger) == 0x0002B8, "Wrong size on AKuroMoveBoxTrigger");
static_assert(offsetof(AKuroMoveBoxTrigger, BoxCollision) == 0x0002B0, "Member 'AKuroMoveBoxTrigger::BoxCollision' has a wrong offset!");

// Class KuroMovement.KuroMoveBrushTrigger
// 0x0010 (0x02C0 - 0x02B0)
class AKuroMoveBrushTrigger final : public AKuroMoveTrigger
{
public:
	class ABrush*                                 Volume;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMoveBrushTrigger">();
	}
	static class AKuroMoveBrushTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveBrushTrigger>();
	}
};
static_assert(alignof(AKuroMoveBrushTrigger) == 0x000008, "Wrong alignment on AKuroMoveBrushTrigger");
static_assert(sizeof(AKuroMoveBrushTrigger) == 0x0002C0, "Wrong size on AKuroMoveBrushTrigger");
static_assert(offsetof(AKuroMoveBrushTrigger, Volume) == 0x0002B0, "Member 'AKuroMoveBrushTrigger::Volume' has a wrong offset!");
static_assert(offsetof(AKuroMoveBrushTrigger, Root) == 0x0002B8, "Member 'AKuroMoveBrushTrigger::Root' has a wrong offset!");

// Class KuroMovement.KuroMovementBPLibrary
// 0x0000 (0x0030 - 0x0030)
class UKuroMovementBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool KuroSoar(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, float AirFriction, float Aerodynamics, const struct FVector& Gravity, const struct FVector& SoarPlaneNormal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMovementBPLibrary">();
	}
	static class UKuroMovementBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKuroMovementBPLibrary>();
	}
};
static_assert(alignof(UKuroMovementBPLibrary) == 0x000008, "Wrong alignment on UKuroMovementBPLibrary");
static_assert(sizeof(UKuroMovementBPLibrary) == 0x000030, "Wrong size on UKuroMovementBPLibrary");

// Class KuroMovement.KuroMoveTriggerController
// 0x0020 (0x02C8 - 0x02A8)
class AKuroMoveTriggerController final : public AInfo
{
public:
	FMulticastInlineDelegateProperty_             Callback;                                          // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FOverlapActorRecord>            Records;                                           // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static void RegisterController(class AKuroMoveTriggerController* ControllerPtr);
	static void UnRegisterController();

	void InitAllTriggers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KuroMoveTriggerController">();
	}
	static class AKuroMoveTriggerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKuroMoveTriggerController>();
	}
};
static_assert(alignof(AKuroMoveTriggerController) == 0x000008, "Wrong alignment on AKuroMoveTriggerController");
static_assert(sizeof(AKuroMoveTriggerController) == 0x0002C8, "Wrong size on AKuroMoveTriggerController");
static_assert(offsetof(AKuroMoveTriggerController, Callback) == 0x0002A8, "Member 'AKuroMoveTriggerController::Callback' has a wrong offset!");
static_assert(offsetof(AKuroMoveTriggerController, Records) == 0x0002B8, "Member 'AKuroMoveTriggerController::Records' has a wrong offset!");

}

