#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroRenderingRuntimeBPPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "MovieScene_structs.hpp"
#include "KuroCurve_structs.hpp"
#include "KuroRenderingRuntimeBPPlugin_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneInfo.Init
// 0x0040 (0x0040 - 0x0000)
struct KuroUiSceneInfo_Init final
{
public:
	class ULevelStreamingDynamic*                 InLevelStreaming;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InLevelName;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OptionalName;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_186A[0x4];                                     // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 InWorld;                                           // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneInfo_Init) == 0x000008, "Wrong alignment on KuroUiSceneInfo_Init");
static_assert(sizeof(KuroUiSceneInfo_Init) == 0x000040, "Wrong size on KuroUiSceneInfo_Init");
static_assert(offsetof(KuroUiSceneInfo_Init, InLevelStreaming) == 0x000000, "Member 'KuroUiSceneInfo_Init::InLevelStreaming' has a wrong offset!");
static_assert(offsetof(KuroUiSceneInfo_Init, InLevelName) == 0x000008, "Member 'KuroUiSceneInfo_Init::InLevelName' has a wrong offset!");
static_assert(offsetof(KuroUiSceneInfo_Init, OptionalName) == 0x000018, "Member 'KuroUiSceneInfo_Init::OptionalName' has a wrong offset!");
static_assert(offsetof(KuroUiSceneInfo_Init, InLocation) == 0x000028, "Member 'KuroUiSceneInfo_Init::InLocation' has a wrong offset!");
static_assert(offsetof(KuroUiSceneInfo_Init, InWorld) == 0x000038, "Member 'KuroUiSceneInfo_Init::InWorld' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneInfo.SetLevelVisible
// 0x0001 (0x0001 - 0x0000)
struct KuroUiSceneInfo_SetLevelVisible final
{
public:
	bool                                          InIsVisible;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneInfo_SetLevelVisible) == 0x000001, "Wrong alignment on KuroUiSceneInfo_SetLevelVisible");
static_assert(sizeof(KuroUiSceneInfo_SetLevelVisible) == 0x000001, "Wrong size on KuroUiSceneInfo_SetLevelVisible");
static_assert(offsetof(KuroUiSceneInfo_SetLevelVisible, InIsVisible) == 0x000000, "Member 'KuroUiSceneInfo_SetLevelVisible::InIsVisible' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroChangeSkeletalMaterialsComponent.ChangeMaterialsWithDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset final
{
public:
	const class UKuroChangeMaterialsTextures*     DataAsset;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset) == 0x000008, "Wrong alignment on KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset");
static_assert(sizeof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset) == 0x000008, "Wrong size on KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset");
static_assert(offsetof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset, DataAsset) == 0x000000, "Member 'KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithDataAsset::DataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroChangeSkeletalMaterialsComponent.ChangeMaterialsWithTextures
// 0x0028 (0x0028 - 0x0000)
struct KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1870[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTexture2D>>      Textures;                                          // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures) == 0x000008, "Wrong alignment on KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures");
static_assert(sizeof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures) == 0x000028, "Wrong size on KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures");
static_assert(offsetof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures, SkeletalMeshComponent) == 0x000000, "Member 'KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures, ParameterName) == 0x000008, "Member 'KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures, Textures) == 0x000018, "Member 'KuroChangeSkeletalMaterialsComponent_ChangeMaterialsWithTextures::Textures' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotify.K2_Notify
// 0x0018 (0x0018 - 0x0000)
struct KuroAnimNotify_K2_Notify final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1874[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotify_K2_Notify) == 0x000008, "Wrong alignment on KuroAnimNotify_K2_Notify");
static_assert(sizeof(KuroAnimNotify_K2_Notify) == 0x000018, "Wrong size on KuroAnimNotify_K2_Notify");
static_assert(offsetof(KuroAnimNotify_K2_Notify, MeshComp) == 0x000000, "Member 'KuroAnimNotify_K2_Notify::MeshComp' has a wrong offset!");
static_assert(offsetof(KuroAnimNotify_K2_Notify, Animation) == 0x000008, "Member 'KuroAnimNotify_K2_Notify::Animation' has a wrong offset!");
static_assert(offsetof(KuroAnimNotify_K2_Notify, ReturnValue) == 0x000010, "Member 'KuroAnimNotify_K2_Notify::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotify.K2_PostChangeProperty
// 0x0010 (0x0010 - 0x0000)
struct KuroAnimNotify_K2_PostChangeProperty final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1875[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotify_K2_PostChangeProperty) == 0x000004, "Wrong alignment on KuroAnimNotify_K2_PostChangeProperty");
static_assert(sizeof(KuroAnimNotify_K2_PostChangeProperty) == 0x000010, "Wrong size on KuroAnimNotify_K2_PostChangeProperty");
static_assert(offsetof(KuroAnimNotify_K2_PostChangeProperty, PropertyName) == 0x000000, "Member 'KuroAnimNotify_K2_PostChangeProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroAnimNotify_K2_PostChangeProperty, ReturnValue) == 0x00000C, "Member 'KuroAnimNotify_K2_PostChangeProperty::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotify.K2_ValidateAssets
// 0x0001 (0x0001 - 0x0000)
struct KuroAnimNotify_K2_ValidateAssets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroAnimNotify_K2_ValidateAssets) == 0x000001, "Wrong alignment on KuroAnimNotify_K2_ValidateAssets");
static_assert(sizeof(KuroAnimNotify_K2_ValidateAssets) == 0x000001, "Wrong size on KuroAnimNotify_K2_ValidateAssets");
static_assert(offsetof(KuroAnimNotify_K2_ValidateAssets, ReturnValue) == 0x000000, "Member 'KuroAnimNotify_K2_ValidateAssets::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSuperFarFog.Update
// 0x0004 (0x0004 - 0x0000)
struct KuroSuperFarFog_Update final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSuperFarFog_Update) == 0x000004, "Wrong alignment on KuroSuperFarFog_Update");
static_assert(sizeof(KuroSuperFarFog_Update) == 0x000004, "Wrong size on KuroSuperFarFog_Update");
static_assert(offsetof(KuroSuperFarFog_Update, DeltaSeconds) == 0x000000, "Member 'KuroSuperFarFog_Update::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_NotifyBegin
// 0x0018 (0x0018 - 0x0000)
struct KuroAnimNotifyState_K2_NotifyBegin final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDuration;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1878[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotifyState_K2_NotifyBegin) == 0x000008, "Wrong alignment on KuroAnimNotifyState_K2_NotifyBegin");
static_assert(sizeof(KuroAnimNotifyState_K2_NotifyBegin) == 0x000018, "Wrong size on KuroAnimNotifyState_K2_NotifyBegin");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyBegin, MeshComp) == 0x000000, "Member 'KuroAnimNotifyState_K2_NotifyBegin::MeshComp' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyBegin, Animation) == 0x000008, "Member 'KuroAnimNotifyState_K2_NotifyBegin::Animation' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyBegin, TotalDuration) == 0x000010, "Member 'KuroAnimNotifyState_K2_NotifyBegin::TotalDuration' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyBegin, ReturnValue) == 0x000014, "Member 'KuroAnimNotifyState_K2_NotifyBegin::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_NotifyEnd
// 0x0018 (0x0018 - 0x0000)
struct KuroAnimNotifyState_K2_NotifyEnd final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1879[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotifyState_K2_NotifyEnd) == 0x000008, "Wrong alignment on KuroAnimNotifyState_K2_NotifyEnd");
static_assert(sizeof(KuroAnimNotifyState_K2_NotifyEnd) == 0x000018, "Wrong size on KuroAnimNotifyState_K2_NotifyEnd");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyEnd, MeshComp) == 0x000000, "Member 'KuroAnimNotifyState_K2_NotifyEnd::MeshComp' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyEnd, Animation) == 0x000008, "Member 'KuroAnimNotifyState_K2_NotifyEnd::Animation' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyEnd, ReturnValue) == 0x000010, "Member 'KuroAnimNotifyState_K2_NotifyEnd::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_NotifyTick
// 0x0018 (0x0018 - 0x0000)
struct KuroAnimNotifyState_K2_NotifyTick final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameDeltaTime;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_187A[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotifyState_K2_NotifyTick) == 0x000008, "Wrong alignment on KuroAnimNotifyState_K2_NotifyTick");
static_assert(sizeof(KuroAnimNotifyState_K2_NotifyTick) == 0x000018, "Wrong size on KuroAnimNotifyState_K2_NotifyTick");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyTick, MeshComp) == 0x000000, "Member 'KuroAnimNotifyState_K2_NotifyTick::MeshComp' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyTick, Animation) == 0x000008, "Member 'KuroAnimNotifyState_K2_NotifyTick::Animation' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyTick, FrameDeltaTime) == 0x000010, "Member 'KuroAnimNotifyState_K2_NotifyTick::FrameDeltaTime' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_NotifyTick, ReturnValue) == 0x000014, "Member 'KuroAnimNotifyState_K2_NotifyTick::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_PostChangeProperty
// 0x0010 (0x0010 - 0x0000)
struct KuroAnimNotifyState_K2_PostChangeProperty final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_187B[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroAnimNotifyState_K2_PostChangeProperty) == 0x000004, "Wrong alignment on KuroAnimNotifyState_K2_PostChangeProperty");
static_assert(sizeof(KuroAnimNotifyState_K2_PostChangeProperty) == 0x000010, "Wrong size on KuroAnimNotifyState_K2_PostChangeProperty");
static_assert(offsetof(KuroAnimNotifyState_K2_PostChangeProperty, PropertyName) == 0x000000, "Member 'KuroAnimNotifyState_K2_PostChangeProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroAnimNotifyState_K2_PostChangeProperty, ReturnValue) == 0x00000C, "Member 'KuroAnimNotifyState_K2_PostChangeProperty::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroAnimNotifyState.K2_ValidateAssets
// 0x0001 (0x0001 - 0x0000)
struct KuroAnimNotifyState_K2_ValidateAssets final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroAnimNotifyState_K2_ValidateAssets) == 0x000001, "Wrong alignment on KuroAnimNotifyState_K2_ValidateAssets");
static_assert(sizeof(KuroAnimNotifyState_K2_ValidateAssets) == 0x000001, "Wrong size on KuroAnimNotifyState_K2_ValidateAssets");
static_assert(offsetof(KuroAnimNotifyState_K2_ValidateAssets, ReturnValue) == 0x000000, "Member 'KuroAnimNotifyState_K2_ValidateAssets::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroTrailSystem.GetKuroTrailSystem
// 0x0010 (0x0010 - 0x0000)
struct KuroTrailSystem_GetKuroTrailSystem final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroTrailSystem*                       ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTrailSystem_GetKuroTrailSystem) == 0x000008, "Wrong alignment on KuroTrailSystem_GetKuroTrailSystem");
static_assert(sizeof(KuroTrailSystem_GetKuroTrailSystem) == 0x000010, "Wrong size on KuroTrailSystem_GetKuroTrailSystem");
static_assert(offsetof(KuroTrailSystem_GetKuroTrailSystem, InWorld) == 0x000000, "Member 'KuroTrailSystem_GetKuroTrailSystem::InWorld' has a wrong offset!");
static_assert(offsetof(KuroTrailSystem_GetKuroTrailSystem, ReturnValue) == 0x000008, "Member 'KuroTrailSystem_GetKuroTrailSystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroTrailSystem.GetTrailDrawerInRadius
// 0x0020 (0x0020 - 0x0000)
struct KuroTrailSystem_GetTrailDrawerInRadius final
{
public:
	struct FVector                                InWorldPosition;                                   // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UKuroTrailDrawerComponent*>      ReturnValue;                                       // 0x0010(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTrailSystem_GetTrailDrawerInRadius) == 0x000008, "Wrong alignment on KuroTrailSystem_GetTrailDrawerInRadius");
static_assert(sizeof(KuroTrailSystem_GetTrailDrawerInRadius) == 0x000020, "Wrong size on KuroTrailSystem_GetTrailDrawerInRadius");
static_assert(offsetof(KuroTrailSystem_GetTrailDrawerInRadius, InWorldPosition) == 0x000000, "Member 'KuroTrailSystem_GetTrailDrawerInRadius::InWorldPosition' has a wrong offset!");
static_assert(offsetof(KuroTrailSystem_GetTrailDrawerInRadius, Radius) == 0x00000C, "Member 'KuroTrailSystem_GetTrailDrawerInRadius::Radius' has a wrong offset!");
static_assert(offsetof(KuroTrailSystem_GetTrailDrawerInRadius, ReturnValue) == 0x000010, "Member 'KuroTrailSystem_GetTrailDrawerInRadius::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.AddLayer
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_AddLayer final
{
public:
	float                                         Alpha;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_AddLayer) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_AddLayer");
static_assert(sizeof(KuroBezierMeshComponent_AddLayer) == 0x000004, "Wrong size on KuroBezierMeshComponent_AddLayer");
static_assert(offsetof(KuroBezierMeshComponent_AddLayer, Alpha) == 0x000000, "Member 'KuroBezierMeshComponent_AddLayer::Alpha' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.Dissipate
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_Dissipate final
{
public:
	float                                         SubLayersNum;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_Dissipate) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_Dissipate");
static_assert(sizeof(KuroBezierMeshComponent_Dissipate) == 0x000004, "Wrong size on KuroBezierMeshComponent_Dissipate");
static_assert(offsetof(KuroBezierMeshComponent_Dissipate, SubLayersNum) == 0x000000, "Member 'KuroBezierMeshComponent_Dissipate::SubLayersNum' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetLayerNum
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_GetLayerNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetLayerNum) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_GetLayerNum");
static_assert(sizeof(KuroBezierMeshComponent_GetLayerNum) == 0x000004, "Wrong size on KuroBezierMeshComponent_GetLayerNum");
static_assert(offsetof(KuroBezierMeshComponent_GetLayerNum, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetLayerNum::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetMeshHeight
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_GetMeshHeight final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetMeshHeight) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_GetMeshHeight");
static_assert(sizeof(KuroBezierMeshComponent_GetMeshHeight) == 0x000004, "Wrong size on KuroBezierMeshComponent_GetMeshHeight");
static_assert(offsetof(KuroBezierMeshComponent_GetMeshHeight, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetMeshHeight::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetMeshPoints
// 0x0010 (0x0010 - 0x0000)
struct KuroBezierMeshComponent_GetMeshPoints final
{
public:
	TArray<struct FVector>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetMeshPoints) == 0x000008, "Wrong alignment on KuroBezierMeshComponent_GetMeshPoints");
static_assert(sizeof(KuroBezierMeshComponent_GetMeshPoints) == 0x000010, "Wrong size on KuroBezierMeshComponent_GetMeshPoints");
static_assert(offsetof(KuroBezierMeshComponent_GetMeshPoints, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetMeshPoints::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetMeshTriangles
// 0x0010 (0x0010 - 0x0000)
struct KuroBezierMeshComponent_GetMeshTriangles final
{
public:
	TArray<int32>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetMeshTriangles) == 0x000008, "Wrong alignment on KuroBezierMeshComponent_GetMeshTriangles");
static_assert(sizeof(KuroBezierMeshComponent_GetMeshTriangles) == 0x000010, "Wrong size on KuroBezierMeshComponent_GetMeshTriangles");
static_assert(offsetof(KuroBezierMeshComponent_GetMeshTriangles, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetMeshTriangles::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetMeshWidth
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_GetMeshWidth final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetMeshWidth) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_GetMeshWidth");
static_assert(sizeof(KuroBezierMeshComponent_GetMeshWidth) == 0x000004, "Wrong size on KuroBezierMeshComponent_GetMeshWidth");
static_assert(offsetof(KuroBezierMeshComponent_GetMeshWidth, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetMeshWidth::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.GetPointsArray
// 0x0010 (0x0010 - 0x0000)
struct KuroBezierMeshComponent_GetPointsArray final
{
public:
	TArray<struct FVector>                        ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_GetPointsArray) == 0x000008, "Wrong alignment on KuroBezierMeshComponent_GetPointsArray");
static_assert(sizeof(KuroBezierMeshComponent_GetPointsArray) == 0x000010, "Wrong size on KuroBezierMeshComponent_GetPointsArray");
static_assert(offsetof(KuroBezierMeshComponent_GetPointsArray, ReturnValue) == 0x000000, "Member 'KuroBezierMeshComponent_GetPointsArray::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.SetKeyPoint
// 0x0010 (0x0010 - 0x0000)
struct KuroBezierMeshComponent_SetKeyPoint final
{
public:
	int32                                         Param_Index;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_SetKeyPoint) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_SetKeyPoint");
static_assert(sizeof(KuroBezierMeshComponent_SetKeyPoint) == 0x000010, "Wrong size on KuroBezierMeshComponent_SetKeyPoint");
static_assert(offsetof(KuroBezierMeshComponent_SetKeyPoint, Param_Index) == 0x000000, "Member 'KuroBezierMeshComponent_SetKeyPoint::Param_Index' has a wrong offset!");
static_assert(offsetof(KuroBezierMeshComponent_SetKeyPoint, X) == 0x000004, "Member 'KuroBezierMeshComponent_SetKeyPoint::X' has a wrong offset!");
static_assert(offsetof(KuroBezierMeshComponent_SetKeyPoint, Y) == 0x000008, "Member 'KuroBezierMeshComponent_SetKeyPoint::Y' has a wrong offset!");
static_assert(offsetof(KuroBezierMeshComponent_SetKeyPoint, Z) == 0x00000C, "Member 'KuroBezierMeshComponent_SetKeyPoint::Z' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.Setup
// 0x0008 (0x0008 - 0x0000)
struct KuroBezierMeshComponent_Setup final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InUnitLength;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_Setup) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_Setup");
static_assert(sizeof(KuroBezierMeshComponent_Setup) == 0x000008, "Wrong size on KuroBezierMeshComponent_Setup");
static_assert(offsetof(KuroBezierMeshComponent_Setup, Width) == 0x000000, "Member 'KuroBezierMeshComponent_Setup::Width' has a wrong offset!");
static_assert(offsetof(KuroBezierMeshComponent_Setup, InUnitLength) == 0x000004, "Member 'KuroBezierMeshComponent_Setup::InUnitLength' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroBezierMeshComponent.UpdateMesh
// 0x0004 (0x0004 - 0x0000)
struct KuroBezierMeshComponent_UpdateMesh final
{
public:
	int32                                         Section;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroBezierMeshComponent_UpdateMesh) == 0x000004, "Wrong alignment on KuroBezierMeshComponent_UpdateMesh");
static_assert(sizeof(KuroBezierMeshComponent_UpdateMesh) == 0x000004, "Wrong size on KuroBezierMeshComponent_UpdateMesh");
static_assert(offsetof(KuroBezierMeshComponent_UpdateMesh, Section) == 0x000000, "Member 'KuroBezierMeshComponent_UpdateMesh::Section' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetBaseColorTint
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetBaseColorTint final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetBaseColorTint) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetBaseColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetBaseColorTint) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetBaseColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseColorTint, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetBaseColorTint::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseColorTint, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetBaseColorTint::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseColorTint, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetBaseColorTint::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetBaseRefine
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetBaseRefine final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetBaseRefine) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetBaseRefine");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetBaseRefine) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetBaseRefine");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseRefine, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetBaseRefine::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseRefine, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetBaseRefine::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetBaseRefine, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetBaseRefine::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetCustomColorParametersValue
// 0x001C (0x001C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetCustomColorParametersValue final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x000C(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetCustomColorParametersValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue) == 0x00001C, "Wrong size on KuroCharacterMaterialControllerCache_GetCustomColorParametersValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetCustomColorParametersValue::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetCustomColorParametersValue::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue, Param_Index) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetCustomColorParametersValue::Param_Index' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomColorParametersValue, ReturnValue) == 0x00000C, "Member 'KuroCharacterMaterialControllerCache_GetCustomColorParametersValue::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetCustomFloatParametersValue
// 0x0010 (0x0010 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue) == 0x000010, "Wrong size on KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue, Param_Index) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue::Param_Index' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue, ReturnValue) == 0x00000C, "Member 'KuroCharacterMaterialControllerCache_GetCustomFloatParametersValue::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDissolveColor
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDissolveColor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDissolveColor) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDissolveColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDissolveColor) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetDissolveColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColor, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColor::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColor, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColor::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColor, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDissolveColorIntensity
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDissolveColorIntensity final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDissolveColorIntensity");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetDissolveColorIntensity");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColorIntensity::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColorIntensity::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveColorIntensity, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDissolveColorIntensity::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDissolveProgress
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDissolveProgress final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDissolveProgress) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDissolveProgress");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDissolveProgress) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetDissolveProgress");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveProgress, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDissolveProgress::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveProgress, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDissolveProgress::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveProgress, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDissolveProgress::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDissolveSmooth
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDissolveSmooth final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDissolveSmooth) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDissolveSmooth");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDissolveSmooth) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetDissolveSmooth");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveSmooth, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDissolveSmooth::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveSmooth, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDissolveSmooth::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDissolveSmooth, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDissolveSmooth::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetDitherValue
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetDitherValue final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetDitherValue) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetDitherValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetDitherValue) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetDitherValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDitherValue, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetDitherValue::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDitherValue, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetDitherValue::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetDitherValue, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetDitherValue::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetEmissionColor
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetEmissionColor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetEmissionColor) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetEmissionColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetEmissionColor) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetEmissionColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionColor, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetEmissionColor::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionColor, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetEmissionColor::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionColor, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetEmissionColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetEmissionIntensity
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetEmissionIntensity final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetEmissionIntensity) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetEmissionIntensity");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetEmissionIntensity) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetEmissionIntensity");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionIntensity, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetEmissionIntensity::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionIntensity, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetEmissionIntensity::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetEmissionIntensity, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetEmissionIntensity::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetHairDisplaceContrast
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetHairDisplaceContrast final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetHairDisplaceContrast");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetHairDisplaceContrast");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceContrast::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceContrast::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceContrast, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceContrast::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetHairDisplaceProgress
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetHairDisplaceProgress final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetHairDisplaceProgress");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetHairDisplaceProgress");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceProgress::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceProgress::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetHairDisplaceProgress, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetHairDisplaceProgress::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetMainTexColorTint
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetMainTexColorTint final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetMainTexColorTint) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetMainTexColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetMainTexColorTint) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetMainTexColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMainTexColorTint, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetMainTexColorTint::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMainTexColorTint, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetMainTexColorTint::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMainTexColorTint, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetMainTexColorTint::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetMotionColorEnd
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetMotionColorEnd final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetMotionColorEnd) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetMotionColorEnd");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetMotionColorEnd) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetMotionColorEnd");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorEnd, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorEnd::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorEnd, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorEnd::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorEnd, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorEnd::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetMotionColorStart
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetMotionColorStart final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetMotionColorStart) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetMotionColorStart");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetMotionColorStart) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetMotionColorStart");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorStart, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorStart::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorStart, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorStart::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionColorStart, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetMotionColorStart::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetMotionNoiseSpeed
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetMotionNoiseSpeed::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetOutlineColor
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetOutlineColor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetOutlineColor) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetOutlineColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetOutlineColor) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetOutlineColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineColor, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetOutlineColor::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineColor, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetOutlineColor::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineColor, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetOutlineColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetOutlineWidth
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetOutlineWidth final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetOutlineWidth) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetOutlineWidth");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetOutlineWidth) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetOutlineWidth");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineWidth, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetOutlineWidth::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineWidth, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetOutlineWidth::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetOutlineWidth, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetOutlineWidth::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetRimColor
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetRimColor final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetRimColor) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetRimColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetRimColor) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetRimColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimColor, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetRimColor::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimColor, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetRimColor::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimColor, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetRimColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetRimRange
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetRimRange final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetRimRange) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetRimRange");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetRimRange) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetRimRange");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimRange, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetRimRange::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimRange, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetRimRange::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRimRange, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetRimRange::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetRotation
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetRotation final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetRotation) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetRotation");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetRotation) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetRotation");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRotation, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetRotation::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRotation, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetRotation::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetRotation, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetRotation::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetStripMaskProportion
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetStripMaskProportion final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetStripMaskProportion) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetStripMaskProportion");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetStripMaskProportion) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetStripMaskProportion");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskProportion, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskProportion::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskProportion, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskProportion::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskProportion, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskProportion::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetStripMaskVScale
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetStripMaskVScale final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetStripMaskVScale) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetStripMaskVScale");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetStripMaskVScale) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetStripMaskVScale");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVScale, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVScale::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVScale, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVScale::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVScale, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVScale::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetStripMaskVSpeed
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetStripMaskVSpeed final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetStripMaskVSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetStripMaskVSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVSpeed::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVSpeed::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetStripMaskVSpeed, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetStripMaskVSpeed::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureColorTint
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureColorTint final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureColorTint) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureColorTint) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureColorTint, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureColorTint::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureColorTint, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureColorTint::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureColorTint, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureColorTint::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureLowerLimit
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureLowerLimit final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureLowerLimit");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureLowerLimit");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureLowerLimit::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureLowerLimit::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureLowerLimit, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureLowerLimit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureScaleAndOffset
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureScaleAndOffset::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureSpeed
// 0x0018 (0x0018 - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureSpeed final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureSpeed) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureSpeed) == 0x000018, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureSpeed, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureSpeed::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureSpeed, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureSpeed::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureSpeed, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureSpeed::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureStrength
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureStrength final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureStrength) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureStrength");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureStrength) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureStrength");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureStrength, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureStrength::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureStrength, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureStrength::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureStrength, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureStrength::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.GetTextureUpperLimit
// 0x000C (0x000C - 0x0000)
struct KuroCharacterMaterialControllerCache_GetTextureUpperLimit final
{
public:
	float                                         Factor;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit) == 0x000004, "Wrong alignment on KuroCharacterMaterialControllerCache_GetTextureUpperLimit");
static_assert(sizeof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit) == 0x00000C, "Wrong size on KuroCharacterMaterialControllerCache_GetTextureUpperLimit");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit, Factor) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_GetTextureUpperLimit::Factor' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit, Type) == 0x000004, "Member 'KuroCharacterMaterialControllerCache_GetTextureUpperLimit::Type' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_GetTextureUpperLimit, ReturnValue) == 0x000008, "Member 'KuroCharacterMaterialControllerCache_GetTextureUpperLimit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetBaseColorTint
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetBaseColorTint final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetBaseColorTint) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetBaseColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetBaseColorTint) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetBaseColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseColorTint, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetBaseColorTint::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseColorTint, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetBaseColorTint::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseColorTint, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetBaseColorTint::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetBaseRefine
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetBaseRefine final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetBaseRefine) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetBaseRefine");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetBaseRefine) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetBaseRefine");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseRefine, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetBaseRefine::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseRefine, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetBaseRefine::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetBaseRefine, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetBaseRefine::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetCustomColorParametersValue
// 0x0030 (0x0030 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetCustomColorParametersValue final
{
public:
	TArray<struct FKuroCurveLinearColor>          Start;                                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          Loop;                                              // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          End;                                               // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetCustomColorParametersValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue) == 0x000030, "Wrong size on KuroCharacterMaterialControllerCache_SetCustomColorParametersValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetCustomColorParametersValue::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue, Loop) == 0x000010, "Member 'KuroCharacterMaterialControllerCache_SetCustomColorParametersValue::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomColorParametersValue, End) == 0x000020, "Member 'KuroCharacterMaterialControllerCache_SetCustomColorParametersValue::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetCustomFloatParametersValue
// 0x0030 (0x0030 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue final
{
public:
	TArray<struct FKuroCurveFloat>                Start;                                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                Loop;                                              // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                End;                                               // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue) == 0x000030, "Wrong size on KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue, Loop) == 0x000010, "Member 'KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue, End) == 0x000020, "Member 'KuroCharacterMaterialControllerCache_SetCustomFloatParametersValue::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDissolveColor
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDissolveColor final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDissolveColor) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDissolveColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDissolveColor) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetDissolveColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColor, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColor::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColor, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColor::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColor, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColor::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDissolveColorIntensity
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDissolveColorIntensity final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDissolveColorIntensity");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetDissolveColorIntensity");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColorIntensity::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColorIntensity::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveColorIntensity, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetDissolveColorIntensity::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDissolveProgress
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDissolveProgress final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDissolveProgress) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDissolveProgress");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDissolveProgress) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetDissolveProgress");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveProgress, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDissolveProgress::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveProgress, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetDissolveProgress::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveProgress, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetDissolveProgress::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDissolveSmooth
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDissolveSmooth final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDissolveSmooth) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDissolveSmooth");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDissolveSmooth) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetDissolveSmooth");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveSmooth, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDissolveSmooth::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveSmooth, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetDissolveSmooth::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDissolveSmooth, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetDissolveSmooth::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetDitherValue
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetDitherValue final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetDitherValue) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetDitherValue");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetDitherValue) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetDitherValue");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDitherValue, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetDitherValue::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDitherValue, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetDitherValue::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetDitherValue, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetDitherValue::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetEmissionColor
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetEmissionColor final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetEmissionColor) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetEmissionColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetEmissionColor) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetEmissionColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionColor, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetEmissionColor::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionColor, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetEmissionColor::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionColor, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetEmissionColor::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetEmissionIntensity
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetEmissionIntensity final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetEmissionIntensity) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetEmissionIntensity");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetEmissionIntensity) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetEmissionIntensity");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionIntensity, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetEmissionIntensity::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionIntensity, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetEmissionIntensity::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetEmissionIntensity, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetEmissionIntensity::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetHairDisplaceContrast
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetHairDisplaceContrast final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetHairDisplaceContrast");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetHairDisplaceContrast");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceContrast::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceContrast::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceContrast, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceContrast::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetHairDisplaceProgress
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetHairDisplaceProgress final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetHairDisplaceProgress");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetHairDisplaceProgress");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceProgress::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceProgress::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetHairDisplaceProgress, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetHairDisplaceProgress::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetMainTexColorTint
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetMainTexColorTint final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetMainTexColorTint) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetMainTexColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetMainTexColorTint) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetMainTexColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMainTexColorTint, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetMainTexColorTint::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMainTexColorTint, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetMainTexColorTint::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMainTexColorTint, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetMainTexColorTint::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetMotionColorEnd
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetMotionColorEnd final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetMotionColorEnd) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetMotionColorEnd");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetMotionColorEnd) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetMotionColorEnd");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorEnd, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorEnd::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorEnd, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorEnd::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorEnd, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorEnd::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetMotionColorStart
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetMotionColorStart final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetMotionColorStart) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetMotionColorStart");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetMotionColorStart) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetMotionColorStart");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorStart, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorStart::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorStart, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorStart::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionColorStart, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetMotionColorStart::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetMotionNoiseSpeed
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetMotionNoiseSpeed::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetOutlineColor
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetOutlineColor final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetOutlineColor) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetOutlineColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetOutlineColor) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetOutlineColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineColor, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetOutlineColor::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineColor, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetOutlineColor::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineColor, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetOutlineColor::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetOutlineWidth
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetOutlineWidth final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetOutlineWidth) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetOutlineWidth");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetOutlineWidth) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetOutlineWidth");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineWidth, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetOutlineWidth::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineWidth, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetOutlineWidth::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetOutlineWidth, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetOutlineWidth::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetRimColor
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetRimColor final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetRimColor) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetRimColor");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetRimColor) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetRimColor");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimColor, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetRimColor::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimColor, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetRimColor::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimColor, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetRimColor::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetRimRange
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetRimRange final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetRimRange) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetRimRange");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetRimRange) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetRimRange");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimRange, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetRimRange::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimRange, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetRimRange::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRimRange, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetRimRange::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetRotation
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetRotation final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetRotation) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetRotation");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetRotation) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetRotation");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRotation, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetRotation::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRotation, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetRotation::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetRotation, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetRotation::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetStripMaskProportion
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetStripMaskProportion final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetStripMaskProportion) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetStripMaskProportion");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetStripMaskProportion) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetStripMaskProportion");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskProportion, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskProportion::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskProportion, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskProportion::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskProportion, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskProportion::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetStripMaskVScale
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetStripMaskVScale final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetStripMaskVScale) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetStripMaskVScale");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetStripMaskVScale) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetStripMaskVScale");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVScale, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVScale::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVScale, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVScale::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVScale, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVScale::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetStripMaskVSpeed
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetStripMaskVSpeed final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetStripMaskVSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetStripMaskVSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVSpeed::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVSpeed::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetStripMaskVSpeed, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetStripMaskVSpeed::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureColorTint
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureColorTint final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureColorTint) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureColorTint");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureColorTint) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureColorTint");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureColorTint, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureColorTint::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureColorTint, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetTextureColorTint::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureColorTint, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetTextureColorTint::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureLowerLimit
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureLowerLimit final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureLowerLimit");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureLowerLimit");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureLowerLimit::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetTextureLowerLimit::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureLowerLimit, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetTextureLowerLimit::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureScaleAndOffset
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetTextureScaleAndOffset::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureSpeed
// 0x0660 (0x0660 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureSpeed final
{
public:
	struct FKuroCurveLinearColor                  Start;                                             // 0x0000(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0220(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0440(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureSpeed) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureSpeed");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureSpeed) == 0x000660, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureSpeed");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureSpeed, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureSpeed::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureSpeed, Loop) == 0x000220, "Member 'KuroCharacterMaterialControllerCache_SetTextureSpeed::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureSpeed, End) == 0x000440, "Member 'KuroCharacterMaterialControllerCache_SetTextureSpeed::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureStrength
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureStrength final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureStrength) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureStrength");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureStrength) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureStrength");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureStrength, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureStrength::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureStrength, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetTextureStrength::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureStrength, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetTextureStrength::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroCharacterMaterialControllerCache.SetTextureUpperLimit
// 0x01B0 (0x01B0 - 0x0000)
struct KuroCharacterMaterialControllerCache_SetTextureUpperLimit final
{
public:
	struct FKuroCurveFloat                        Start;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0090(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x0120(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit) == 0x000008, "Wrong alignment on KuroCharacterMaterialControllerCache_SetTextureUpperLimit");
static_assert(sizeof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit) == 0x0001B0, "Wrong size on KuroCharacterMaterialControllerCache_SetTextureUpperLimit");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit, Start) == 0x000000, "Member 'KuroCharacterMaterialControllerCache_SetTextureUpperLimit::Start' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit, Loop) == 0x000090, "Member 'KuroCharacterMaterialControllerCache_SetTextureUpperLimit::Loop' has a wrong offset!");
static_assert(offsetof(KuroCharacterMaterialControllerCache_SetTextureUpperLimit, End) == 0x000120, "Member 'KuroCharacterMaterialControllerCache_SetTextureUpperLimit::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEditorTickActor.EditorTick
// 0x0004 (0x0004 - 0x0000)
struct KuroEditorTickActor_EditorTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEditorTickActor_EditorTick) == 0x000004, "Wrong alignment on KuroEditorTickActor_EditorTick");
static_assert(sizeof(KuroEditorTickActor_EditorTick) == 0x000004, "Wrong size on KuroEditorTickActor_EditorTick");
static_assert(offsetof(KuroEditorTickActor_EditorTick, DeltaSeconds) == 0x000000, "Member 'KuroEditorTickActor_EditorTick::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEditorTickActor.EditorSetActorComponentsTickEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroEditorTickActor_EditorSetActorComponentsTickEnabled final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEditorTickActor_EditorSetActorComponentsTickEnabled) == 0x000001, "Wrong alignment on KuroEditorTickActor_EditorSetActorComponentsTickEnabled");
static_assert(sizeof(KuroEditorTickActor_EditorSetActorComponentsTickEnabled) == 0x000001, "Wrong size on KuroEditorTickActor_EditorSetActorComponentsTickEnabled");
static_assert(offsetof(KuroEditorTickActor_EditorSetActorComponentsTickEnabled, bValue) == 0x000000, "Member 'KuroEditorTickActor_EditorSetActorComponentsTickEnabled::bValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEffectActor.DoHiddenInGame
// 0x0001 (0x0001 - 0x0000)
struct KuroEffectActor_DoHiddenInGame final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectActor_DoHiddenInGame) == 0x000001, "Wrong alignment on KuroEffectActor_DoHiddenInGame");
static_assert(sizeof(KuroEffectActor_DoHiddenInGame) == 0x000001, "Wrong size on KuroEffectActor_DoHiddenInGame");
static_assert(offsetof(KuroEffectActor_DoHiddenInGame, bValue) == 0x000000, "Member 'KuroEffectActor_DoHiddenInGame::bValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEffectActor.EditorTick
// 0x0004 (0x0004 - 0x0000)
struct KuroEffectActor_EditorTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectActor_EditorTick) == 0x000004, "Wrong alignment on KuroEffectActor_EditorTick");
static_assert(sizeof(KuroEffectActor_EditorTick) == 0x000004, "Wrong size on KuroEffectActor_EditorTick");
static_assert(offsetof(KuroEffectActor_EditorTick, DeltaSeconds) == 0x000000, "Member 'KuroEffectActor_EditorTick::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroEffectActor.EditorSetActorComponentsTickEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroEffectActor_EditorSetActorComponentsTickEnabled final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroEffectActor_EditorSetActorComponentsTickEnabled) == 0x000001, "Wrong alignment on KuroEffectActor_EditorSetActorComponentsTickEnabled");
static_assert(sizeof(KuroEffectActor_EditorSetActorComponentsTickEnabled) == 0x000001, "Wrong size on KuroEffectActor_EditorSetActorComponentsTickEnabled");
static_assert(offsetof(KuroEffectActor_EditorSetActorComponentsTickEnabled, bValue) == 0x000000, "Member 'KuroEffectActor_EditorSetActorComponentsTickEnabled::bValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLandscapeParametersData.SetLandscapeMaterialLayerParameters
// 0x0010 (0x0010 - 0x0000)
struct KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters final
{
public:
	class UWorld*                                 World;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_188E[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters) == 0x000008, "Wrong alignment on KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters");
static_assert(sizeof(KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters) == 0x000010, "Wrong size on KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters");
static_assert(offsetof(KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters, World) == 0x000000, "Member 'KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters::World' has a wrong offset!");
static_assert(offsetof(KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters, ReturnValue) == 0x000008, "Member 'KuroLandscapeParametersData_SetLandscapeMaterialLayerParameters::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.GetKuroGISystem
// 0x0010 (0x0010 - 0x0000)
struct KuroGISystem_GetKuroGISystem final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroGISystem*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_GetKuroGISystem) == 0x000008, "Wrong alignment on KuroGISystem_GetKuroGISystem");
static_assert(sizeof(KuroGISystem_GetKuroGISystem) == 0x000010, "Wrong size on KuroGISystem_GetKuroGISystem");
static_assert(offsetof(KuroGISystem_GetKuroGISystem, InWorld) == 0x000000, "Member 'KuroGISystem_GetKuroGISystem::InWorld' has a wrong offset!");
static_assert(offsetof(KuroGISystem_GetKuroGISystem, ReturnValue) == 0x000008, "Member 'KuroGISystem_GetKuroGISystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.End3DUISceneRendering
// 0x0001 (0x0001 - 0x0000)
struct KuroGISystem_End3DUISceneRendering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_End3DUISceneRendering) == 0x000001, "Wrong alignment on KuroGISystem_End3DUISceneRendering");
static_assert(sizeof(KuroGISystem_End3DUISceneRendering) == 0x000001, "Wrong size on KuroGISystem_End3DUISceneRendering");
static_assert(offsetof(KuroGISystem_End3DUISceneRendering, ReturnValue) == 0x000000, "Member 'KuroGISystem_End3DUISceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.GetKuroGlobalGIActor
// 0x0008 (0x0008 - 0x0000)
struct KuroGISystem_GetKuroGlobalGIActor final
{
public:
	class AKuroGlobalGI*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_GetKuroGlobalGIActor) == 0x000008, "Wrong alignment on KuroGISystem_GetKuroGlobalGIActor");
static_assert(sizeof(KuroGISystem_GetKuroGlobalGIActor) == 0x000008, "Wrong size on KuroGISystem_GetKuroGlobalGIActor");
static_assert(offsetof(KuroGISystem_GetKuroGlobalGIActor, ReturnValue) == 0x000000, "Member 'KuroGISystem_GetKuroGlobalGIActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.IsLastTickGIActor
// 0x0010 (0x0010 - 0x0000)
struct KuroGISystem_IsLastTickGIActor final
{
public:
	class AKuroGlobalGI*                          Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1894[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGISystem_IsLastTickGIActor) == 0x000008, "Wrong alignment on KuroGISystem_IsLastTickGIActor");
static_assert(sizeof(KuroGISystem_IsLastTickGIActor) == 0x000010, "Wrong size on KuroGISystem_IsLastTickGIActor");
static_assert(offsetof(KuroGISystem_IsLastTickGIActor, Actor) == 0x000000, "Member 'KuroGISystem_IsLastTickGIActor::Actor' has a wrong offset!");
static_assert(offsetof(KuroGISystem_IsLastTickGIActor, ReturnValue) == 0x000008, "Member 'KuroGISystem_IsLastTickGIActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.IsUISceneRendering
// 0x0001 (0x0001 - 0x0000)
struct KuroGISystem_IsUISceneRendering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_IsUISceneRendering) == 0x000001, "Wrong alignment on KuroGISystem_IsUISceneRendering");
static_assert(sizeof(KuroGISystem_IsUISceneRendering) == 0x000001, "Wrong size on KuroGISystem_IsUISceneRendering");
static_assert(offsetof(KuroGISystem_IsUISceneRendering, ReturnValue) == 0x000000, "Member 'KuroGISystem_IsUISceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.Start3DUISceneRendering
// 0x0018 (0x0018 - 0x0000)
struct KuroGISystem_Start3DUISceneRendering final
{
public:
	class FString                                 InLevelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1895[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGISystem_Start3DUISceneRendering) == 0x000008, "Wrong alignment on KuroGISystem_Start3DUISceneRendering");
static_assert(sizeof(KuroGISystem_Start3DUISceneRendering) == 0x000018, "Wrong size on KuroGISystem_Start3DUISceneRendering");
static_assert(offsetof(KuroGISystem_Start3DUISceneRendering, InLevelName) == 0x000000, "Member 'KuroGISystem_Start3DUISceneRendering::InLevelName' has a wrong offset!");
static_assert(offsetof(KuroGISystem_Start3DUISceneRendering, ReturnValue) == 0x000010, "Member 'KuroGISystem_Start3DUISceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGISystem.GetUISceneRenderingState
// 0x0001 (0x0001 - 0x0000)
struct KuroGISystem_GetUISceneRenderingState final
{
public:
	EKuroUI3DState                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGISystem_GetUISceneRenderingState) == 0x000001, "Wrong alignment on KuroGISystem_GetUISceneRenderingState");
static_assert(sizeof(KuroGISystem_GetUISceneRenderingState) == 0x000001, "Wrong size on KuroGISystem_GetUISceneRenderingState");
static_assert(offsetof(KuroGISystem_GetUISceneRenderingState, ReturnValue) == 0x000000, "Member 'KuroGISystem_GetUISceneRenderingState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalColorMapComponent.UpdateColorMap
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalColorMapComponent_UpdateColorMap final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1897[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalColorMapComponent_UpdateColorMap) == 0x000008, "Wrong alignment on KuroGlobalColorMapComponent_UpdateColorMap");
static_assert(sizeof(KuroGlobalColorMapComponent_UpdateColorMap) == 0x000018, "Wrong size on KuroGlobalColorMapComponent_UpdateColorMap");
static_assert(offsetof(KuroGlobalColorMapComponent_UpdateColorMap, WorldContextObject) == 0x000000, "Member 'KuroGlobalColorMapComponent_UpdateColorMap::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalColorMapComponent_UpdateColorMap, ViewLocation) == 0x000008, "Member 'KuroGlobalColorMapComponent_UpdateColorMap::ViewLocation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplayShadowTintRampOffset
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_ApplayShadowTintRampOffset final
{
public:
	class USkyLightComponent*                     SkyLight;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplayShadowTintRampOffset) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplayShadowTintRampOffset");
static_assert(sizeof(KuroGlobalGI_ApplayShadowTintRampOffset) == 0x000008, "Wrong size on KuroGlobalGI_ApplayShadowTintRampOffset");
static_assert(offsetof(KuroGlobalGI_ApplayShadowTintRampOffset, SkyLight) == 0x000000, "Member 'KuroGlobalGI_ApplayShadowTintRampOffset::SkyLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.Apply3DUISceneSkyLight
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_Apply3DUISceneSkyLight final
{
public:
	class USkyLightComponent*                     SkyLight;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_Apply3DUISceneSkyLight) == 0x000008, "Wrong alignment on KuroGlobalGI_Apply3DUISceneSkyLight");
static_assert(sizeof(KuroGlobalGI_Apply3DUISceneSkyLight) == 0x000008, "Wrong size on KuroGlobalGI_Apply3DUISceneSkyLight");
static_assert(offsetof(KuroGlobalGI_Apply3DUISceneSkyLight, SkyLight) == 0x000000, "Member 'KuroGlobalGI_Apply3DUISceneSkyLight::SkyLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyAndUpdateDayNightDataLayer
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_ApplyAndUpdateDayNightDataLayer final
{
public:
	float                                         TimeOfDay;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TODLightLoadingWait;                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyAndUpdateDayNightDataLayer) == 0x000004, "Wrong alignment on KuroGlobalGI_ApplyAndUpdateDayNightDataLayer");
static_assert(sizeof(KuroGlobalGI_ApplyAndUpdateDayNightDataLayer) == 0x000008, "Wrong size on KuroGlobalGI_ApplyAndUpdateDayNightDataLayer");
static_assert(offsetof(KuroGlobalGI_ApplyAndUpdateDayNightDataLayer, TimeOfDay) == 0x000000, "Member 'KuroGlobalGI_ApplyAndUpdateDayNightDataLayer::TimeOfDay' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyAndUpdateDayNightDataLayer, TODLightLoadingWait) == 0x000004, "Member 'KuroGlobalGI_ApplyAndUpdateDayNightDataLayer::TODLightLoadingWait' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyGlobalGIRenderQuality
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_ApplyGlobalGIRenderQuality final
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyGlobalGIRenderQuality) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyGlobalGIRenderQuality");
static_assert(sizeof(KuroGlobalGI_ApplyGlobalGIRenderQuality) == 0x000008, "Wrong size on KuroGlobalGI_ApplyGlobalGIRenderQuality");
static_assert(offsetof(KuroGlobalGI_ApplyGlobalGIRenderQuality, DynamicMaterial) == 0x000000, "Member 'KuroGlobalGI_ApplyGlobalGIRenderQuality::DynamicMaterial' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyKuroSkyLight
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_ApplyKuroSkyLight final
{
public:
	class USkyLightComponent*                     SkyLight;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfDay;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultShadowSupplement;                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultReflectionAddIntensity;                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A3[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_ApplyKuroSkyLight) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyKuroSkyLight");
static_assert(sizeof(KuroGlobalGI_ApplyKuroSkyLight) == 0x000018, "Wrong size on KuroGlobalGI_ApplyKuroSkyLight");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, SkyLight) == 0x000000, "Member 'KuroGlobalGI_ApplyKuroSkyLight::SkyLight' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, TimeOfDay) == 0x000008, "Member 'KuroGlobalGI_ApplyKuroSkyLight::TimeOfDay' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, DefaultShadowSupplement) == 0x00000C, "Member 'KuroGlobalGI_ApplyKuroSkyLight::DefaultShadowSupplement' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyKuroSkyLight, DefaultReflectionAddIntensity) == 0x000010, "Member 'KuroGlobalGI_ApplyKuroSkyLight::DefaultReflectionAddIntensity' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLensflare
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_ApplyLensflare final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SunForward;                                        // 0x0004(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyLensflare) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLensflare");
static_assert(sizeof(KuroGlobalGI_ApplyLensflare) == 0x000018, "Wrong size on KuroGlobalGI_ApplyLensflare");
static_assert(offsetof(KuroGlobalGI_ApplyLensflare, DeltaTime) == 0x000000, "Member 'KuroGlobalGI_ApplyLensflare::DeltaTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLensflare, SunForward) == 0x000004, "Member 'KuroGlobalGI_ApplyLensflare::SunForward' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLensflare, Collection) == 0x000010, "Member 'KuroGlobalGI_ApplyLensflare::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLightFunctionSetting
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplyLightFunctionSetting final
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               DefaultLightFucntionTexture;                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyLightFunctionSetting) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLightFunctionSetting");
static_assert(sizeof(KuroGlobalGI_ApplyLightFunctionSetting) == 0x000010, "Wrong size on KuroGlobalGI_ApplyLightFunctionSetting");
static_assert(offsetof(KuroGlobalGI_ApplyLightFunctionSetting, DynamicMaterial) == 0x000000, "Member 'KuroGlobalGI_ApplyLightFunctionSetting::DynamicMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightFunctionSetting, DefaultLightFucntionTexture) == 0x000008, "Member 'KuroGlobalGI_ApplyLightFunctionSetting::DefaultLightFucntionTexture' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyMilkyWayParameters
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplyMilkyWayParameters final
{
public:
	class UMaterialInstance*                      MilkyWayMaterial;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MilkyWayMeshComponent;                             // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyMilkyWayParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyMilkyWayParameters");
static_assert(sizeof(KuroGlobalGI_ApplyMilkyWayParameters) == 0x000010, "Wrong size on KuroGlobalGI_ApplyMilkyWayParameters");
static_assert(offsetof(KuroGlobalGI_ApplyMilkyWayParameters, MilkyWayMaterial) == 0x000000, "Member 'KuroGlobalGI_ApplyMilkyWayParameters::MilkyWayMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyMilkyWayParameters, MilkyWayMeshComponent) == 0x000008, "Member 'KuroGlobalGI_ApplyMilkyWayParameters::MilkyWayMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplySkyBoxSetting
// 0x0020 (0x0020 - 0x0000)
struct KuroGlobalGI_ApplySkyBoxSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      SkyBoxMaterial;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   SkyBoxMeshComponent;                               // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplySkyBoxSetting) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplySkyBoxSetting");
static_assert(sizeof(KuroGlobalGI_ApplySkyBoxSetting) == 0x000020, "Wrong size on KuroGlobalGI_ApplySkyBoxSetting");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplySkyBoxSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplySkyBoxSetting::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, SkyBoxMaterial) == 0x000010, "Member 'KuroGlobalGI_ApplySkyBoxSetting::SkyBoxMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyBoxSetting, SkyBoxMeshComponent) == 0x000018, "Member 'KuroGlobalGI_ApplySkyBoxSetting::SkyBoxMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyStarsParameters
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplyStarsParameters final
{
public:
	class UMaterialInstance*                      StarMaterial;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StarMeshComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyStarsParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyStarsParameters");
static_assert(sizeof(KuroGlobalGI_ApplyStarsParameters) == 0x000010, "Wrong size on KuroGlobalGI_ApplyStarsParameters");
static_assert(offsetof(KuroGlobalGI_ApplyStarsParameters, StarMaterial) == 0x000000, "Member 'KuroGlobalGI_ApplyStarsParameters::StarMaterial' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyStarsParameters, StarMeshComponent) == 0x000008, "Member 'KuroGlobalGI_ApplyStarsParameters::StarMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.CalLightDirectionWithLimit
// 0x0014 (0x0014 - 0x0000)
struct KuroGlobalGI_CalLightDirectionWithLimit final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightAngleLimit;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LightRotation;                                     // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_CalLightDirectionWithLimit) == 0x000004, "Wrong alignment on KuroGlobalGI_CalLightDirectionWithLimit");
static_assert(sizeof(KuroGlobalGI_CalLightDirectionWithLimit) == 0x000014, "Wrong size on KuroGlobalGI_CalLightDirectionWithLimit");
static_assert(offsetof(KuroGlobalGI_CalLightDirectionWithLimit, Time) == 0x000000, "Member 'KuroGlobalGI_CalLightDirectionWithLimit::Time' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalLightDirectionWithLimit, LightAngleLimit) == 0x000004, "Member 'KuroGlobalGI_CalLightDirectionWithLimit::LightAngleLimit' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalLightDirectionWithLimit, LightRotation) == 0x000008, "Member 'KuroGlobalGI_CalLightDirectionWithLimit::LightRotation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.GetCachedGISystem
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_GetCachedGISystem final
{
public:
	class UKuroGISystem*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_GetCachedGISystem) == 0x000008, "Wrong alignment on KuroGlobalGI_GetCachedGISystem");
static_assert(sizeof(KuroGlobalGI_GetCachedGISystem) == 0x000008, "Wrong size on KuroGlobalGI_GetCachedGISystem");
static_assert(offsetof(KuroGlobalGI_GetCachedGISystem, ReturnValue) == 0x000000, "Member 'KuroGlobalGI_GetCachedGISystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.GetGITime
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_GetGITime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_GetGITime) == 0x000004, "Wrong alignment on KuroGlobalGI_GetGITime");
static_assert(sizeof(KuroGlobalGI_GetGITime) == 0x000004, "Wrong size on KuroGlobalGI_GetGITime");
static_assert(offsetof(KuroGlobalGI_GetGITime, ReturnValue) == 0x000000, "Member 'KuroGlobalGI_GetGITime::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroSetRuntimeTime
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_OnKuroSetRuntimeTime final
{
public:
	float                                         CurrentTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroSetRuntimeTime) == 0x000004, "Wrong alignment on KuroGlobalGI_OnKuroSetRuntimeTime");
static_assert(sizeof(KuroGlobalGI_OnKuroSetRuntimeTime) == 0x000004, "Wrong size on KuroGlobalGI_OnKuroSetRuntimeTime");
static_assert(offsetof(KuroGlobalGI_OnKuroSetRuntimeTime, CurrentTime) == 0x000000, "Member 'KuroGlobalGI_OnKuroSetRuntimeTime::CurrentTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroStartUI
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_OnKuroStartUI final
{
public:
	class FString                                 InName;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 InUILevel;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroStartUI) == 0x000008, "Wrong alignment on KuroGlobalGI_OnKuroStartUI");
static_assert(sizeof(KuroGlobalGI_OnKuroStartUI) == 0x000018, "Wrong size on KuroGlobalGI_OnKuroStartUI");
static_assert(offsetof(KuroGlobalGI_OnKuroStartUI, InName) == 0x000000, "Member 'KuroGlobalGI_OnKuroStartUI::InName' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_OnKuroStartUI, InUILevel) == 0x000010, "Member 'KuroGlobalGI_OnKuroStartUI::InUILevel' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroStartUiScene
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_OnKuroStartUiScene final
{
public:
	class FString                                 InName;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 InUILevel;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroStartUiScene) == 0x000008, "Wrong alignment on KuroGlobalGI_OnKuroStartUiScene");
static_assert(sizeof(KuroGlobalGI_OnKuroStartUiScene) == 0x000018, "Wrong size on KuroGlobalGI_OnKuroStartUiScene");
static_assert(offsetof(KuroGlobalGI_OnKuroStartUiScene, InName) == 0x000000, "Member 'KuroGlobalGI_OnKuroStartUiScene::InName' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_OnKuroStartUiScene, InUILevel) == 0x000010, "Member 'KuroGlobalGI_OnKuroStartUiScene::InUILevel' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroTick
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_OnKuroTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroTick) == 0x000004, "Wrong alignment on KuroGlobalGI_OnKuroTick");
static_assert(sizeof(KuroGlobalGI_OnKuroTick) == 0x000004, "Wrong size on KuroGlobalGI_OnKuroTick");
static_assert(offsetof(KuroGlobalGI_OnKuroTick, DeltaTime) == 0x000000, "Member 'KuroGlobalGI_OnKuroTick::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.OnKuroTickEditor
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_OnKuroTickEditor final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_OnKuroTickEditor) == 0x000004, "Wrong alignment on KuroGlobalGI_OnKuroTickEditor");
static_assert(sizeof(KuroGlobalGI_OnKuroTickEditor) == 0x000004, "Wrong size on KuroGlobalGI_OnKuroTickEditor");
static_assert(offsetof(KuroGlobalGI_OnKuroTickEditor, DeltaTime) == 0x000000, "Member 'KuroGlobalGI_OnKuroTickEditor::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.SetGITime
// 0x0004 (0x0004 - 0x0000)
struct KuroGlobalGI_SetGITime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_SetGITime) == 0x000004, "Wrong alignment on KuroGlobalGI_SetGITime");
static_assert(sizeof(KuroGlobalGI_SetGITime) == 0x000004, "Wrong size on KuroGlobalGI_SetGITime");
static_assert(offsetof(KuroGlobalGI_SetGITime, Time) == 0x000000, "Member 'KuroGlobalGI_SetGITime::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.SetSunLensflareEnabled
// 0x0001 (0x0001 - 0x0000)
struct KuroGlobalGI_SetSunLensflareEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_SetSunLensflareEnabled) == 0x000001, "Wrong alignment on KuroGlobalGI_SetSunLensflareEnabled");
static_assert(sizeof(KuroGlobalGI_SetSunLensflareEnabled) == 0x000001, "Wrong size on KuroGlobalGI_SetSunLensflareEnabled");
static_assert(offsetof(KuroGlobalGI_SetSunLensflareEnabled, bEnable) == 0x000000, "Member 'KuroGlobalGI_SetSunLensflareEnabled::bEnable' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.SetupSceneRain
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_SetupSceneRain final
{
public:
	class UKuroSceneRainEmitterConfig*            FrontRainConfig;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroSceneRainEmitterConfig*            BackRainConfig;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_SetupSceneRain) == 0x000008, "Wrong alignment on KuroGlobalGI_SetupSceneRain");
static_assert(sizeof(KuroGlobalGI_SetupSceneRain) == 0x000010, "Wrong size on KuroGlobalGI_SetupSceneRain");
static_assert(offsetof(KuroGlobalGI_SetupSceneRain, FrontRainConfig) == 0x000000, "Member 'KuroGlobalGI_SetupSceneRain::FrontRainConfig' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_SetupSceneRain, BackRainConfig) == 0x000008, "Member 'KuroGlobalGI_SetupSceneRain::BackRainConfig' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateAndApplyWeather
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_UpdateAndApplyWeather final
{
public:
	class AKuroRainActor*                         RainActor;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKuroRainActor*                         SnowActor;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             HeightTexture;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateAndApplyWeather) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateAndApplyWeather");
static_assert(sizeof(KuroGlobalGI_UpdateAndApplyWeather) == 0x000018, "Wrong size on KuroGlobalGI_UpdateAndApplyWeather");
static_assert(offsetof(KuroGlobalGI_UpdateAndApplyWeather, RainActor) == 0x000000, "Member 'KuroGlobalGI_UpdateAndApplyWeather::RainActor' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateAndApplyWeather, SnowActor) == 0x000008, "Member 'KuroGlobalGI_UpdateAndApplyWeather::SnowActor' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateAndApplyWeather, HeightTexture) == 0x000010, "Member 'KuroGlobalGI_UpdateAndApplyWeather::HeightTexture' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateAndApplyWind
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_UpdateAndApplyWind final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateAndApplyWind) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateAndApplyWind");
static_assert(sizeof(KuroGlobalGI_UpdateAndApplyWind) == 0x000010, "Wrong size on KuroGlobalGI_UpdateAndApplyWind");
static_assert(offsetof(KuroGlobalGI_UpdateAndApplyWind, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateAndApplyWind::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateAndApplyWind, Collection) == 0x000008, "Member 'KuroGlobalGI_UpdateAndApplyWind::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateCharLightHorizontal
// 0x0030 (0x0030 - 0x0000)
struct KuroGlobalGI_UpdateCharLightHorizontal final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SceneLightRot;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A4[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           Collection;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugCharLightHorizontal;                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A5[0x3];                                     // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugCharLightHorizontal;                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugCharLightVertical;                            // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A6[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_UpdateCharLightHorizontal) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateCharLightHorizontal");
static_assert(sizeof(KuroGlobalGI_UpdateCharLightHorizontal) == 0x000030, "Wrong size on KuroGlobalGI_UpdateCharLightHorizontal");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, SceneLightRot) == 0x000008, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::SceneLightRot' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, Collection) == 0x000018, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, bDebugCharLightHorizontal) == 0x000020, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::bDebugCharLightHorizontal' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, DebugCharLightHorizontal) == 0x000024, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::DebugCharLightHorizontal' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateCharLightHorizontal, DebugCharLightVertical) == 0x000028, "Member 'KuroGlobalGI_UpdateCharLightHorizontal::DebugCharLightVertical' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateLightDirection
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_UpdateLightDirection final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             AtmoSunLight;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             AtmoMoonLight;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateLightDirection) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateLightDirection");
static_assert(sizeof(KuroGlobalGI_UpdateLightDirection) == 0x000018, "Wrong size on KuroGlobalGI_UpdateLightDirection");
static_assert(offsetof(KuroGlobalGI_UpdateLightDirection, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateLightDirection::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateLightDirection, AtmoSunLight) == 0x000008, "Member 'KuroGlobalGI_UpdateLightDirection::AtmoSunLight' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateLightDirection, AtmoMoonLight) == 0x000010, "Member 'KuroGlobalGI_UpdateLightDirection::AtmoMoonLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdatePostProcessSettingData
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_UpdatePostProcessSettingData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurTime;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipLerpData;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A7[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroGlobalGI_UpdatePostProcessSettingData) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdatePostProcessSettingData");
static_assert(sizeof(KuroGlobalGI_UpdatePostProcessSettingData) == 0x000010, "Wrong size on KuroGlobalGI_UpdatePostProcessSettingData");
static_assert(offsetof(KuroGlobalGI_UpdatePostProcessSettingData, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdatePostProcessSettingData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdatePostProcessSettingData, CurTime) == 0x000008, "Member 'KuroGlobalGI_UpdatePostProcessSettingData::CurTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdatePostProcessSettingData, bSkipLerpData) == 0x00000C, "Member 'KuroGlobalGI_UpdatePostProcessSettingData::bSkipLerpData' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.UpdateTODData
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_UpdateTODData final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSecnod;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_UpdateTODData) == 0x000008, "Wrong alignment on KuroGlobalGI_UpdateTODData");
static_assert(sizeof(KuroGlobalGI_UpdateTODData) == 0x000018, "Wrong size on KuroGlobalGI_UpdateTODData");
static_assert(offsetof(KuroGlobalGI_UpdateTODData, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_UpdateTODData::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateTODData, WorldPosition) == 0x000008, "Member 'KuroGlobalGI_UpdateTODData::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_UpdateTODData, TimeSecnod) == 0x000014, "Member 'KuroGlobalGI_UpdateTODData::TimeSecnod' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyCloudCardSetting
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplyCloudCardSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyCloudCardSetting) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyCloudCardSetting");
static_assert(sizeof(KuroGlobalGI_ApplyCloudCardSetting) == 0x000010, "Wrong size on KuroGlobalGI_ApplyCloudCardSetting");
static_assert(offsetof(KuroGlobalGI_ApplyCloudCardSetting, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyCloudCardSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyCloudCardSetting, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyCloudCardSetting::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyFog
// 0x0028 (0x0028 - 0x0000)
struct KuroGlobalGI_ApplyFog final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UExponentialHeightFogComponent*         HeightFog;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldZOffset;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A8[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   CloudOcean;                                        // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyFog) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyFog");
static_assert(sizeof(KuroGlobalGI_ApplyFog) == 0x000028, "Wrong size on KuroGlobalGI_ApplyFog");
static_assert(offsetof(KuroGlobalGI_ApplyFog, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyFog::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, HeightFog) == 0x000008, "Member 'KuroGlobalGI_ApplyFog::HeightFog' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, Collection) == 0x000010, "Member 'KuroGlobalGI_ApplyFog::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, WorldZOffset) == 0x000018, "Member 'KuroGlobalGI_ApplyFog::WorldZOffset' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyFog, CloudOcean) == 0x000020, "Member 'KuroGlobalGI_ApplyFog::CloudOcean' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyGlobalShaderParameters
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplyGlobalShaderParameters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyGlobalShaderParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyGlobalShaderParameters");
static_assert(sizeof(KuroGlobalGI_ApplyGlobalShaderParameters) == 0x000010, "Wrong size on KuroGlobalGI_ApplyGlobalShaderParameters");
static_assert(offsetof(KuroGlobalGI_ApplyGlobalShaderParameters, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyGlobalShaderParameters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyGlobalShaderParameters, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyGlobalShaderParameters::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLightParameters
// 0x0018 (0x0018 - 0x0000)
struct KuroGlobalGI_ApplyLightParameters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDirectionalLightComponent*             SceneLight;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyLightParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLightParameters");
static_assert(sizeof(KuroGlobalGI_ApplyLightParameters) == 0x000018, "Wrong size on KuroGlobalGI_ApplyLightParameters");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplyLightParameters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplyLightParameters::Collection' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplyLightParameters, SceneLight) == 0x000010, "Member 'KuroGlobalGI_ApplyLightParameters::SceneLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplyLightShaft
// 0x0008 (0x0008 - 0x0000)
struct KuroGlobalGI_ApplyLightShaft final
{
public:
	class UDirectionalLightComponent*             SceneLight;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplyLightShaft) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplyLightShaft");
static_assert(sizeof(KuroGlobalGI_ApplyLightShaft) == 0x000008, "Wrong size on KuroGlobalGI_ApplyLightShaft");
static_assert(offsetof(KuroGlobalGI_ApplyLightShaft, SceneLight) == 0x000000, "Member 'KuroGlobalGI_ApplyLightShaft::SceneLight' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.ApplySkyEffectsParameters
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_ApplySkyEffectsParameters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_ApplySkyEffectsParameters) == 0x000008, "Wrong alignment on KuroGlobalGI_ApplySkyEffectsParameters");
static_assert(sizeof(KuroGlobalGI_ApplySkyEffectsParameters) == 0x000010, "Wrong size on KuroGlobalGI_ApplySkyEffectsParameters");
static_assert(offsetof(KuroGlobalGI_ApplySkyEffectsParameters, WorldContextObject) == 0x000000, "Member 'KuroGlobalGI_ApplySkyEffectsParameters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_ApplySkyEffectsParameters, Collection) == 0x000008, "Member 'KuroGlobalGI_ApplySkyEffectsParameters::Collection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.CalcTODTimeFactor
// 0x0010 (0x0010 - 0x0000)
struct KuroGlobalGI_CalcTODTimeFactor final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrTime;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_CalcTODTimeFactor) == 0x000004, "Wrong alignment on KuroGlobalGI_CalcTODTimeFactor");
static_assert(sizeof(KuroGlobalGI_CalcTODTimeFactor) == 0x000010, "Wrong size on KuroGlobalGI_CalcTODTimeFactor");
static_assert(offsetof(KuroGlobalGI_CalcTODTimeFactor, StartTime) == 0x000000, "Member 'KuroGlobalGI_CalcTODTimeFactor::StartTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalcTODTimeFactor, EndTime) == 0x000004, "Member 'KuroGlobalGI_CalcTODTimeFactor::EndTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalcTODTimeFactor, CurrTime) == 0x000008, "Member 'KuroGlobalGI_CalcTODTimeFactor::CurrTime' has a wrong offset!");
static_assert(offsetof(KuroGlobalGI_CalcTODTimeFactor, ReturnValue) == 0x00000C, "Member 'KuroGlobalGI_CalcTODTimeFactor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGlobalGI.K2_IsInPersistentLevel
// 0x0001 (0x0001 - 0x0000)
struct KuroGlobalGI_K2_IsInPersistentLevel final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGlobalGI_K2_IsInPersistentLevel) == 0x000001, "Wrong alignment on KuroGlobalGI_K2_IsInPersistentLevel");
static_assert(sizeof(KuroGlobalGI_K2_IsInPersistentLevel) == 0x000001, "Wrong size on KuroGlobalGI_K2_IsInPersistentLevel");
static_assert(offsetof(KuroGlobalGI_K2_IsInPersistentLevel, ReturnValue) == 0x000000, "Member 'KuroGlobalGI_K2_IsInPersistentLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGPUParticleComponent.DoTick
// 0x0004 (0x0004 - 0x0000)
struct KuroGPUParticleComponent_DoTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGPUParticleComponent_DoTick) == 0x000004, "Wrong alignment on KuroGPUParticleComponent_DoTick");
static_assert(sizeof(KuroGPUParticleComponent_DoTick) == 0x000004, "Wrong size on KuroGPUParticleComponent_DoTick");
static_assert(offsetof(KuroGPUParticleComponent_DoTick, DeltaTime) == 0x000000, "Member 'KuroGPUParticleComponent_DoTick::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGPUParticleComponent.SetGPUData
// 0x0008 (0x0008 - 0x0000)
struct KuroGPUParticleComponent_SetGPUData final
{
public:
	class UKuroGPUParticleDA*                     TargetData;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGPUParticleComponent_SetGPUData) == 0x000008, "Wrong alignment on KuroGPUParticleComponent_SetGPUData");
static_assert(sizeof(KuroGPUParticleComponent_SetGPUData) == 0x000008, "Wrong size on KuroGPUParticleComponent_SetGPUData");
static_assert(offsetof(KuroGPUParticleComponent_SetGPUData, TargetData) == 0x000000, "Member 'KuroGPUParticleComponent_SetGPUData::TargetData' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGPUParticleComponent.SetupParticle
// 0x0004 (0x0004 - 0x0000)
struct KuroGPUParticleComponent_SetupParticle final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGPUParticleComponent_SetupParticle) == 0x000004, "Wrong alignment on KuroGPUParticleComponent_SetupParticle");
static_assert(sizeof(KuroGPUParticleComponent_SetupParticle) == 0x000004, "Wrong size on KuroGPUParticleComponent_SetupParticle");
static_assert(offsetof(KuroGPUParticleComponent_SetupParticle, DeltaTime) == 0x000000, "Member 'KuroGPUParticleComponent_SetupParticle::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroGPUParticleSubsystem.GetKuroGPUParticleSystem
// 0x0010 (0x0010 - 0x0000)
struct KuroGPUParticleSubsystem_GetKuroGPUParticleSystem final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroGPUParticleSubsystem*              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroGPUParticleSubsystem_GetKuroGPUParticleSystem) == 0x000008, "Wrong alignment on KuroGPUParticleSubsystem_GetKuroGPUParticleSystem");
static_assert(sizeof(KuroGPUParticleSubsystem_GetKuroGPUParticleSystem) == 0x000010, "Wrong size on KuroGPUParticleSubsystem_GetKuroGPUParticleSystem");
static_assert(offsetof(KuroGPUParticleSubsystem_GetKuroGPUParticleSystem, InWorld) == 0x000000, "Member 'KuroGPUParticleSubsystem_GetKuroGPUParticleSystem::InWorld' has a wrong offset!");
static_assert(offsetof(KuroGPUParticleSubsystem_GetKuroGPUParticleSystem, ReturnValue) == 0x000008, "Member 'KuroGPUParticleSubsystem_GetKuroGPUParticleSystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHaloComponent.SetRadius
// 0x0004 (0x0004 - 0x0000)
struct KuroHaloComponent_SetRadius final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHaloComponent_SetRadius) == 0x000004, "Wrong alignment on KuroHaloComponent_SetRadius");
static_assert(sizeof(KuroHaloComponent_SetRadius) == 0x000004, "Wrong size on KuroHaloComponent_SetRadius");
static_assert(offsetof(KuroHaloComponent_SetRadius, Radius) == 0x000000, "Member 'KuroHaloComponent_SetRadius::Radius' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroHaloComponent.GetLightRadius
// 0x0004 (0x0004 - 0x0000)
struct KuroHaloComponent_GetLightRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroHaloComponent_GetLightRadius) == 0x000004, "Wrong alignment on KuroHaloComponent_GetLightRadius");
static_assert(sizeof(KuroHaloComponent_GetLightRadius) == 0x000004, "Wrong size on KuroHaloComponent_GetLightRadius");
static_assert(offsetof(KuroHaloComponent_GetLightRadius, ReturnValue) == 0x000000, "Member 'KuroHaloComponent_GetLightRadius::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.GetViewportSize
// 0x0008 (0x0008 - 0x0000)
struct KuroLensFlare_GetViewportSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_GetViewportSize) == 0x000004, "Wrong alignment on KuroLensFlare_GetViewportSize");
static_assert(sizeof(KuroLensFlare_GetViewportSize) == 0x000008, "Wrong size on KuroLensFlare_GetViewportSize");
static_assert(offsetof(KuroLensFlare_GetViewportSize, ReturnValue) == 0x000000, "Member 'KuroLensFlare_GetViewportSize::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.Init
// 0x0008 (0x0008 - 0x0000)
struct KuroLensFlare_Init final
{
public:
	class UProceduralMeshComponent*               InputMeshComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_Init) == 0x000008, "Wrong alignment on KuroLensFlare_Init");
static_assert(sizeof(KuroLensFlare_Init) == 0x000008, "Wrong size on KuroLensFlare_Init");
static_assert(offsetof(KuroLensFlare_Init, InputMeshComponent) == 0x000000, "Member 'KuroLensFlare_Init::InputMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.InitVecticesData
// 0x0004 (0x0004 - 0x0000)
struct KuroLensFlare_InitVecticesData final
{
public:
	int32                                         LensImageLengths;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_InitVecticesData) == 0x000004, "Wrong alignment on KuroLensFlare_InitVecticesData");
static_assert(sizeof(KuroLensFlare_InitVecticesData) == 0x000004, "Wrong size on KuroLensFlare_InitVecticesData");
static_assert(offsetof(KuroLensFlare_InitVecticesData, LensImageLengths) == 0x000000, "Member 'KuroLensFlare_InitVecticesData::LensImageLengths' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.IsInit
// 0x0001 (0x0001 - 0x0000)
struct KuroLensFlare_IsInit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_IsInit) == 0x000001, "Wrong alignment on KuroLensFlare_IsInit");
static_assert(sizeof(KuroLensFlare_IsInit) == 0x000001, "Wrong size on KuroLensFlare_IsInit");
static_assert(offsetof(KuroLensFlare_IsInit, ReturnValue) == 0x000000, "Member 'KuroLensFlare_IsInit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.IsViewportEnable
// 0x0001 (0x0001 - 0x0000)
struct KuroLensFlare_IsViewportEnable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_IsViewportEnable) == 0x000001, "Wrong alignment on KuroLensFlare_IsViewportEnable");
static_assert(sizeof(KuroLensFlare_IsViewportEnable) == 0x000001, "Wrong size on KuroLensFlare_IsViewportEnable");
static_assert(offsetof(KuroLensFlare_IsViewportEnable, ReturnValue) == 0x000000, "Member 'KuroLensFlare_IsViewportEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLensFlare.SetVertsProperties
// 0x004C (0x004C - 0x0000)
struct KuroLensFlare_SetVertsProperties final
{
public:
	struct FVector2D                              ViewportScale;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimityIndex;                                      // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UVCenter;                                          // 0x000C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UVSize;                                            // 0x0014(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LensFlareScale;                                    // 0x001C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareOffset;                                   // 0x0024(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LensFlareRotation;                                 // 0x0028(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LensFlareTint;                                     // 0x002C(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LensFlareScreenPosition;                           // 0x003C(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LensFlareDirection;                                // 0x0044(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLensFlare_SetVertsProperties) == 0x000004, "Wrong alignment on KuroLensFlare_SetVertsProperties");
static_assert(sizeof(KuroLensFlare_SetVertsProperties) == 0x00004C, "Wrong size on KuroLensFlare_SetVertsProperties");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, ViewportScale) == 0x000000, "Member 'KuroLensFlare_SetVertsProperties::ViewportScale' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, PrimityIndex) == 0x000008, "Member 'KuroLensFlare_SetVertsProperties::PrimityIndex' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, UVCenter) == 0x00000C, "Member 'KuroLensFlare_SetVertsProperties::UVCenter' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, UVSize) == 0x000014, "Member 'KuroLensFlare_SetVertsProperties::UVSize' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareScale) == 0x00001C, "Member 'KuroLensFlare_SetVertsProperties::LensFlareScale' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareOffset) == 0x000024, "Member 'KuroLensFlare_SetVertsProperties::LensFlareOffset' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareRotation) == 0x000028, "Member 'KuroLensFlare_SetVertsProperties::LensFlareRotation' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareTint) == 0x00002C, "Member 'KuroLensFlare_SetVertsProperties::LensFlareTint' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareScreenPosition) == 0x00003C, "Member 'KuroLensFlare_SetVertsProperties::LensFlareScreenPosition' has a wrong offset!");
static_assert(offsetof(KuroLensFlare_SetVertsProperties, LensFlareDirection) == 0x000044, "Member 'KuroLensFlare_SetVertsProperties::LensFlareDirection' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLevelSequenceSubsystem.GetAllLevelSequences
// 0x0010 (0x0010 - 0x0000)
struct KuroLevelSequenceSubsystem_GetAllLevelSequences final
{
public:
	TArray<class AKuroLevelSequenceActor*>        InAllLevelSequences;                               // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLevelSequenceSubsystem_GetAllLevelSequences) == 0x000008, "Wrong alignment on KuroLevelSequenceSubsystem_GetAllLevelSequences");
static_assert(sizeof(KuroLevelSequenceSubsystem_GetAllLevelSequences) == 0x000010, "Wrong size on KuroLevelSequenceSubsystem_GetAllLevelSequences");
static_assert(offsetof(KuroLevelSequenceSubsystem_GetAllLevelSequences, InAllLevelSequences) == 0x000000, "Member 'KuroLevelSequenceSubsystem_GetAllLevelSequences::InAllLevelSequences' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroLevelSequenceSubsystem.GetLevelSequence
// 0x0018 (0x0018 - 0x0000)
struct KuroLevelSequenceSubsystem_GetLevelSequence final
{
public:
	class FName                                   Key;                                               // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B4[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AKuroLevelSequenceActor*                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroLevelSequenceSubsystem_GetLevelSequence) == 0x000008, "Wrong alignment on KuroLevelSequenceSubsystem_GetLevelSequence");
static_assert(sizeof(KuroLevelSequenceSubsystem_GetLevelSequence) == 0x000018, "Wrong size on KuroLevelSequenceSubsystem_GetLevelSequence");
static_assert(offsetof(KuroLevelSequenceSubsystem_GetLevelSequence, Key) == 0x000000, "Member 'KuroLevelSequenceSubsystem_GetLevelSequence::Key' has a wrong offset!");
static_assert(offsetof(KuroLevelSequenceSubsystem_GetLevelSequence, ReturnValue) == 0x000010, "Member 'KuroLevelSequenceSubsystem_GetLevelSequence::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.GetKeywordState
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialVariationComponent_GetKeywordState final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B6[0x3];                                     // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_GetKeywordState) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_GetKeywordState");
static_assert(sizeof(KuroMaterialVariationComponent_GetKeywordState) == 0x000014, "Wrong size on KuroMaterialVariationComponent_GetKeywordState");
static_assert(offsetof(KuroMaterialVariationComponent_GetKeywordState, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_GetKeywordState::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetKeywordState, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_GetKeywordState::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetKeywordState, ReturnValue) == 0x000010, "Member 'KuroMaterialVariationComponent_GetKeywordState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.GetMaterialFloat
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialVariationComponent_GetMaterialFloat final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_GetMaterialFloat) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_GetMaterialFloat");
static_assert(sizeof(KuroMaterialVariationComponent_GetMaterialFloat) == 0x000014, "Wrong size on KuroMaterialVariationComponent_GetMaterialFloat");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialFloat, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_GetMaterialFloat::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialFloat, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_GetMaterialFloat::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialFloat, ReturnValue) == 0x000010, "Member 'KuroMaterialVariationComponent_GetMaterialFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.GetMaterialLinearColor
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialVariationComponent_GetMaterialLinearColor final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_GetMaterialLinearColor) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_GetMaterialLinearColor");
static_assert(sizeof(KuroMaterialVariationComponent_GetMaterialLinearColor) == 0x000020, "Wrong size on KuroMaterialVariationComponent_GetMaterialLinearColor");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialLinearColor, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_GetMaterialLinearColor::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialLinearColor, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_GetMaterialLinearColor::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialLinearColor, ReturnValue) == 0x000010, "Member 'KuroMaterialVariationComponent_GetMaterialLinearColor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.GetMaterialTexture
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialVariationComponent_GetMaterialTexture final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_GetMaterialTexture) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_GetMaterialTexture");
static_assert(sizeof(KuroMaterialVariationComponent_GetMaterialTexture) == 0x000018, "Wrong size on KuroMaterialVariationComponent_GetMaterialTexture");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialTexture, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_GetMaterialTexture::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialTexture, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_GetMaterialTexture::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_GetMaterialTexture, ReturnValue) == 0x000010, "Member 'KuroMaterialVariationComponent_GetMaterialTexture::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.InitWithSkeletalMeshComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_InitWithSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B7[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_InitWithSkeletalMeshComponent) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_InitWithSkeletalMeshComponent");
static_assert(sizeof(KuroMaterialVariationComponent_InitWithSkeletalMeshComponent) == 0x000010, "Wrong size on KuroMaterialVariationComponent_InitWithSkeletalMeshComponent");
static_assert(offsetof(KuroMaterialVariationComponent_InitWithSkeletalMeshComponent, InSkeletalMeshComponent) == 0x000000, "Member 'KuroMaterialVariationComponent_InitWithSkeletalMeshComponent::InSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_InitWithSkeletalMeshComponent, ReturnValue) == 0x000008, "Member 'KuroMaterialVariationComponent_InitWithSkeletalMeshComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.InitWithStaticMeshComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_InitWithStaticMeshComponent final
{
public:
	class UStaticMeshComponent*                   InStaticMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B8[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_InitWithStaticMeshComponent) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_InitWithStaticMeshComponent");
static_assert(sizeof(KuroMaterialVariationComponent_InitWithStaticMeshComponent) == 0x000010, "Wrong size on KuroMaterialVariationComponent_InitWithStaticMeshComponent");
static_assert(offsetof(KuroMaterialVariationComponent_InitWithStaticMeshComponent, InStaticMeshComponent) == 0x000000, "Member 'KuroMaterialVariationComponent_InitWithStaticMeshComponent::InStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_InitWithStaticMeshComponent, ReturnValue) == 0x000008, "Member 'KuroMaterialVariationComponent_InitWithStaticMeshComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.IsComponentValid
// 0x0001 (0x0001 - 0x0000)
struct KuroMaterialVariationComponent_IsComponentValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_IsComponentValid) == 0x000001, "Wrong alignment on KuroMaterialVariationComponent_IsComponentValid");
static_assert(sizeof(KuroMaterialVariationComponent_IsComponentValid) == 0x000001, "Wrong size on KuroMaterialVariationComponent_IsComponentValid");
static_assert(offsetof(KuroMaterialVariationComponent_IsComponentValid, ReturnValue) == 0x000000, "Member 'KuroMaterialVariationComponent_IsComponentValid::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.IsMaterialVariationDataValid
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialVariationComponent_IsMaterialVariationDataValid final
{
public:
	class UMeshComponent*                         CheckMeshComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UKuroMaterialVariationCollection*> CheckCollection;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B9[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_IsMaterialVariationDataValid) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_IsMaterialVariationDataValid");
static_assert(sizeof(KuroMaterialVariationComponent_IsMaterialVariationDataValid) == 0x000020, "Wrong size on KuroMaterialVariationComponent_IsMaterialVariationDataValid");
static_assert(offsetof(KuroMaterialVariationComponent_IsMaterialVariationDataValid, CheckMeshComponent) == 0x000000, "Member 'KuroMaterialVariationComponent_IsMaterialVariationDataValid::CheckMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_IsMaterialVariationDataValid, CheckCollection) == 0x000008, "Member 'KuroMaterialVariationComponent_IsMaterialVariationDataValid::CheckCollection' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_IsMaterialVariationDataValid, ReturnValue) == 0x000018, "Member 'KuroMaterialVariationComponent_IsMaterialVariationDataValid::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.ReplaceMaterial
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_ReplaceMaterial final
{
public:
	class UMaterialInterface*                     MatToReplace;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18BA[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_ReplaceMaterial) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_ReplaceMaterial");
static_assert(sizeof(KuroMaterialVariationComponent_ReplaceMaterial) == 0x000010, "Wrong size on KuroMaterialVariationComponent_ReplaceMaterial");
static_assert(offsetof(KuroMaterialVariationComponent_ReplaceMaterial, MatToReplace) == 0x000000, "Member 'KuroMaterialVariationComponent_ReplaceMaterial::MatToReplace' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_ReplaceMaterial, MaterialIndex) == 0x000008, "Member 'KuroMaterialVariationComponent_ReplaceMaterial::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterial
// 0x0004 (0x0004 - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterial final
{
public:
	int32                                         MaterialIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterial) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterial");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterial) == 0x000004, "Wrong size on KuroMaterialVariationComponent_RevertMaterial");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterial, MaterialIndex) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterial::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialFloat
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialFloat final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialFloat) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialFloat");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialFloat) == 0x000010, "Wrong size on KuroMaterialVariationComponent_RevertMaterialFloat");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialFloat, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialFloat::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialFloat, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_RevertMaterialFloat::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialFloatAll
// 0x000C (0x000C - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialFloatAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialFloatAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialFloatAll");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialFloatAll) == 0x00000C, "Wrong size on KuroMaterialVariationComponent_RevertMaterialFloatAll");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialFloatAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialFloatAll::PropertyName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialLinearColor
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialLinearColor final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialLinearColor) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialLinearColor");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialLinearColor) == 0x000010, "Wrong size on KuroMaterialVariationComponent_RevertMaterialLinearColor");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialLinearColor, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialLinearColor::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialLinearColor, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_RevertMaterialLinearColor::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialLinearColorAll
// 0x000C (0x000C - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialLinearColorAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialLinearColorAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialLinearColorAll");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialLinearColorAll) == 0x00000C, "Wrong size on KuroMaterialVariationComponent_RevertMaterialLinearColorAll");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialLinearColorAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialLinearColorAll::PropertyName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialTexture
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialTexture final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialTexture) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialTexture");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialTexture) == 0x000010, "Wrong size on KuroMaterialVariationComponent_RevertMaterialTexture");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialTexture, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialTexture::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialTexture, MaterialIndex) == 0x00000C, "Member 'KuroMaterialVariationComponent_RevertMaterialTexture::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.RevertMaterialTextureAll
// 0x000C (0x000C - 0x0000)
struct KuroMaterialVariationComponent_RevertMaterialTextureAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_RevertMaterialTextureAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_RevertMaterialTextureAll");
static_assert(sizeof(KuroMaterialVariationComponent_RevertMaterialTextureAll) == 0x00000C, "Wrong size on KuroMaterialVariationComponent_RevertMaterialTextureAll");
static_assert(offsetof(KuroMaterialVariationComponent_RevertMaterialTextureAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_RevertMaterialTextureAll::PropertyName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetKeywordState
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialVariationComponent_SetKeywordState final
{
public:
	class FName                                   Keyword;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InIsEnable;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18BB[0x3];                                     // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaterialIndex;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetKeywordState) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetKeywordState");
static_assert(sizeof(KuroMaterialVariationComponent_SetKeywordState) == 0x000014, "Wrong size on KuroMaterialVariationComponent_SetKeywordState");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordState, Keyword) == 0x000000, "Member 'KuroMaterialVariationComponent_SetKeywordState::Keyword' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordState, InIsEnable) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetKeywordState::InIsEnable' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordState, MaterialIndex) == 0x000010, "Member 'KuroMaterialVariationComponent_SetKeywordState::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetKeywordStateAll
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_SetKeywordStateAll final
{
public:
	class FName                                   Keyword;                                           // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InIsEnable;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18BC[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_SetKeywordStateAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetKeywordStateAll");
static_assert(sizeof(KuroMaterialVariationComponent_SetKeywordStateAll) == 0x000010, "Wrong size on KuroMaterialVariationComponent_SetKeywordStateAll");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordStateAll, Keyword) == 0x000000, "Member 'KuroMaterialVariationComponent_SetKeywordStateAll::Keyword' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetKeywordStateAll, InIsEnable) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetKeywordStateAll::InIsEnable' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialFloat
// 0x0014 (0x0014 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialFloat final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialFloat) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialFloat");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialFloat) == 0x000014, "Wrong size on KuroMaterialVariationComponent_SetMaterialFloat");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloat, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialFloat::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloat, InValue) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetMaterialFloat::InValue' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloat, MaterialIndex) == 0x000010, "Member 'KuroMaterialVariationComponent_SetMaterialFloat::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialFloatAll
// 0x0010 (0x0010 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialFloatAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialFloatAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialFloatAll");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialFloatAll) == 0x000010, "Wrong size on KuroMaterialVariationComponent_SetMaterialFloatAll");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloatAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialFloatAll::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialFloatAll, InValue) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetMaterialFloatAll::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialLinearColor
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialLinearColor final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InValue;                                           // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialLinearColor) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialLinearColor");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialLinearColor) == 0x000020, "Wrong size on KuroMaterialVariationComponent_SetMaterialLinearColor");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColor, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColor::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColor, InValue) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColor::InValue' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColor, MaterialIndex) == 0x00001C, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColor::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialLinearColorAll
// 0x001C (0x001C - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialLinearColorAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InValue;                                           // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialLinearColorAll) == 0x000004, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialLinearColorAll");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialLinearColorAll) == 0x00001C, "Wrong size on KuroMaterialVariationComponent_SetMaterialLinearColorAll");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColorAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColorAll::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialLinearColorAll, InValue) == 0x00000C, "Member 'KuroMaterialVariationComponent_SetMaterialLinearColorAll::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialTexture
// 0x0020 (0x0020 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialTexture final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18BD[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               InValue;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18BE[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialTexture) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialTexture");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialTexture) == 0x000020, "Wrong size on KuroMaterialVariationComponent_SetMaterialTexture");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTexture, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialTexture::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTexture, InValue) == 0x000010, "Member 'KuroMaterialVariationComponent_SetMaterialTexture::InValue' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTexture, MaterialIndex) == 0x000018, "Member 'KuroMaterialVariationComponent_SetMaterialTexture::MaterialIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroMaterialVariationComponent.SetMaterialTextureAll
// 0x0018 (0x0018 - 0x0000)
struct KuroMaterialVariationComponent_SetMaterialTextureAll final
{
public:
	class FName                                   PropertyName;                                      // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18BF[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               InValue;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroMaterialVariationComponent_SetMaterialTextureAll) == 0x000008, "Wrong alignment on KuroMaterialVariationComponent_SetMaterialTextureAll");
static_assert(sizeof(KuroMaterialVariationComponent_SetMaterialTextureAll) == 0x000018, "Wrong size on KuroMaterialVariationComponent_SetMaterialTextureAll");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTextureAll, PropertyName) == 0x000000, "Member 'KuroMaterialVariationComponent_SetMaterialTextureAll::PropertyName' has a wrong offset!");
static_assert(offsetof(KuroMaterialVariationComponent_SetMaterialTextureAll, InValue) == 0x000010, "Member 'KuroMaterialVariationComponent_SetMaterialTextureAll::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.DeleteKey
// 0x0010 (0x0010 - 0x0000)
struct KuroPlayerPrefsSystem_DeleteKey final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_DeleteKey) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_DeleteKey");
static_assert(sizeof(KuroPlayerPrefsSystem_DeleteKey) == 0x000010, "Wrong size on KuroPlayerPrefsSystem_DeleteKey");
static_assert(offsetof(KuroPlayerPrefsSystem_DeleteKey, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_DeleteKey::Key' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.GetFloat
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_GetFloat final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_GetFloat) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_GetFloat");
static_assert(sizeof(KuroPlayerPrefsSystem_GetFloat) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_GetFloat");
static_assert(offsetof(KuroPlayerPrefsSystem_GetFloat, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_GetFloat::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetFloat, DefaultValue) == 0x000010, "Member 'KuroPlayerPrefsSystem_GetFloat::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetFloat, ReturnValue) == 0x000014, "Member 'KuroPlayerPrefsSystem_GetFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.GetInt
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_GetInt final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_GetInt) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_GetInt");
static_assert(sizeof(KuroPlayerPrefsSystem_GetInt) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_GetInt");
static_assert(offsetof(KuroPlayerPrefsSystem_GetInt, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_GetInt::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetInt, DefaultValue) == 0x000010, "Member 'KuroPlayerPrefsSystem_GetInt::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetInt, ReturnValue) == 0x000014, "Member 'KuroPlayerPrefsSystem_GetInt::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.GetString
// 0x0030 (0x0030 - 0x0000)
struct KuroPlayerPrefsSystem_GetString final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultValue;                                      // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_GetString) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_GetString");
static_assert(sizeof(KuroPlayerPrefsSystem_GetString) == 0x000030, "Wrong size on KuroPlayerPrefsSystem_GetString");
static_assert(offsetof(KuroPlayerPrefsSystem_GetString, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_GetString::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetString, DefaultValue) == 0x000010, "Member 'KuroPlayerPrefsSystem_GetString::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_GetString, ReturnValue) == 0x000020, "Member 'KuroPlayerPrefsSystem_GetString::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.HasKey
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_HasKey final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C0[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroPlayerPrefsSystem_HasKey) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_HasKey");
static_assert(sizeof(KuroPlayerPrefsSystem_HasKey) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_HasKey");
static_assert(offsetof(KuroPlayerPrefsSystem_HasKey, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_HasKey::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_HasKey, ReturnValue) == 0x000010, "Member 'KuroPlayerPrefsSystem_HasKey::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.SetFloat
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_SetFloat final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C1[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroPlayerPrefsSystem_SetFloat) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_SetFloat");
static_assert(sizeof(KuroPlayerPrefsSystem_SetFloat) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_SetFloat");
static_assert(offsetof(KuroPlayerPrefsSystem_SetFloat, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_SetFloat::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_SetFloat, Value) == 0x000010, "Member 'KuroPlayerPrefsSystem_SetFloat::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.SetInt
// 0x0018 (0x0018 - 0x0000)
struct KuroPlayerPrefsSystem_SetInt final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C2[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroPlayerPrefsSystem_SetInt) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_SetInt");
static_assert(sizeof(KuroPlayerPrefsSystem_SetInt) == 0x000018, "Wrong size on KuroPlayerPrefsSystem_SetInt");
static_assert(offsetof(KuroPlayerPrefsSystem_SetInt, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_SetInt::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_SetInt, Value) == 0x000010, "Member 'KuroPlayerPrefsSystem_SetInt::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPlayerPrefsSystem.SetString
// 0x0020 (0x0020 - 0x0000)
struct KuroPlayerPrefsSystem_SetString final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPlayerPrefsSystem_SetString) == 0x000008, "Wrong alignment on KuroPlayerPrefsSystem_SetString");
static_assert(sizeof(KuroPlayerPrefsSystem_SetString) == 0x000020, "Wrong size on KuroPlayerPrefsSystem_SetString");
static_assert(offsetof(KuroPlayerPrefsSystem_SetString, Key) == 0x000000, "Member 'KuroPlayerPrefsSystem_SetString::Key' has a wrong offset!");
static_assert(offsetof(KuroPlayerPrefsSystem_SetString, Value) == 0x000010, "Member 'KuroPlayerPrefsSystem_SetString::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessComponent.SetPPTODDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessComponent_SetPPTODDataAsset final
{
public:
	class UKuroTODData*                           InPPTODDataAsset;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessComponent_SetPPTODDataAsset) == 0x000008, "Wrong alignment on KuroPostProcessComponent_SetPPTODDataAsset");
static_assert(sizeof(KuroPostProcessComponent_SetPPTODDataAsset) == 0x000008, "Wrong size on KuroPostProcessComponent_SetPPTODDataAsset");
static_assert(offsetof(KuroPostProcessComponent_SetPPTODDataAsset, InPPTODDataAsset) == 0x000000, "Member 'KuroPostProcessComponent_SetPPTODDataAsset::InPPTODDataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessComponent.SetReferencedVolumeActor
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessComponent_SetReferencedVolumeActor final
{
public:
	class AVolume*                                InReferencedVolumeActor;                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessComponent_SetReferencedVolumeActor) == 0x000008, "Wrong alignment on KuroPostProcessComponent_SetReferencedVolumeActor");
static_assert(sizeof(KuroPostProcessComponent_SetReferencedVolumeActor) == 0x000008, "Wrong size on KuroPostProcessComponent_SetReferencedVolumeActor");
static_assert(offsetof(KuroPostProcessComponent_SetReferencedVolumeActor, InReferencedVolumeActor) == 0x000000, "Member 'KuroPostProcessComponent_SetReferencedVolumeActor::InReferencedVolumeActor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessComponent.SetWeatherDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessComponent_SetWeatherDataAsset final
{
public:
	class UKuroWeatherDataAsset*                  InWeatherDataAsset;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessComponent_SetWeatherDataAsset) == 0x000008, "Wrong alignment on KuroPostProcessComponent_SetWeatherDataAsset");
static_assert(sizeof(KuroPostProcessComponent_SetWeatherDataAsset) == 0x000008, "Wrong size on KuroPostProcessComponent_SetWeatherDataAsset");
static_assert(offsetof(KuroPostProcessComponent_SetWeatherDataAsset, InWeatherDataAsset) == 0x000000, "Member 'KuroPostProcessComponent_SetWeatherDataAsset::InWeatherDataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessVolume.SetPPTODDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessVolume_SetPPTODDataAsset final
{
public:
	class UKuroTODData*                           InPPTODDataAsset;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessVolume_SetPPTODDataAsset) == 0x000008, "Wrong alignment on KuroPostProcessVolume_SetPPTODDataAsset");
static_assert(sizeof(KuroPostProcessVolume_SetPPTODDataAsset) == 0x000008, "Wrong size on KuroPostProcessVolume_SetPPTODDataAsset");
static_assert(offsetof(KuroPostProcessVolume_SetPPTODDataAsset, InPPTODDataAsset) == 0x000000, "Member 'KuroPostProcessVolume_SetPPTODDataAsset::InPPTODDataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroPostProcessVolume.SetWeatherDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroPostProcessVolume_SetWeatherDataAsset final
{
public:
	class UKuroWeatherDataAsset*                  InWeatherDataAsset;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroPostProcessVolume_SetWeatherDataAsset) == 0x000008, "Wrong alignment on KuroPostProcessVolume_SetWeatherDataAsset");
static_assert(sizeof(KuroPostProcessVolume_SetWeatherDataAsset) == 0x000008, "Wrong size on KuroPostProcessVolume_SetWeatherDataAsset");
static_assert(offsetof(KuroPostProcessVolume_SetWeatherDataAsset, InWeatherDataAsset) == 0x000000, "Member 'KuroPostProcessVolume_SetWeatherDataAsset::InWeatherDataAsset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.GetDynamicMaterial
// 0x0008 (0x0008 - 0x0000)
struct KuroRainActor_GetDynamicMaterial final
{
public:
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_GetDynamicMaterial) == 0x000008, "Wrong alignment on KuroRainActor_GetDynamicMaterial");
static_assert(sizeof(KuroRainActor_GetDynamicMaterial) == 0x000008, "Wrong size on KuroRainActor_GetDynamicMaterial");
static_assert(offsetof(KuroRainActor_GetDynamicMaterial, ReturnValue) == 0x000000, "Member 'KuroRainActor_GetDynamicMaterial::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.GetIsInit
// 0x0001 (0x0001 - 0x0000)
struct KuroRainActor_GetIsInit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_GetIsInit) == 0x000001, "Wrong alignment on KuroRainActor_GetIsInit");
static_assert(sizeof(KuroRainActor_GetIsInit) == 0x000001, "Wrong size on KuroRainActor_GetIsInit");
static_assert(offsetof(KuroRainActor_GetIsInit, ReturnValue) == 0x000000, "Member 'KuroRainActor_GetIsInit::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.SetCurrentRain
// 0x0014 (0x0014 - 0x0000)
struct KuroRainActor_SetCurrentRain final
{
public:
	float                                         InDensity;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGravity;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWindX;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWindY;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InWindZ;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_SetCurrentRain) == 0x000004, "Wrong alignment on KuroRainActor_SetCurrentRain");
static_assert(sizeof(KuroRainActor_SetCurrentRain) == 0x000014, "Wrong size on KuroRainActor_SetCurrentRain");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InDensity) == 0x000000, "Member 'KuroRainActor_SetCurrentRain::InDensity' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InGravity) == 0x000004, "Member 'KuroRainActor_SetCurrentRain::InGravity' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InWindX) == 0x000008, "Member 'KuroRainActor_SetCurrentRain::InWindX' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InWindY) == 0x00000C, "Member 'KuroRainActor_SetCurrentRain::InWindY' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetCurrentRain, InWindZ) == 0x000010, "Member 'KuroRainActor_SetCurrentRain::InWindZ' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.SetMaterialParameterOverrideColor
// 0x001C (0x001C - 0x0000)
struct KuroRainActor_SetMaterialParameterOverrideColor final
{
public:
	class FName                                   Param_Name;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_SetMaterialParameterOverrideColor) == 0x000004, "Wrong alignment on KuroRainActor_SetMaterialParameterOverrideColor");
static_assert(sizeof(KuroRainActor_SetMaterialParameterOverrideColor) == 0x00001C, "Wrong size on KuroRainActor_SetMaterialParameterOverrideColor");
static_assert(offsetof(KuroRainActor_SetMaterialParameterOverrideColor, Param_Name) == 0x000000, "Member 'KuroRainActor_SetMaterialParameterOverrideColor::Param_Name' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetMaterialParameterOverrideColor, Value) == 0x00000C, "Member 'KuroRainActor_SetMaterialParameterOverrideColor::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.SetMaterialParameterOverrideFloat
// 0x0010 (0x0010 - 0x0000)
struct KuroRainActor_SetMaterialParameterOverrideFloat final
{
public:
	class FName                                   Param_Name;                                        // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_SetMaterialParameterOverrideFloat) == 0x000004, "Wrong alignment on KuroRainActor_SetMaterialParameterOverrideFloat");
static_assert(sizeof(KuroRainActor_SetMaterialParameterOverrideFloat) == 0x000010, "Wrong size on KuroRainActor_SetMaterialParameterOverrideFloat");
static_assert(offsetof(KuroRainActor_SetMaterialParameterOverrideFloat, Param_Name) == 0x000000, "Member 'KuroRainActor_SetMaterialParameterOverrideFloat::Param_Name' has a wrong offset!");
static_assert(offsetof(KuroRainActor_SetMaterialParameterOverrideFloat, Value) == 0x00000C, "Member 'KuroRainActor_SetMaterialParameterOverrideFloat::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActor.Update
// 0x0004 (0x0004 - 0x0000)
struct KuroRainActor_Update final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActor_Update) == 0x000004, "Wrong alignment on KuroRainActor_Update");
static_assert(sizeof(KuroRainActor_Update) == 0x000004, "Wrong size on KuroRainActor_Update");
static_assert(offsetof(KuroRainActor_Update, DeltaSeconds) == 0x000000, "Member 'KuroRainActor_Update::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.AddRainComponent
// 0x0010 (0x0010 - 0x0000)
struct KuroRainActorV2_AddRainComponent final
{
public:
	TSubclassOf<class UKuroRainComponent>         ClassType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroRainComponent*                     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_AddRainComponent) == 0x000008, "Wrong alignment on KuroRainActorV2_AddRainComponent");
static_assert(sizeof(KuroRainActorV2_AddRainComponent) == 0x000010, "Wrong size on KuroRainActorV2_AddRainComponent");
static_assert(offsetof(KuroRainActorV2_AddRainComponent, ClassType) == 0x000000, "Member 'KuroRainActorV2_AddRainComponent::ClassType' has a wrong offset!");
static_assert(offsetof(KuroRainActorV2_AddRainComponent, ReturnValue) == 0x000008, "Member 'KuroRainActorV2_AddRainComponent::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.GetPlayerOrEditorCameraLocation
// 0x000C (0x000C - 0x0000)
struct KuroRainActorV2_GetPlayerOrEditorCameraLocation final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_GetPlayerOrEditorCameraLocation) == 0x000004, "Wrong alignment on KuroRainActorV2_GetPlayerOrEditorCameraLocation");
static_assert(sizeof(KuroRainActorV2_GetPlayerOrEditorCameraLocation) == 0x00000C, "Wrong size on KuroRainActorV2_GetPlayerOrEditorCameraLocation");
static_assert(offsetof(KuroRainActorV2_GetPlayerOrEditorCameraLocation, OutLocation) == 0x000000, "Member 'KuroRainActorV2_GetPlayerOrEditorCameraLocation::OutLocation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.RemoveRainComponent
// 0x0008 (0x0008 - 0x0000)
struct KuroRainActorV2_RemoveRainComponent final
{
public:
	class UKuroRainComponent*                     Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_RemoveRainComponent) == 0x000008, "Wrong alignment on KuroRainActorV2_RemoveRainComponent");
static_assert(sizeof(KuroRainActorV2_RemoveRainComponent) == 0x000008, "Wrong size on KuroRainActorV2_RemoveRainComponent");
static_assert(offsetof(KuroRainActorV2_RemoveRainComponent, Comp) == 0x000000, "Member 'KuroRainActorV2_RemoveRainComponent::Comp' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainActorV2.SetCameraFrustum
// 0x0008 (0x0008 - 0x0000)
struct KuroRainActorV2_SetCameraFrustum final
{
public:
	class UKuroRainComponent*                     Comp;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainActorV2_SetCameraFrustum) == 0x000008, "Wrong alignment on KuroRainActorV2_SetCameraFrustum");
static_assert(sizeof(KuroRainActorV2_SetCameraFrustum) == 0x000008, "Wrong size on KuroRainActorV2_SetCameraFrustum");
static_assert(offsetof(KuroRainActorV2_SetCameraFrustum, Comp) == 0x000000, "Member 'KuroRainActorV2_SetCameraFrustum::Comp' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddArraySpawner
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_AddArraySpawner final
{
public:
	int32                                         RenderIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddArraySpawner) == 0x000004, "Wrong alignment on KuroRainComponent_AddArraySpawner");
static_assert(sizeof(KuroRainComponent_AddArraySpawner) == 0x000008, "Wrong size on KuroRainComponent_AddArraySpawner");
static_assert(offsetof(KuroRainComponent_AddArraySpawner, RenderIndex) == 0x000000, "Member 'KuroRainComponent_AddArraySpawner::RenderIndex' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddArraySpawner, ReturnValue) == 0x000004, "Member 'KuroRainComponent_AddArraySpawner::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddCustomRandomByNormalizedAgeProcessor
// 0x0098 (0x0098 - 0x0000)
struct KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor final
{
public:
	struct FKuroCurveFloat                        Curve;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0094(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor");
static_assert(sizeof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor) == 0x000098, "Wrong size on KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor, Curve) == 0x000000, "Member 'KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor::Curve' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor, Param_Index) == 0x000090, "Member 'KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor::Param_Index' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor, ReturnValue) == 0x000094, "Member 'KuroRainComponent_AddCustomRandomByNormalizedAgeProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddCustomRandomByVelocityProcessor
// 0x0098 (0x0098 - 0x0000)
struct KuroRainComponent_AddCustomRandomByVelocityProcessor final
{
public:
	struct FKuroCurveFloat                        Curve;                                             // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0090(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0094(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddCustomRandomByVelocityProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_AddCustomRandomByVelocityProcessor");
static_assert(sizeof(KuroRainComponent_AddCustomRandomByVelocityProcessor) == 0x000098, "Wrong size on KuroRainComponent_AddCustomRandomByVelocityProcessor");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByVelocityProcessor, Curve) == 0x000000, "Member 'KuroRainComponent_AddCustomRandomByVelocityProcessor::Curve' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByVelocityProcessor, Param_Index) == 0x000090, "Member 'KuroRainComponent_AddCustomRandomByVelocityProcessor::Param_Index' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomByVelocityProcessor, ReturnValue) == 0x000094, "Member 'KuroRainComponent_AddCustomRandomByVelocityProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddCustomRandomSetProcessor
// 0x000C (0x000C - 0x0000)
struct KuroRainComponent_AddCustomRandomSetProcessor final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddCustomRandomSetProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddCustomRandomSetProcessor");
static_assert(sizeof(KuroRainComponent_AddCustomRandomSetProcessor) == 0x00000C, "Wrong size on KuroRainComponent_AddCustomRandomSetProcessor");
static_assert(offsetof(KuroRainComponent_AddCustomRandomSetProcessor, Value) == 0x000000, "Member 'KuroRainComponent_AddCustomRandomSetProcessor::Value' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomSetProcessor, Param_Index) == 0x000004, "Member 'KuroRainComponent_AddCustomRandomSetProcessor::Param_Index' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCustomRandomSetProcessor, ReturnValue) == 0x000008, "Member 'KuroRainComponent_AddCustomRandomSetProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddCycleBoxProcessor
// 0x0020 (0x0020 - 0x0000)
struct KuroRainComponent_AddCycleBoxProcessor final
{
public:
	struct FVector                                Min;                                               // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillOnZ;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18CD[0x3];                                     // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddCycleBoxProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddCycleBoxProcessor");
static_assert(sizeof(KuroRainComponent_AddCycleBoxProcessor) == 0x000020, "Wrong size on KuroRainComponent_AddCycleBoxProcessor");
static_assert(offsetof(KuroRainComponent_AddCycleBoxProcessor, Min) == 0x000000, "Member 'KuroRainComponent_AddCycleBoxProcessor::Min' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCycleBoxProcessor, Max) == 0x00000C, "Member 'KuroRainComponent_AddCycleBoxProcessor::Max' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCycleBoxProcessor, bKillOnZ) == 0x000018, "Member 'KuroRainComponent_AddCycleBoxProcessor::bKillOnZ' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddCycleBoxProcessor, ReturnValue) == 0x00001C, "Member 'KuroRainComponent_AddCycleBoxProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddDragProcessor
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_AddDragProcessor final
{
public:
	float                                         DragSize;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddDragProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddDragProcessor");
static_assert(sizeof(KuroRainComponent_AddDragProcessor) == 0x000008, "Wrong size on KuroRainComponent_AddDragProcessor");
static_assert(offsetof(KuroRainComponent_AddDragProcessor, DragSize) == 0x000000, "Member 'KuroRainComponent_AddDragProcessor::DragSize' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddDragProcessor, ReturnValue) == 0x000004, "Member 'KuroRainComponent_AddDragProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddLinearForceProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_AddLinearForceProcessor final
{
public:
	struct FVector                                Force;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddLinearForceProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddLinearForceProcessor");
static_assert(sizeof(KuroRainComponent_AddLinearForceProcessor) == 0x000010, "Wrong size on KuroRainComponent_AddLinearForceProcessor");
static_assert(offsetof(KuroRainComponent_AddLinearForceProcessor, Force) == 0x000000, "Member 'KuroRainComponent_AddLinearForceProcessor::Force' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddLinearForceProcessor, ReturnValue) == 0x00000C, "Member 'KuroRainComponent_AddLinearForceProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddRandomSpawner
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_AddRandomSpawner final
{
public:
	int32                                         RenderIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddRandomSpawner) == 0x000004, "Wrong alignment on KuroRainComponent_AddRandomSpawner");
static_assert(sizeof(KuroRainComponent_AddRandomSpawner) == 0x000008, "Wrong size on KuroRainComponent_AddRandomSpawner");
static_assert(offsetof(KuroRainComponent_AddRandomSpawner, RenderIndex) == 0x000000, "Member 'KuroRainComponent_AddRandomSpawner::RenderIndex' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddRandomSpawner, ReturnValue) == 0x000004, "Member 'KuroRainComponent_AddRandomSpawner::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddVectorFieldForceProcessor
// 0x0028 (0x0028 - 0x0000)
struct KuroRainComponent_AddVectorFieldForceProcessor final
{
public:
	class UVectorFieldStatic*                     InVectorField;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPosScale;                                        // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InMoveSpeed;                                       // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForceSize;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddVectorFieldForceProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_AddVectorFieldForceProcessor");
static_assert(sizeof(KuroRainComponent_AddVectorFieldForceProcessor) == 0x000028, "Wrong size on KuroRainComponent_AddVectorFieldForceProcessor");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, InVectorField) == 0x000000, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::InVectorField' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, InPosScale) == 0x000008, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::InPosScale' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, InMoveSpeed) == 0x000014, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::InMoveSpeed' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, InForceSize) == 0x000020, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::InForceSize' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddVectorFieldForceProcessor, ReturnValue) == 0x000024, "Member 'KuroRainComponent_AddVectorFieldForceProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.AddWindProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_AddWindProcessor final
{
public:
	struct FVector                                WindVelocity;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_AddWindProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_AddWindProcessor");
static_assert(sizeof(KuroRainComponent_AddWindProcessor) == 0x000010, "Wrong size on KuroRainComponent_AddWindProcessor");
static_assert(offsetof(KuroRainComponent_AddWindProcessor, WindVelocity) == 0x000000, "Member 'KuroRainComponent_AddWindProcessor::WindVelocity' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_AddWindProcessor, ReturnValue) == 0x00000C, "Member 'KuroRainComponent_AddWindProcessor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetCycleBoxProcessor_Max
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_GetCycleBoxProcessor_Max final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetCycleBoxProcessor_Max) == 0x000004, "Wrong alignment on KuroRainComponent_GetCycleBoxProcessor_Max");
static_assert(sizeof(KuroRainComponent_GetCycleBoxProcessor_Max) == 0x000010, "Wrong size on KuroRainComponent_GetCycleBoxProcessor_Max");
static_assert(offsetof(KuroRainComponent_GetCycleBoxProcessor_Max, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetCycleBoxProcessor_Max::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetCycleBoxProcessor_Max, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetCycleBoxProcessor_Max::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetCycleBoxProcessor_Min
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_GetCycleBoxProcessor_Min final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetCycleBoxProcessor_Min) == 0x000004, "Wrong alignment on KuroRainComponent_GetCycleBoxProcessor_Min");
static_assert(sizeof(KuroRainComponent_GetCycleBoxProcessor_Min) == 0x000010, "Wrong size on KuroRainComponent_GetCycleBoxProcessor_Min");
static_assert(offsetof(KuroRainComponent_GetCycleBoxProcessor_Min, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetCycleBoxProcessor_Min::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetCycleBoxProcessor_Min, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetCycleBoxProcessor_Min::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetDragProcessor_DragSize
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_GetDragProcessor_DragSize final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetDragProcessor_DragSize) == 0x000004, "Wrong alignment on KuroRainComponent_GetDragProcessor_DragSize");
static_assert(sizeof(KuroRainComponent_GetDragProcessor_DragSize) == 0x000008, "Wrong size on KuroRainComponent_GetDragProcessor_DragSize");
static_assert(offsetof(KuroRainComponent_GetDragProcessor_DragSize, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetDragProcessor_DragSize::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetDragProcessor_DragSize, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetDragProcessor_DragSize::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetEmitterDataNum
// 0x0004 (0x0004 - 0x0000)
struct KuroRainComponent_GetEmitterDataNum final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetEmitterDataNum) == 0x000004, "Wrong alignment on KuroRainComponent_GetEmitterDataNum");
static_assert(sizeof(KuroRainComponent_GetEmitterDataNum) == 0x000004, "Wrong size on KuroRainComponent_GetEmitterDataNum");
static_assert(offsetof(KuroRainComponent_GetEmitterDataNum, ReturnValue) == 0x000000, "Member 'KuroRainComponent_GetEmitterDataNum::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetIsPlaying
// 0x0001 (0x0001 - 0x0000)
struct KuroRainComponent_GetIsPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetIsPlaying) == 0x000001, "Wrong alignment on KuroRainComponent_GetIsPlaying");
static_assert(sizeof(KuroRainComponent_GetIsPlaying) == 0x000001, "Wrong size on KuroRainComponent_GetIsPlaying");
static_assert(offsetof(KuroRainComponent_GetIsPlaying, ReturnValue) == 0x000000, "Member 'KuroRainComponent_GetIsPlaying::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetLinearForceProcessor_Force
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_GetLinearForceProcessor_Force final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetLinearForceProcessor_Force) == 0x000004, "Wrong alignment on KuroRainComponent_GetLinearForceProcessor_Force");
static_assert(sizeof(KuroRainComponent_GetLinearForceProcessor_Force) == 0x000010, "Wrong size on KuroRainComponent_GetLinearForceProcessor_Force");
static_assert(offsetof(KuroRainComponent_GetLinearForceProcessor_Force, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetLinearForceProcessor_Force::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetLinearForceProcessor_Force, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetLinearForceProcessor_Force::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.GetWindProcessor_WindVelocity
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_GetWindProcessor_WindVelocity final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_GetWindProcessor_WindVelocity) == 0x000004, "Wrong alignment on KuroRainComponent_GetWindProcessor_WindVelocity");
static_assert(sizeof(KuroRainComponent_GetWindProcessor_WindVelocity) == 0x000010, "Wrong size on KuroRainComponent_GetWindProcessor_WindVelocity");
static_assert(offsetof(KuroRainComponent_GetWindProcessor_WindVelocity, ProcessorID) == 0x000000, "Member 'KuroRainComponent_GetWindProcessor_WindVelocity::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_GetWindProcessor_WindVelocity, ReturnValue) == 0x000004, "Member 'KuroRainComponent_GetWindProcessor_WindVelocity::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.PreSolveRainParticles
// 0x0004 (0x0004 - 0x0000)
struct KuroRainComponent_PreSolveRainParticles final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_PreSolveRainParticles) == 0x000004, "Wrong alignment on KuroRainComponent_PreSolveRainParticles");
static_assert(sizeof(KuroRainComponent_PreSolveRainParticles) == 0x000004, "Wrong size on KuroRainComponent_PreSolveRainParticles");
static_assert(offsetof(KuroRainComponent_PreSolveRainParticles, DeltaSeconds) == 0x000000, "Member 'KuroRainComponent_PreSolveRainParticles::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetArraySpawnerBasic
// 0x002C (0x002C - 0x0000)
struct KuroRainComponent_SetArraySpawnerBasic final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ArraySize;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrayLength;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnTimeWiggle;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnPositionWiggle;                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeMin;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeMax;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMin;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMax;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMassMin;                                       // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMassMax;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetArraySpawnerBasic) == 0x000004, "Wrong alignment on KuroRainComponent_SetArraySpawnerBasic");
static_assert(sizeof(KuroRainComponent_SetArraySpawnerBasic) == 0x00002C, "Wrong size on KuroRainComponent_SetArraySpawnerBasic");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, SpawnerID) == 0x000000, "Member 'KuroRainComponent_SetArraySpawnerBasic::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, ArraySize) == 0x000004, "Member 'KuroRainComponent_SetArraySpawnerBasic::ArraySize' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, ArrayLength) == 0x000008, "Member 'KuroRainComponent_SetArraySpawnerBasic::ArrayLength' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, SpawnTimeWiggle) == 0x00000C, "Member 'KuroRainComponent_SetArraySpawnerBasic::SpawnTimeWiggle' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, SpawnPositionWiggle) == 0x000010, "Member 'KuroRainComponent_SetArraySpawnerBasic::SpawnPositionWiggle' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, LifeTimeMin) == 0x000014, "Member 'KuroRainComponent_SetArraySpawnerBasic::LifeTimeMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, LifeTimeMax) == 0x000018, "Member 'KuroRainComponent_SetArraySpawnerBasic::LifeTimeMax' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, ScaleMin) == 0x00001C, "Member 'KuroRainComponent_SetArraySpawnerBasic::ScaleMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, ScaleMax) == 0x000020, "Member 'KuroRainComponent_SetArraySpawnerBasic::ScaleMax' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, BaseMassMin) == 0x000024, "Member 'KuroRainComponent_SetArraySpawnerBasic::BaseMassMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerBasic, BaseMassMax) == 0x000028, "Member 'KuroRainComponent_SetArraySpawnerBasic::BaseMassMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetArraySpawnerRuntime
// 0x002C (0x002C - 0x0000)
struct KuroRainComponent_SetArraySpawnerRuntime final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnCenter;                                       // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRate;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMin;                                       // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMax;                                       // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetArraySpawnerRuntime) == 0x000004, "Wrong alignment on KuroRainComponent_SetArraySpawnerRuntime");
static_assert(sizeof(KuroRainComponent_SetArraySpawnerRuntime) == 0x00002C, "Wrong size on KuroRainComponent_SetArraySpawnerRuntime");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, SpawnerID) == 0x000000, "Member 'KuroRainComponent_SetArraySpawnerRuntime::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, SpawnCenter) == 0x000004, "Member 'KuroRainComponent_SetArraySpawnerRuntime::SpawnCenter' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, SpawnRate) == 0x000010, "Member 'KuroRainComponent_SetArraySpawnerRuntime::SpawnRate' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, VelocityMin) == 0x000014, "Member 'KuroRainComponent_SetArraySpawnerRuntime::VelocityMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetArraySpawnerRuntime, VelocityMax) == 0x000020, "Member 'KuroRainComponent_SetArraySpawnerRuntime::VelocityMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetCustomRandomByNormalizedAgeProcessor
// 0x00A0 (0x00A0 - 0x0000)
struct KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18CE[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        Curve;                                             // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18CF[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor");
static_assert(sizeof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor) == 0x0000A0, "Wrong size on KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor, Curve) == 0x000008, "Member 'KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor::Curve' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor, Param_Index) == 0x000098, "Member 'KuroRainComponent_SetCustomRandomByNormalizedAgeProcessor::Param_Index' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetCustomRandomByVelocityProcessor
// 0x00A0 (0x00A0 - 0x0000)
struct KuroRainComponent_SetCustomRandomByVelocityProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D0[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        Curve;                                             // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D1[0x4];                                     // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRainComponent_SetCustomRandomByVelocityProcessor) == 0x000008, "Wrong alignment on KuroRainComponent_SetCustomRandomByVelocityProcessor");
static_assert(sizeof(KuroRainComponent_SetCustomRandomByVelocityProcessor) == 0x0000A0, "Wrong size on KuroRainComponent_SetCustomRandomByVelocityProcessor");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByVelocityProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetCustomRandomByVelocityProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByVelocityProcessor, Curve) == 0x000008, "Member 'KuroRainComponent_SetCustomRandomByVelocityProcessor::Curve' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomByVelocityProcessor, Param_Index) == 0x000098, "Member 'KuroRainComponent_SetCustomRandomByVelocityProcessor::Param_Index' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetCustomRandomSetProcessor
// 0x000C (0x000C - 0x0000)
struct KuroRainComponent_SetCustomRandomSetProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetCustomRandomSetProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetCustomRandomSetProcessor");
static_assert(sizeof(KuroRainComponent_SetCustomRandomSetProcessor) == 0x00000C, "Wrong size on KuroRainComponent_SetCustomRandomSetProcessor");
static_assert(offsetof(KuroRainComponent_SetCustomRandomSetProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetCustomRandomSetProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomSetProcessor, Value) == 0x000004, "Member 'KuroRainComponent_SetCustomRandomSetProcessor::Value' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCustomRandomSetProcessor, Param_Index) == 0x000008, "Member 'KuroRainComponent_SetCustomRandomSetProcessor::Param_Index' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetCycleBoxProcessor
// 0x001C (0x001C - 0x0000)
struct KuroRainComponent_SetCycleBoxProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetCycleBoxProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetCycleBoxProcessor");
static_assert(sizeof(KuroRainComponent_SetCycleBoxProcessor) == 0x00001C, "Wrong size on KuroRainComponent_SetCycleBoxProcessor");
static_assert(offsetof(KuroRainComponent_SetCycleBoxProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetCycleBoxProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCycleBoxProcessor, Min) == 0x000004, "Member 'KuroRainComponent_SetCycleBoxProcessor::Min' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetCycleBoxProcessor, Max) == 0x000010, "Member 'KuroRainComponent_SetCycleBoxProcessor::Max' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetDragProcessor
// 0x0008 (0x0008 - 0x0000)
struct KuroRainComponent_SetDragProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DragSize;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetDragProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetDragProcessor");
static_assert(sizeof(KuroRainComponent_SetDragProcessor) == 0x000008, "Wrong size on KuroRainComponent_SetDragProcessor");
static_assert(offsetof(KuroRainComponent_SetDragProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetDragProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetDragProcessor, DragSize) == 0x000004, "Member 'KuroRainComponent_SetDragProcessor::DragSize' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetLifeTimeDilation
// 0x0004 (0x0004 - 0x0000)
struct KuroRainComponent_SetLifeTimeDilation final
{
public:
	float                                         Dilation;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetLifeTimeDilation) == 0x000004, "Wrong alignment on KuroRainComponent_SetLifeTimeDilation");
static_assert(sizeof(KuroRainComponent_SetLifeTimeDilation) == 0x000004, "Wrong size on KuroRainComponent_SetLifeTimeDilation");
static_assert(offsetof(KuroRainComponent_SetLifeTimeDilation, Dilation) == 0x000000, "Member 'KuroRainComponent_SetLifeTimeDilation::Dilation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetLinearForceProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_SetLinearForceProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Force;                                             // 0x0004(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetLinearForceProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetLinearForceProcessor");
static_assert(sizeof(KuroRainComponent_SetLinearForceProcessor) == 0x000010, "Wrong size on KuroRainComponent_SetLinearForceProcessor");
static_assert(offsetof(KuroRainComponent_SetLinearForceProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetLinearForceProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetLinearForceProcessor, Force) == 0x000004, "Member 'KuroRainComponent_SetLinearForceProcessor::Force' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetRandomSpawnerBasic
// 0x0024 (0x0024 - 0x0000)
struct KuroRainComponent_SetRandomSpawnerBasic final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnInnerRadius;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnOuterRadius;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeMin;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeMax;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMin;                                          // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleMax;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMassMin;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseMassMax;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetRandomSpawnerBasic) == 0x000004, "Wrong alignment on KuroRainComponent_SetRandomSpawnerBasic");
static_assert(sizeof(KuroRainComponent_SetRandomSpawnerBasic) == 0x000024, "Wrong size on KuroRainComponent_SetRandomSpawnerBasic");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, SpawnerID) == 0x000000, "Member 'KuroRainComponent_SetRandomSpawnerBasic::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, SpawnInnerRadius) == 0x000004, "Member 'KuroRainComponent_SetRandomSpawnerBasic::SpawnInnerRadius' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, SpawnOuterRadius) == 0x000008, "Member 'KuroRainComponent_SetRandomSpawnerBasic::SpawnOuterRadius' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, LifeTimeMin) == 0x00000C, "Member 'KuroRainComponent_SetRandomSpawnerBasic::LifeTimeMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, LifeTimeMax) == 0x000010, "Member 'KuroRainComponent_SetRandomSpawnerBasic::LifeTimeMax' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, ScaleMin) == 0x000014, "Member 'KuroRainComponent_SetRandomSpawnerBasic::ScaleMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, ScaleMax) == 0x000018, "Member 'KuroRainComponent_SetRandomSpawnerBasic::ScaleMax' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, BaseMassMin) == 0x00001C, "Member 'KuroRainComponent_SetRandomSpawnerBasic::BaseMassMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerBasic, BaseMassMax) == 0x000020, "Member 'KuroRainComponent_SetRandomSpawnerBasic::BaseMassMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetRandomSpawnerRuntime
// 0x002C (0x002C - 0x0000)
struct KuroRainComponent_SetRandomSpawnerRuntime final
{
public:
	int32                                         SpawnerID;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnCenter;                                       // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRate;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMin;                                       // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VelocityMax;                                       // 0x0020(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetRandomSpawnerRuntime) == 0x000004, "Wrong alignment on KuroRainComponent_SetRandomSpawnerRuntime");
static_assert(sizeof(KuroRainComponent_SetRandomSpawnerRuntime) == 0x00002C, "Wrong size on KuroRainComponent_SetRandomSpawnerRuntime");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, SpawnerID) == 0x000000, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::SpawnerID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, SpawnCenter) == 0x000004, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::SpawnCenter' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, SpawnRate) == 0x000010, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::SpawnRate' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, VelocityMin) == 0x000014, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::VelocityMin' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetRandomSpawnerRuntime, VelocityMax) == 0x000020, "Member 'KuroRainComponent_SetRandomSpawnerRuntime::VelocityMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetTimeDilation
// 0x0004 (0x0004 - 0x0000)
struct KuroRainComponent_SetTimeDilation final
{
public:
	float                                         Dilation;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetTimeDilation) == 0x000004, "Wrong alignment on KuroRainComponent_SetTimeDilation");
static_assert(sizeof(KuroRainComponent_SetTimeDilation) == 0x000004, "Wrong size on KuroRainComponent_SetTimeDilation");
static_assert(offsetof(KuroRainComponent_SetTimeDilation, Dilation) == 0x000000, "Member 'KuroRainComponent_SetTimeDilation::Dilation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.Setup
// 0x0020 (0x0020 - 0x0000)
struct KuroRainComponent_Setup final
{
public:
	TArray<class UStaticMesh*>                    Meshes;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_Setup) == 0x000008, "Wrong alignment on KuroRainComponent_Setup");
static_assert(sizeof(KuroRainComponent_Setup) == 0x000020, "Wrong size on KuroRainComponent_Setup");
static_assert(offsetof(KuroRainComponent_Setup, Meshes) == 0x000000, "Member 'KuroRainComponent_Setup::Meshes' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_Setup, Materials) == 0x000010, "Member 'KuroRainComponent_Setup::Materials' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetVectorFieldForceProcessor_Others
// 0x0020 (0x0020 - 0x0000)
struct KuroRainComponent_SetVectorFieldForceProcessor_Others final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPosScale;                                        // 0x0004(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InMoveSpeed;                                       // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForceSize;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetVectorFieldForceProcessor_Others) == 0x000004, "Wrong alignment on KuroRainComponent_SetVectorFieldForceProcessor_Others");
static_assert(sizeof(KuroRainComponent_SetVectorFieldForceProcessor_Others) == 0x000020, "Wrong size on KuroRainComponent_SetVectorFieldForceProcessor_Others");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_Others, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_Others::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_Others, InPosScale) == 0x000004, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_Others::InPosScale' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_Others, InMoveSpeed) == 0x000010, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_Others::InMoveSpeed' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_Others, InForceSize) == 0x00001C, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_Others::InForceSize' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetVectorFieldForceProcessor_VectorField
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_SetVectorFieldForceProcessor_VectorField final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D2[0x4];                                     // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVectorFieldStatic*                     InVectorField;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetVectorFieldForceProcessor_VectorField) == 0x000008, "Wrong alignment on KuroRainComponent_SetVectorFieldForceProcessor_VectorField");
static_assert(sizeof(KuroRainComponent_SetVectorFieldForceProcessor_VectorField) == 0x000010, "Wrong size on KuroRainComponent_SetVectorFieldForceProcessor_VectorField");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_VectorField, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_VectorField::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetVectorFieldForceProcessor_VectorField, InVectorField) == 0x000008, "Member 'KuroRainComponent_SetVectorFieldForceProcessor_VectorField::InVectorField' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRainComponent.SetWindProcessor
// 0x0010 (0x0010 - 0x0000)
struct KuroRainComponent_SetWindProcessor final
{
public:
	int32                                         ProcessorID;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WindVelocity;                                      // 0x0004(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRainComponent_SetWindProcessor) == 0x000004, "Wrong alignment on KuroRainComponent_SetWindProcessor");
static_assert(sizeof(KuroRainComponent_SetWindProcessor) == 0x000010, "Wrong size on KuroRainComponent_SetWindProcessor");
static_assert(offsetof(KuroRainComponent_SetWindProcessor, ProcessorID) == 0x000000, "Member 'KuroRainComponent_SetWindProcessor::ProcessorID' has a wrong offset!");
static_assert(offsetof(KuroRainComponent_SetWindProcessor, WindVelocity) == 0x000004, "Member 'KuroRainComponent_SetWindProcessor::WindVelocity' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.AddAdditionalClusteredStuff
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClusteredStuffDataAsset*               Asset;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff, Asset) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddAdditionalClusteredStuff::Asset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.AddPostprocessMaterial
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, Material) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::Material' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, Priority) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::Priority' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddPostprocessMaterial::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.AddWeatherDataType
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D5[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ClassType;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D6[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType, Identifier) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType::Identifier' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType, ClassType) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType::ClassType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_AddWeatherDataType::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ClearObjectFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Flags;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags, Param_Flags) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClearObjectFlags::Param_Flags' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ClipboardCopy_EditorOnly
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly final
{
public:
	class FString                                 Str;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly, Str) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClipboardCopy_EditorOnly::Str' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ClipboardPaste_EditorOnly
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly final
{
public:
	class FString                                 Dest;                                              // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly, Dest) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ClipboardPaste_EditorOnly::Dest' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharColorGroupArray
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray final
{
public:
	TArray<struct FKuroCharMaterialControllerColorGroup> Target;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          Start;                                             // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          Loop;                                              // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveLinearColor>          End;                                               // 0x0030(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray, Start) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray::Start' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray, Loop) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray::Loop' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray, End) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorGroupArray::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharColorParameter
// 0x0460 (0x0460 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter final
{
public:
	struct FKuroCharMaterialControllerColorParameter Target;                                            // 0x0000(0x0230)(Parm, OutParm, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0230(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D8[0x4];                                     // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveLinearColor                  ParameterValue;                                    // 0x0240(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter) == 0x000460, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter, ParameterName) == 0x000230, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter, ParameterValue) == 0x000240, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharColorParameter::ParameterValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharFloatGroup
// 0x0360 (0x0360 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup final
{
public:
	struct FKuroCharMaterialControllerFloatGroup  Target;                                            // 0x0000(0x01B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Start;                                             // 0x01B0(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Loop;                                              // 0x0240(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        End;                                               // 0x02D0(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup) == 0x000360, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup, Start) == 0x0001B0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup::Start' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup, Loop) == 0x000240, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup::Loop' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup, End) == 0x0002D0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroup::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharFloatGroupArray
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray final
{
public:
	TArray<struct FKuroCharMaterialControllerFloatGroup> Target;                                            // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                Start;                                             // 0x0010(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                Loop;                                              // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FKuroCurveFloat>                End;                                               // 0x0030(0x0010)(ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray, Start) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray::Start' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray, Loop) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray::Loop' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray, End) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatGroupArray::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharFloatParameter
// 0x0140 (0x0140 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter final
{
public:
	struct FKuroCharMaterialControllerFloatParameter Target;                                            // 0x0000(0x00A0)(Parm, OutParm, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x00A0(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D9[0x4];                                     // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKuroCurveFloat                        ParameterValue;                                    // 0x00B0(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter) == 0x000140, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter, ParameterName) == 0x0000A0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter, ParameterValue) == 0x0000B0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharFloatParameter::ParameterValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CopyKuroCharLinearColorGroup
// 0x0CC0 (0x0CC0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup final
{
public:
	struct FKuroCharMaterialControllerColorGroup  Target;                                            // 0x0000(0x0660)(Parm, OutParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Start;                                             // 0x0660(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  Loop;                                              // 0x0880(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveLinearColor                  End;                                               // 0x0AA0(0x0220)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup) == 0x000CC0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup, Start) == 0x000660, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup::Start' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup, Loop) == 0x000880, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup::Loop' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup, End) == 0x000AA0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CopyKuroCharLinearColorGroup::End' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.CreateGITransientActor
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdName;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToPlayer;                                   // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToEditorCamera;                             // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18DA[0x2];                                     // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EditorFolderPath;                                  // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18DB[0x4];                                     // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, IdName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::IdName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, bAttachToPlayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::bAttachToPlayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, bAttachToEditorCamera) == 0x000015, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::bAttachToEditorCamera' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, EditorFolderPath) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::EditorFolderPath' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor, ReturnValue) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_CreateGITransientActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.DeleteAll
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DeleteAll::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.DeleteKey
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DeleteKey::Key' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.DestroyGITransientActor
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdName;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18DC[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor, IdName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_DestroyGITransientActor::IdName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.FreezeWorldLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_FreezeWorldLevelStreaming::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorForwardVectorRef
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RefForwardVector;                                  // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18DD[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef, RefForwardVector) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRef::RefForwardVector' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorForwardVectorRefXYZ
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18DE[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ, X) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ::X' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ, Y) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ::Y' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ, Z) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorForwardVectorRefXYZ::Z' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorLocationRef
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RefLocation;                                       // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18DF[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef, RefLocation) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRef::RefLocation' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorLocationRefXYZ
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E0[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ, X) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ::X' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ, Y) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ::Y' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ, Z) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorLocationRefXYZ::Z' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorOfClass
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass, ActorClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass::ActorClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorOfClass::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetActorsInLevel
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel final
{
public:
	const class ULevel*                           InLevel;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel, InLevel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel::InLevel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel, ActorClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel::ActorClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel, OutActors) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetActorsInLevel::OutActors' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetAndAddCurveFloatSampleTask
// 0x00B0 (0x00B0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask final
{
public:
	int64                                         LastFrameHandle;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveFloat                        Curve;                                             // 0x0008(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0098(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x009C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         OutHandle;                                         // 0x00A0(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00A8(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E1[0x4];                                     // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask) == 0x0000B0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, LastFrameHandle) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::LastFrameHandle' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, Curve) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, Time) == 0x000098, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::Time' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, Default) == 0x00009C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::Default' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, OutHandle) == 0x0000A0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::OutHandle' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask, ReturnValue) == 0x0000A8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndAddCurveFloatSampleTask::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetAndroidRawResolution
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAndroidRawResolution::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetAssetsByPath
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath final
{
public:
	class FName                                   PackagePath;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecursive;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeOnlyOnDiskAssets;                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E2[0x2];                                     // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssetData>                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath, PackagePath) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath::PackagePath' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath, bRecursive) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath::bRecursive' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath, bIncludeOnlyOnDiskAssets) == 0x00000D, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath::bIncludeOnlyOnDiskAssets' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetAssetsByPath::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetBoneDirection
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E3[0xC];                                     // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection, SkeletalMeshComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection, BoneName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection::BoneName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetBoneDirection::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCacheCameraInfo
// 0x06A0 (0x06A0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo final
{
public:
	class APlayerCameraManager*                   Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E4[0x8];                                     // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       Inout;                                             // 0x0010(0x0690)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo) == 0x0006A0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo, Owner) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo::Owner' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo, Inout) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCacheCameraInfo::Inout' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCaveOrRoomState
// 0x0038 (0x0038 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnClosetDataLayer;                                 // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnCloseSubDataLayer;                               // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveOrRoomLoadType                           OutLoadType;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E5[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutLoadCoef;                                       // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E6[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState) == 0x000038, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, EnClosetDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::EnClosetDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, EnCloseSubDataLayer) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::EnCloseSubDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, OutLoadType) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::OutLoadType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, OutLoadCoef) == 0x00002C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::OutLoadCoef' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState, ReturnValue) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCaveOrRoomState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCharacterSectionCount
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E7[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount, Mesh) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount::Mesh' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionCount::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCharacterSectionInfo
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E8[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo, Mesh) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo::Mesh' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo, SectionIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo::SectionIndex' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionInfo::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCharacterSectionMaterialIndex
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex, SkeletalMesh) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex, SectionIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex::SectionIndex' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex, ReturnValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCharacterSectionMaterialIndex::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetColorFromGroup
// 0x0678 (0x0678 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup final
{
public:
	struct FKuroCharMaterialControllerColorGroup  Target;                                            // 0x0000(0x0660)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         Factor;                                            // 0x0660(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x0664(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0668(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup) == 0x000678, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup, Factor) == 0x000660, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup::Factor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup, Type) == 0x000664, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup::Type' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup, ReturnValue) == 0x000668, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetColorFromGroup::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetComponentPhysicalMaterial
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial, Component) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial::Component' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetComponentPhysicalMaterial::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetCVarFloat
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat final
{
public:
	class FString                                 CVarKey;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E9[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat, CVarKey) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat::CVarKey' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetCVarFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceHardwareLevel
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceHardwareLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceProfileBaseProfileName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileBaseProfileName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceProfileDeviceScore
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceScore::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetDeviceProfileDeviceType
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetDeviceProfileDeviceType::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetFloat
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetFloat final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetFloat");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetFloat");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloat::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat, DefaultValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloat::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloat, ReturnValue) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloat::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetFloatGromGroup
// 0x01C0 (0x01C0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup final
{
public:
	struct FKuroCharMaterialControllerFloatGroup  Target;                                            // 0x0000(0x01B0)(Parm, OutParm, NativeAccessSpecifierPublic)
	float                                         Factor;                                            // 0x01B0(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Type;                                              // 0x01B4(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x01B8(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EA[0x4];                                     // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup) == 0x0001C0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup, Target) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup::Target' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup, Factor) == 0x0001B0, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup::Factor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup, Type) == 0x0001B4, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup::Type' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup, ReturnValue) == 0x0001B8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetFloatGromGroup::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGameResolution
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGameResolution::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGameViewportSize
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGameViewportSize::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGITransientActor
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdName;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EB[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor, IdName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor::IdName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGITransientActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetGlobalGIActor
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetGlobalGIActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetInt
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetInt final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetInt");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetInt");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetInt::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetInt::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt, DefaultValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetInt::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetInt, ReturnValue) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetInt::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetKuroLandscapeParametersDataAsset
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset final
{
public:
	class UKuroLandscapeParametersData*           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetKuroLandscapeParametersDataAsset::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLevel
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLevel final
{
public:
	const class UWorld*                           World;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLevel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevel) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLevel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevel, World) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevel::World' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevel, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLevelActors
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors final
{
public:
	class ULevel*                                 InLevel;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors, InLevel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors::InLevel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelActors::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLevelEditorCameraLocationAndForward
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EC[0x7];                                     // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward, Position) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward::Position' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward, Rotation) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward::Rotation' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorCameraLocationAndForward::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetLevelEditorViewPortSize
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ViewPortSize;                                      // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18ED[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize, ViewPortSize) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize::ViewPortSize' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetLevelEditorViewPortSize::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetNiagaraParticleCount
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveEmitters;                                    // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveParticles;                                   // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount, NiagaraComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount, ActiveEmitters) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount::ActiveEmitters' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount, ActiveParticles) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetNiagaraParticleCount::ActiveParticles' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetObjectMaskedFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Mask;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags, Mask) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags::Mask' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags, ReturnValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetObjectMaskedFlags::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetOverlappingBoxCountForAllFoliageActors
// 0x0038 (0x0038 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UFoliageType*                     FoliageType;                                       // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0010(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EE[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors) == 0x000038, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, FoliageType) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::FoliageType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, Box) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::Box' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, Max) == 0x00002C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::Max' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors, ReturnValue) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetOverlappingBoxCountForAllFoliageActors::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPcLightCullParameters
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters final
{
public:
	class ULightComponent*                        LightComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMinDistance;                                  // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMaxDistance;                                  // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMinFade;                                      // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightMaxFade;                                      // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightMinDistance) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightMinDistance' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightMaxDistance) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightMaxDistance' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightMinFade) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightMinFade' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters, LightMaxFade) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPcLightCullParameters::LightMaxFade' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPhysicalGBRam
// 0x0004 (0x0004 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam) == 0x000004, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPhysicalGBRam::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPostProcessGIDataDebugInfo
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18EF[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPostprocessGIDebugInfo>        OutDAResult;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPostprocessGIDebugInfo>        OutOverrideResult;                                 // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F0[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, WorldPosition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, OutDAResult) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::OutDAResult' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, OutOverrideResult) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::OutOverrideResult' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo, ReturnValue) == 0x000038, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugInfo::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPostProcessGIDataDebugNames
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutDANames;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F1[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames, OutDANames) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames::OutDANames' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataDebugNames::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetPostProcessGIDataNames
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F2[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         OutDANames;                                        // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F3[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames, WorldPosition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames, OutDANames) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames::OutDANames' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames, ReturnValue) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetPostProcessGIDataNames::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIDeviceName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDeviceName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIDriverVersion
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIDriverVersion::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetRHIVendorName
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetRHIVendorName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSceneInteractionLevelActor
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor final
{
public:
	class ULevel*                                 InLevel;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor, InLevel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor::InLevel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSceneInteractionLevelActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSkeletalMaterialCount
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount final
{
public:
	class USkeletalMesh*                          Skel;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F4[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount, Skel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount::Skel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialCount::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSkeletalMaterialInterface
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface final
{
public:
	class USkeletalMesh*                          Skel;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F5[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface, Skel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface::Skel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface, MaterialIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialInterface::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSkeletalMaterialSlotName
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName final
{
public:
	class USkeletalMesh*                          Skel;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F6[0x4];                                     // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName, Skel) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName::Skel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName, MaterialIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName::MaterialIndex' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSkeletalMaterialSlotName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSpaceStateByPosition
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPoisition;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveOrRoom                                   OutSpaceType;                                      // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F7[0x3];                                     // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OutEnClosetDataLayer;                              // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutEnCloseSubDataLayer;                            // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F8[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, InPoisition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::InPoisition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, OutSpaceType) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::OutSpaceType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, OutEnClosetDataLayer) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::OutEnClosetDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, OutEnCloseSubDataLayer) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::OutEnCloseSubDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition, ReturnValue) == 0x000038, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSpaceStateByPosition::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetStreamingCells
// 0x0050 (0x0050 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWorldPartitionStreamingQuerySource    QuerySource;                                       // 0x0008(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FWorldPartitionRuntimeSpatialHashCell> OutCells;                                          // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18F9[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells) == 0x000050, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells, QuerySource) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells::QuerySource' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells, OutCells) == 0x000038, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells::OutCells' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells, ReturnValue) == 0x000048, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetStreamingCells::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetString
// 0x0038 (0x0038 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetString final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultValue;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetString) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetString");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetString) == 0x000038, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetString");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetString, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetString, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetString::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetString, DefaultValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetString::DefaultValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetString, ReturnValue) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetString::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetSubsystem
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWorldSubsystem>            WorldSubsystemClass;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldSubsystem*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem, WorldSubsystemClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem::WorldSubsystemClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetSubsystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetVectorParameterValueRef
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RefLinearColor;                                    // 0x001C(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FA[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef, Collection) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef::Collection' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef, ParameterName) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef, RefLinearColor) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRef::RefLinearColor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetVectorParameterValueRefRGBA
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefLinearColorR;                                   // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefLinearColorG;                                   // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefLinearColorB;                                   // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefLinearColorA;                                   // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FB[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, Collection) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::Collection' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, ParameterName) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, RefLinearColorR) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::RefLinearColorR' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, RefLinearColorG) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::RefLinearColorG' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, RefLinearColorB) == 0x000024, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::RefLinearColorB' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA, RefLinearColorA) == 0x000028, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetVectorParameterValueRefRGBA::RefLinearColorA' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWeatherDataRef
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Identifier;                                        // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FC[0x4];                                     // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef, Identifier) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef::Identifier' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWeatherDataRef::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorld
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorld) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorld");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorld) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorld");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorld, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorld, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorld::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldFeatureLevel
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroFeatureLevel                             ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FD[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldFeatureLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldPartition
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorldPartition*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartition::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldPartitionAllDataLayerNames
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionAllDataLayerNames::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldPartitionDataLayerNameByLabel
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InDataLayerLabel;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutDataLayerNamme;                                 // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel, InDataLayerLabel) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel::InDataLayerLabel' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel, OutDataLayerNamme) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldPartitionDataLayerNameByLabel::OutDataLayerNamme' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldSetting
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWorldSettings*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldSetting::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWorldType
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBP_EWorldType                                ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FE[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWorldType::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.GetWpWorldBound
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundMin;                                          // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundMax;                                          // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound, BoundMin) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound::BoundMin' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound, BoundMax) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_GetWpWorldBound::BoundMax' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.HasAllObjectFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Flags;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18FF[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags, Param_Flags) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasAllObjectFlags::Param_Flags' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.HasAnyObjectFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Flags;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1900[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags, Param_Flags) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasAnyObjectFlags::Param_Flags' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.HasKey
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_HasKey final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1901[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_HasKey");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_HasKey");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasKey::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasKey::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HasKey, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HasKey::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.HSP2RGB
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB final
{
public:
	struct FLinearColor                           Hsp;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB, Hsp) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB::Hsp' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_HSP2RGB::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsCurrentPlatformPC
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1902[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsCurrentPlatformPC::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsDistanceCull
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraEffectType*                     EffectType;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1903[0x3];                                     // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull, EffectType) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull::EffectType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull, Location) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull::Location' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull, ReturnValue) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsDistanceCull::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsEditorOnlyActor
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1904[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsEditorOnlyActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsNiagaraComplete
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete final
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1905[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete, NiagaraComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsNiagaraComplete::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsParticleComplete
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete final
{
public:
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1906[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete, ParticleSystemComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsParticleComplete::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsPositionInCaveOrRoom
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPoisition;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1907[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom, InPoisition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom::InPoisition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPositionInCaveOrRoom::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsPostprocessMaterialActive
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Handle;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1908[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive, Handle) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive::Handle' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive, ReturnValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsPostprocessMaterialActive::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsUsingNotSeparateCache
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsUsingNotSeparateCache::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsUsingParallaxCorrect
// 0x0001 (0x0001 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect) == 0x000001, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect) == 0x000001, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect, ReturnValue) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsUsingParallaxCorrect::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsWorldPartitionDataLayerEnable
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataLayerName;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1909[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable, DataLayerName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable::DataLayerName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionDataLayerEnable::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsWorldPartitionWorld
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190A[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWorldPartitionWorld::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.IsWpPlayerInCaveOrRoom
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190B[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_IsWpPlayerInCaveOrRoom::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.KuroMarkPackageDirty
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_KuroMarkPackageDirty::Object' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MakeSequencePlayer
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer final
{
public:
	class UActorSequenceComponent*                SequenceComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x0008(0x0014)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_190C[0x4];                                     // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorSequencePlayer*                   ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer, SequenceComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer::SequenceComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer, PlaybackSettings) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MakeSequencePlayer::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MaterialHasParameter_EditorOnly
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly final
{
public:
	class UMaterialInterface*                     MaterialInterface;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ParameterName;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190D[0x7];                                     // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly, MaterialInterface) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly::MaterialInterface' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly, ParameterName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly, ReturnValue) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MaterialHasParameter_EditorOnly::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MessageNotify_EditorOnly
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly final
{
public:
	class FText                                   Message;                                           // 0x0000(0x0018)(ConstParm, Parm, NativeAccessSpecifierPublic)
	class FName                                   Tile;                                              // 0x0018(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190E[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly, Message) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly::Message' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly, Tile) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MessageNotify_EditorOnly::Tile' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MoveCurveColorValueToOtherTime
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime final
{
public:
	class UCurveLinearColor*                      Curve;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SrcTime;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTime;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime, Curve) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime, SrcTime) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime::SrcTime' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime, TargetTime) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveColorValueToOtherTime::TargetTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.MoveCurveFloatValueToOtherTime
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime final
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SrcTime;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetTime;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime, Curve) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime, SrcTime) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime::SrcTime' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime, TargetTime) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_MoveCurveFloatValueToOtherTime::TargetTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.PackLinearColorRGBToVector2D
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D, Color) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D::Color' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_PackLinearColorRGBToVector2D::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ProjectWorldToScreenWithLevelEditorViewPort
// 0x0040 (0x0040 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190F[0xC];                                     // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Result;                                            // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1910[0xF];                                     // 0x0031(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort) == 0x000040, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort, WorldPosition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort, Result) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort::Result' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort, ReturnValue) == 0x000030, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPort::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ProjectWorldToScreenWithLevelEditorViewPortFloatRef
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultX;                                           // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultY;                                           // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultZ;                                           // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ResultW;                                           // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1911[0x3];                                     // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, WorldPosition) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::WorldPosition' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ResultX) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ResultX' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ResultY) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ResultY' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ResultZ) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ResultZ' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ResultW) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ResultW' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef, ReturnValue) == 0x000024, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ProjectWorldToScreenWithLevelEditorViewPortFloatRef::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.RemoveAdditionalClusteredStuff
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClusteredStuffDataAsset*               Asset;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff, Asset) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RemoveAdditionalClusteredStuff::Asset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.RemovePostprocessMaterial
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Handle;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1912[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial, Handle) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RemovePostprocessMaterial::Handle' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.RerunConstructionScripts
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RerunConstructionScripts::Actor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ResetParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem final
{
public:
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem, ParticleSystemComponent) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ResetParticleSystem::ParticleSystemComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.ResumeSomeWeatherAfterTeleport
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_ResumeSomeWeatherAfterTeleport::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.RGB2HSP
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP final
{
public:
	struct FLinearColor                           Rgb;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP, Rgb) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP::Rgb' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP, ReturnValue) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_RGB2HSP::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.Save
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_Save final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_Save) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_Save");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_Save) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_Save");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_Save, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_Save::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetActorUISceneRendering
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUISceneRendering;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1913[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering, Actor) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering::Actor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering, IsUISceneRendering) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetActorUISceneRendering::IsUISceneRendering' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetClusteredStuffVisible
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Visible;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1914[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible, Visible) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetClusteredStuffVisible::Visible' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetCVarFloat
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat final
{
public:
	class FString                                 CVarKey;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1915[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat, CVarKey) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat::CVarKey' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat, Value) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetCVarFloat::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetCVarInt32
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32 final
{
public:
	class FString                                 CVarKey;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1916[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32, CVarKey) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32::CVarKey' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32, Value) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetCVarInt32::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetFloat
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetFloat final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1917[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetFloat");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetFloat");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetFloat::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetFloat::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetFloat, Value) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetFloat::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetGITransientActorAttachment
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdName;                                            // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToPlayer;                                   // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttachToEditorCamera;                             // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1918[0x2];                                     // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment, IdName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment::IdName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment, bAttachToPlayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment::bAttachToPlayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment, bAttachToEditorCamera) == 0x000015, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGITransientActorAttachment::bAttachToEditorCamera' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetGlobalGITime
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1919[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime, Time) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime::Time' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime, ReturnValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetGlobalGITime::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetInt
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetInt final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191A[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetInt");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetInt");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetInt::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetInt::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetInt, Value) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetInt::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetIntsDataToRenderTarget
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 WriteData;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget, TextureRenderTarget) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget::TextureRenderTarget' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget, WriteData) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIntsDataToRenderTarget::WriteData' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetIsUsingInCaveOrIndoorShadow
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsing;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191B[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MobileCSMDistanceInCave;                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobileCSMDistanceOutCave;                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191C[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow, IsUsing) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow::IsUsing' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow, MobileCSMDistanceInCave) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow::MobileCSMDistanceInCave' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow, MobileCSMDistanceOutCave) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetIsUsingInCaveOrIndoorShadow::MobileCSMDistanceOutCave' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetLevelEditorCameraLocation
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191D[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation, Position) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation::Position' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation, ReturnValue) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetLevelEditorCameraLocation::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetNiagaraSkeletalMeshComponentWithoutWarning
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning final
{
public:
	class UNiagaraComponent*                      NiagaraSystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverrideName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning, NiagaraSystem) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning, OverrideName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning::OverrideName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning, SkeletalMeshComponent) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSkeletalMeshComponentWithoutWarning::SkeletalMeshComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetNiagaraSplineComponent
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent final
{
public:
	class UNiagaraComponent*                      NiagaraSystem;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverrideName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent, NiagaraSystem) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent::NiagaraSystem' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent, OverrideName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent::OverrideName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent, SplineComponent) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetNiagaraSplineComponent::SplineComponent' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetObjectFlags
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Param_Flags;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191E[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags, Object) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags::Object' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags, Param_Flags) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetObjectFlags::Param_Flags' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetSceneKuroMainPlayerLocation
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191F[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation, PlayerIndex) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneKuroMainPlayerLocation::PlayerIndex' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetSceneRenderingState
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSceneVisible;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1920[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState, bSceneVisible) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSceneRenderingState::bSceneVisible' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetString
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetString final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetString) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetString");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetString) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetString");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetString, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetString, Key) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetString::Key' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetString, Value) == 0x000018, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetString::Value' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetSunLensflareEnabled
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1921[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled, bEnabled) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetSunLensflareEnabled::bEnabled' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetTransformLocationInArray
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray final
{
public:
	TArray<struct FTransform>                     TransformArray;                                    // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Param_Index;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray, TransformArray) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray::TransformArray' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray, Param_Index) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray::Param_Index' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray, Location) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetTransformLocationInArray::Location' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetupVolumeSize
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize final
{
public:
	class AVolume*                                Volume;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0008(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1922[0x4];                                     // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize, Volume) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize::Volume' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize, Bounds) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetupVolumeSize::Bounds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetUsingInCaveOrIndoorShadow
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow final
{
public:
	class UDirectionalLightComponent*             LightComp;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsing;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1923[0x3];                                     // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MobileCSMDistanceOld;                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobileCSMDistanceNew;                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1924[0x4];                                     // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow, LightComp) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow::LightComp' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow, IsUsing) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow::IsUsing' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow, MobileCSMDistanceOld) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow::MobileCSMDistanceOld' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow, MobileCSMDistanceNew) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetUsingInCaveOrIndoorShadow::MobileCSMDistanceNew' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetVectorParameterValueRef
// 0x0030 (0x0030 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RefLinearColor;                                    // 0x001C(0x0010)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1925[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef) == 0x000030, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef, Collection) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef::Collection' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef, ParameterName) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef::ParameterName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef, RefLinearColor) == 0x00001C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetVectorParameterValueRef::RefLinearColor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetWorldPartitionDataLayerState
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DataLayerName;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActivate;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1926[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState, DataLayerName) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState::DataLayerName' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState, IsActivate) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionDataLayerState::IsActivate' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SetWorldPartitionStreamingEnable
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStreamingEnable;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1927[0x7];                                     // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable, bStreamingEnable) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SetWorldPartitionStreamingEnable::bStreamingEnable' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SortStringArray
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray final
{
public:
	TArray<class FString>                         InStringArray;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Descending;                                        // 0x0011(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1928[0x6];                                     // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray, InStringArray) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray::InStringArray' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray, SearchCase) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray::SearchCase' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray, Descending) == 0x000011, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SortStringArray::Descending' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SpawnActorFromClass
// 0x0070 (0x0070 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingOverride;                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1929[0x7];                                     // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTemporaryEditorActor;                             // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192A[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0060(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192B[0x8];                                     // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass) == 0x000010, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass) == 0x000070, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, ActorClass) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::ActorClass' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, SpawnTransform) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::SpawnTransform' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, CollisionHandlingOverride) == 0x000040, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::CollisionHandlingOverride' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, Owner) == 0x000048, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::Owner' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, Instigator) == 0x000050, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::Instigator' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, bTemporaryEditorActor) == 0x000058, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::bTemporaryEditorActor' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass, ReturnValue) == 0x000060, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnActorFromClass::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.SpawnTransientActor
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Param_Name;                                        // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FolderPath;                                        // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor, Param_Name) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor::Param_Name' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor, FolderPath) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor::FolderPath' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor, ReturnValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_SpawnTransientActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.StopSomeWeatherBeforeTeleport
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_StopSomeWeatherBeforeTeleport::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UnFreezeWorldLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UnFreezeWorldLevelStreaming::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UnpackVector2DToLinearColorRGB
// 0x0018 (0x0018 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB final
{
public:
	struct FVector2D                              Vector2D;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB) == 0x000004, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB) == 0x000018, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB, Vector2D) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB::Vector2D' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB, ReturnValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UnpackVector2DToLinearColorRGB::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateEffectTransform
// 0x0510 (0x0510 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform final
{
public:
	bool                                          ForceUpdate;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192C[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       LocationCurve;                                     // 0x0010(0x01A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       RotationCurve;                                     // 0x01B8(0x01A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       ScaleCurve;                                        // 0x0360(0x01A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0508(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192D[0x4];                                     // 0x050C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform) == 0x000510, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, ForceUpdate) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::ForceUpdate' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, SceneComponent) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::SceneComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, LocationCurve) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::LocationCurve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, RotationCurve) == 0x0001B8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::RotationCurve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, ScaleCurve) == 0x000360, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::ScaleCurve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform, Time) == 0x000508, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransform::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateEffectTransformLocation
// 0x01C0 (0x01C0 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation final
{
public:
	bool                                          ForceUpdate;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192E[0x7];                                     // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroCurveVector                       LocationCurve;                                     // 0x0010(0x01A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x01B8(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_192F[0x4];                                     // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation) == 0x0001C0, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation, ForceUpdate) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation::ForceUpdate' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation, SceneComponent) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation::SceneComponent' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation, LocationCurve) == 0x000010, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation::LocationCurve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation, Time) == 0x0001B8, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateEffectTransformLocation::Time' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateFoliageDataLayer
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InMobileLevel;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1930[0x4];                                     // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer, InMobileLevel) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateFoliageDataLayer::InMobileLevel' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateOrAddCurveColorValue
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue final
{
public:
	class UCurveLinearColor*                      Curve;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InValue;                                           // 0x000C(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1931[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue, Curve) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue, InTime) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue::InTime' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue, InValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveColorValue::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.UpdateOrAddCurveFloatValue
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue final
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTime;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InValue;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue, Curve) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue::Curve' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue, InTime) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue::InTime' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue, InValue) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_UpdateOrAddCurveFloatValue::InValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpBeginAdjustLoadRange
// 0x0010 (0x0010 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAdjustValue;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveOrRoomLoadType                           InLoadType;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomCoef;                                    // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1932[0x2];                                     // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange) == 0x000010, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange, InAdjustValue) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange::InAdjustValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange, InLoadType) == 0x00000C, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange::InLoadType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange, bUseCustomCoef) == 0x00000D, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginAdjustLoadRange::bUseCustomCoef' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpBeginEnterCaveOrRoom
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginEnterCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpBeginLeaveCaveOrRoom
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpBeginLeaveCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpCancelAdjustLoadRange
// 0x0008 (0x0008 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange) == 0x000008, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpCancelAdjustLoadRange::WorldContextObject' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpEnterCaveOrRoom
// 0x0028 (0x0028 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InAdjustValue;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECaveOrRoomLoadType                           LoadType;                                          // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomCoef;                                    // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1933[0x2];                                     // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom) == 0x000028, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, InAdjustValue) == 0x000020, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::InAdjustValue' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, LoadType) == 0x000024, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::LoadType' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom, bUseCustomCoef) == 0x000025, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpEnterCaveOrRoom::bUseCustomCoef' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpLeaveCaveOrRoom
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpLeaveCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroRenderingRuntimeBPPluginBPLibrary.WpPEnterCaveOrRoom
// 0x0020 (0x0020 - 0x0000)
struct KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseDataLayer;                                  // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EncloseSubDataLayer;                               // 0x0014(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom) == 0x000008, "Wrong alignment on KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom");
static_assert(sizeof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom) == 0x000020, "Wrong size on KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom, WorldContextObject) == 0x000000, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom, EncloseDataLayer) == 0x000008, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom::EncloseDataLayer' has a wrong offset!");
static_assert(offsetof(KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom, EncloseSubDataLayer) == 0x000014, "Member 'KuroRenderingRuntimeBPPluginBPLibrary_WpPEnterCaveOrRoom::EncloseSubDataLayer' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActor.OnSetState
// 0x0002 (0x0002 - 0x0000)
struct KuroSceneInteractionActor_OnSetState final
{
public:
	EKuroSceneInteractionState                    TargetState;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedTransition;                                    // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionActor_OnSetState) == 0x000001, "Wrong alignment on KuroSceneInteractionActor_OnSetState");
static_assert(sizeof(KuroSceneInteractionActor_OnSetState) == 0x000002, "Wrong size on KuroSceneInteractionActor_OnSetState");
static_assert(offsetof(KuroSceneInteractionActor_OnSetState, TargetState) == 0x000000, "Member 'KuroSceneInteractionActor_OnSetState::TargetState' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActor_OnSetState, NeedTransition) == 0x000001, "Member 'KuroSceneInteractionActor_OnSetState::NeedTransition' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.BindActorToLevelSequenceActor
// 0x0020 (0x0020 - 0x0000)
struct KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor final
{
public:
	class AActor*                                 ActorToBind;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BindingName;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor) == 0x000008, "Wrong alignment on KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor");
static_assert(sizeof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor) == 0x000020, "Wrong size on KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor");
static_assert(offsetof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor, ActorToBind) == 0x000000, "Member 'KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor::ActorToBind' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor, LevelSequenceActor) == 0x000008, "Member 'KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor, BindingName) == 0x000010, "Member 'KuroSceneInteractionActorSystem_BindActorToLevelSequenceActor::BindingName' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.CreateSceneInteractionLevel
// 0x0030 (0x0030 - 0x0000)
struct KuroSceneInteractionActorSystem_CreateSceneInteractionLevel final
{
public:
	class FString                                 InLevelName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroSceneInteractionState                    InitState;                                         // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1939[0x3];                                     // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0014(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0020(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x002C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel) == 0x000008, "Wrong alignment on KuroSceneInteractionActorSystem_CreateSceneInteractionLevel");
static_assert(sizeof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel) == 0x000030, "Wrong size on KuroSceneInteractionActorSystem_CreateSceneInteractionLevel");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, InLevelName) == 0x000000, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::InLevelName' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, InitState) == 0x000010, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::InitState' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, Location) == 0x000014, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::Location' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, Rotation) == 0x000020, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::Rotation' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_CreateSceneInteractionLevel, ReturnValue) == 0x00002C, "Member 'KuroSceneInteractionActorSystem_CreateSceneInteractionLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.DestroySceneInteractionLevel
// 0x0008 (0x0008 - 0x0000)
struct KuroSceneInteractionActorSystem_DestroySceneInteractionLevel final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193A[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSceneInteractionActorSystem_DestroySceneInteractionLevel) == 0x000004, "Wrong alignment on KuroSceneInteractionActorSystem_DestroySceneInteractionLevel");
static_assert(sizeof(KuroSceneInteractionActorSystem_DestroySceneInteractionLevel) == 0x000008, "Wrong size on KuroSceneInteractionActorSystem_DestroySceneInteractionLevel");
static_assert(offsetof(KuroSceneInteractionActorSystem_DestroySceneInteractionLevel, HandleId) == 0x000000, "Member 'KuroSceneInteractionActorSystem_DestroySceneInteractionLevel::HandleId' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_DestroySceneInteractionLevel, ReturnValue) == 0x000004, "Member 'KuroSceneInteractionActorSystem_DestroySceneInteractionLevel::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.GetCurrentState
// 0x0008 (0x0008 - 0x0000)
struct KuroSceneInteractionActorSystem_GetCurrentState final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroSceneInteractionState                    ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193B[0x3];                                     // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSceneInteractionActorSystem_GetCurrentState) == 0x000004, "Wrong alignment on KuroSceneInteractionActorSystem_GetCurrentState");
static_assert(sizeof(KuroSceneInteractionActorSystem_GetCurrentState) == 0x000008, "Wrong size on KuroSceneInteractionActorSystem_GetCurrentState");
static_assert(offsetof(KuroSceneInteractionActorSystem_GetCurrentState, HandleId) == 0x000000, "Member 'KuroSceneInteractionActorSystem_GetCurrentState::HandleId' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_GetCurrentState, ReturnValue) == 0x000004, "Member 'KuroSceneInteractionActorSystem_GetCurrentState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.SetSequenceWithTargetLevelActor
// 0x0018 (0x0018 - 0x0000)
struct KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor final
{
public:
	class ALevelSequenceActor*                    LevelSequenceActor;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelSequence*                         InSequence;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetLevelActor;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor) == 0x000008, "Wrong alignment on KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor");
static_assert(sizeof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor) == 0x000018, "Wrong size on KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor");
static_assert(offsetof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor, LevelSequenceActor) == 0x000000, "Member 'KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor::LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor, InSequence) == 0x000008, "Member 'KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor::InSequence' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor, TargetLevelActor) == 0x000010, "Member 'KuroSceneInteractionActorSystem_SetSequenceWithTargetLevelActor::TargetLevelActor' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneInteractionActorSystem.SwitchToState
// 0x0008 (0x0008 - 0x0000)
struct KuroSceneInteractionActorSystem_SwitchToState final
{
public:
	int32                                         HandleId;                                          // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroSceneInteractionState                    TargetState;                                       // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedTransition;                                    // 0x0005(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0006(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_193C[0x1];                                     // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroSceneInteractionActorSystem_SwitchToState) == 0x000004, "Wrong alignment on KuroSceneInteractionActorSystem_SwitchToState");
static_assert(sizeof(KuroSceneInteractionActorSystem_SwitchToState) == 0x000008, "Wrong size on KuroSceneInteractionActorSystem_SwitchToState");
static_assert(offsetof(KuroSceneInteractionActorSystem_SwitchToState, HandleId) == 0x000000, "Member 'KuroSceneInteractionActorSystem_SwitchToState::HandleId' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SwitchToState, TargetState) == 0x000004, "Member 'KuroSceneInteractionActorSystem_SwitchToState::TargetState' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SwitchToState, NeedTransition) == 0x000005, "Member 'KuroSceneInteractionActorSystem_SwitchToState::NeedTransition' has a wrong offset!");
static_assert(offsetof(KuroSceneInteractionActorSystem_SwitchToState, ReturnValue) == 0x000006, "Member 'KuroSceneInteractionActorSystem_SwitchToState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroSceneRainActor.SetCurrentRain
// 0x0014 (0x0014 - 0x0000)
struct KuroSceneRainActor_SetCurrentRain final
{
public:
	float                                         InDensity;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGravity;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InWindSpeed;                                       // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroSceneRainActor_SetCurrentRain) == 0x000004, "Wrong alignment on KuroSceneRainActor_SetCurrentRain");
static_assert(sizeof(KuroSceneRainActor_SetCurrentRain) == 0x000014, "Wrong size on KuroSceneRainActor_SetCurrentRain");
static_assert(offsetof(KuroSceneRainActor_SetCurrentRain, InDensity) == 0x000000, "Member 'KuroSceneRainActor_SetCurrentRain::InDensity' has a wrong offset!");
static_assert(offsetof(KuroSceneRainActor_SetCurrentRain, InGravity) == 0x000004, "Member 'KuroSceneRainActor_SetCurrentRain::InGravity' has a wrong offset!");
static_assert(offsetof(KuroSceneRainActor_SetCurrentRain, InWindSpeed) == 0x000008, "Member 'KuroSceneRainActor_SetCurrentRain::InWindSpeed' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroTrailDrawerComponent.OnDrawerEnd
// 0x0001 (0x0001 - 0x0000)
struct KuroTrailDrawerComponent_OnDrawerEnd final
{
public:
	EEndPlayReason                                EndPlayReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTrailDrawerComponent_OnDrawerEnd) == 0x000001, "Wrong alignment on KuroTrailDrawerComponent_OnDrawerEnd");
static_assert(sizeof(KuroTrailDrawerComponent_OnDrawerEnd) == 0x000001, "Wrong size on KuroTrailDrawerComponent_OnDrawerEnd");
static_assert(offsetof(KuroTrailDrawerComponent_OnDrawerEnd, EndPlayReason) == 0x000000, "Member 'KuroTrailDrawerComponent_OnDrawerEnd::EndPlayReason' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroTrailDrawerComponent.OnDrawerTick
// 0x0004 (0x0004 - 0x0000)
struct KuroTrailDrawerComponent_OnDrawerTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTrailDrawerComponent_OnDrawerTick) == 0x000004, "Wrong alignment on KuroTrailDrawerComponent_OnDrawerTick");
static_assert(sizeof(KuroTrailDrawerComponent_OnDrawerTick) == 0x000004, "Wrong size on KuroTrailDrawerComponent_OnDrawerTick");
static_assert(offsetof(KuroTrailDrawerComponent_OnDrawerTick, DeltaTime) == 0x000000, "Member 'KuroTrailDrawerComponent_OnDrawerTick::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroTrailSensorComponent.OnSensorEnd
// 0x0001 (0x0001 - 0x0000)
struct KuroTrailSensorComponent_OnSensorEnd final
{
public:
	EEndPlayReason                                EndPlayReason;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTrailSensorComponent_OnSensorEnd) == 0x000001, "Wrong alignment on KuroTrailSensorComponent_OnSensorEnd");
static_assert(sizeof(KuroTrailSensorComponent_OnSensorEnd) == 0x000001, "Wrong size on KuroTrailSensorComponent_OnSensorEnd");
static_assert(offsetof(KuroTrailSensorComponent_OnSensorEnd, EndPlayReason) == 0x000000, "Member 'KuroTrailSensorComponent_OnSensorEnd::EndPlayReason' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroTrailSensorComponent.OnSensorTick
// 0x0004 (0x0004 - 0x0000)
struct KuroTrailSensorComponent_OnSensorTick final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroTrailSensorComponent_OnSensorTick) == 0x000004, "Wrong alignment on KuroTrailSensorComponent_OnSensorTick");
static_assert(sizeof(KuroTrailSensorComponent_OnSensorTick) == 0x000004, "Wrong size on KuroTrailSensorComponent_OnSensorTick");
static_assert(offsetof(KuroTrailSensorComponent_OnSensorTick, DeltaTime) == 0x000000, "Member 'KuroTrailSensorComponent_OnSensorTick::DeltaTime' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetKuroUiSceneSystem
// 0x0010 (0x0010 - 0x0000)
struct KuroUiSceneSystem_GetKuroUiSceneSystem final
{
public:
	class UWorld*                                 InWorld;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UKuroUiSceneSystem*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_GetKuroUiSceneSystem) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetKuroUiSceneSystem");
static_assert(sizeof(KuroUiSceneSystem_GetKuroUiSceneSystem) == 0x000010, "Wrong size on KuroUiSceneSystem_GetKuroUiSceneSystem");
static_assert(offsetof(KuroUiSceneSystem_GetKuroUiSceneSystem, InWorld) == 0x000000, "Member 'KuroUiSceneSystem_GetKuroUiSceneSystem::InWorld' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_GetKuroUiSceneSystem, ReturnValue) == 0x000008, "Member 'KuroUiSceneSystem_GetKuroUiSceneSystem::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.EndUiSceneRendering
// 0x0001 (0x0001 - 0x0000)
struct KuroUiSceneSystem_EndUiSceneRendering final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_EndUiSceneRendering) == 0x000001, "Wrong alignment on KuroUiSceneSystem_EndUiSceneRendering");
static_assert(sizeof(KuroUiSceneSystem_EndUiSceneRendering) == 0x000001, "Wrong size on KuroUiSceneSystem_EndUiSceneRendering");
static_assert(offsetof(KuroUiSceneSystem_EndUiSceneRendering, ReturnValue) == 0x000000, "Member 'KuroUiSceneSystem_EndUiSceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetCurrentUiSceneRenderingSceneName
// 0x0010 (0x0010 - 0x0000)
struct KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName");
static_assert(sizeof(KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName) == 0x000010, "Wrong size on KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName");
static_assert(offsetof(KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName, ReturnValue) == 0x000000, "Member 'KuroUiSceneSystem_GetCurrentUiSceneRenderingSceneName::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetUiSceneLoadingState
// 0x0018 (0x0018 - 0x0000)
struct KuroUiSceneSystem_GetUiSceneLoadingState final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKuroUiSceneLoadingState                      ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1940[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_GetUiSceneLoadingState) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetUiSceneLoadingState");
static_assert(sizeof(KuroUiSceneSystem_GetUiSceneLoadingState) == 0x000018, "Wrong size on KuroUiSceneSystem_GetUiSceneLoadingState");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneLoadingState, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_GetUiSceneLoadingState::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneLoadingState, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_GetUiSceneLoadingState::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetUiSceneRootActor
// 0x0018 (0x0018 - 0x0000)
struct KuroUiSceneSystem_GetUiSceneRootActor final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AKuroUiSceneRootActor*                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_GetUiSceneRootActor) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetUiSceneRootActor");
static_assert(sizeof(KuroUiSceneSystem_GetUiSceneRootActor) == 0x000018, "Wrong size on KuroUiSceneSystem_GetUiSceneRootActor");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneRootActor, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_GetUiSceneRootActor::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneRootActor, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_GetUiSceneRootActor::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetUiSceneStates
// 0x0050 (0x0050 - 0x0000)
struct KuroUiSceneSystem_GetUiSceneStates final
{
public:
	TMap<class FString, EKuroUiSceneLoadingState> ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_GetUiSceneStates) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetUiSceneStates");
static_assert(sizeof(KuroUiSceneSystem_GetUiSceneStates) == 0x000050, "Wrong size on KuroUiSceneSystem_GetUiSceneStates");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneStates, ReturnValue) == 0x000000, "Member 'KuroUiSceneSystem_GetUiSceneStates::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.GetUiSceneWorldPositionOffset
// 0x0020 (0x0020 - 0x0000)
struct KuroUiSceneSystem_GetUiSceneWorldPositionOffset final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1941[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_GetUiSceneWorldPositionOffset) == 0x000008, "Wrong alignment on KuroUiSceneSystem_GetUiSceneWorldPositionOffset");
static_assert(sizeof(KuroUiSceneSystem_GetUiSceneWorldPositionOffset) == 0x000020, "Wrong size on KuroUiSceneSystem_GetUiSceneWorldPositionOffset");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneWorldPositionOffset, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_GetUiSceneWorldPositionOffset::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_GetUiSceneWorldPositionOffset, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_GetUiSceneWorldPositionOffset::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.InvokeSceneVisible
// 0x0010 (0x0010 - 0x0000)
struct KuroUiSceneSystem_InvokeSceneVisible final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroUiSceneSystem_InvokeSceneVisible) == 0x000008, "Wrong alignment on KuroUiSceneSystem_InvokeSceneVisible");
static_assert(sizeof(KuroUiSceneSystem_InvokeSceneVisible) == 0x000010, "Wrong size on KuroUiSceneSystem_InvokeSceneVisible");
static_assert(offsetof(KuroUiSceneSystem_InvokeSceneVisible, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_InvokeSceneVisible::ScenePath' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.PreloadUiScene
// 0x0020 (0x0020 - 0x0000)
struct KuroUiSceneSystem_PreloadUiScene final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPositionOffset;                               // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1942[0x4];                                     // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_PreloadUiScene) == 0x000008, "Wrong alignment on KuroUiSceneSystem_PreloadUiScene");
static_assert(sizeof(KuroUiSceneSystem_PreloadUiScene) == 0x000020, "Wrong size on KuroUiSceneSystem_PreloadUiScene");
static_assert(offsetof(KuroUiSceneSystem_PreloadUiScene, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_PreloadUiScene::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_PreloadUiScene, WorldPositionOffset) == 0x000010, "Member 'KuroUiSceneSystem_PreloadUiScene::WorldPositionOffset' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.StartUiSceneRendering
// 0x0018 (0x0018 - 0x0000)
struct KuroUiSceneSystem_StartUiSceneRendering final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1943[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_StartUiSceneRendering) == 0x000008, "Wrong alignment on KuroUiSceneSystem_StartUiSceneRendering");
static_assert(sizeof(KuroUiSceneSystem_StartUiSceneRendering) == 0x000018, "Wrong size on KuroUiSceneSystem_StartUiSceneRendering");
static_assert(offsetof(KuroUiSceneSystem_StartUiSceneRendering, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_StartUiSceneRendering::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_StartUiSceneRendering, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_StartUiSceneRendering::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroUiSceneSystem.UnloadUiScene
// 0x0018 (0x0018 - 0x0000)
struct KuroUiSceneSystem_UnloadUiScene final
{
public:
	class FString                                 ScenePath;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1944[0x7];                                     // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KuroUiSceneSystem_UnloadUiScene) == 0x000008, "Wrong alignment on KuroUiSceneSystem_UnloadUiScene");
static_assert(sizeof(KuroUiSceneSystem_UnloadUiScene) == 0x000018, "Wrong size on KuroUiSceneSystem_UnloadUiScene");
static_assert(offsetof(KuroUiSceneSystem_UnloadUiScene, ScenePath) == 0x000000, "Member 'KuroUiSceneSystem_UnloadUiScene::ScenePath' has a wrong offset!");
static_assert(offsetof(KuroUiSceneSystem_UnloadUiScene, ReturnValue) == 0x000010, "Member 'KuroUiSceneSystem_UnloadUiScene::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldInfo.BP_GetInstance
// 0x0018 (0x0018 - 0x0000)
struct KuroWorldInfo_BP_GetInstance final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoCreate;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1946[0x7];                                     // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AKuroWorldInfo*                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldInfo_BP_GetInstance) == 0x000008, "Wrong alignment on KuroWorldInfo_BP_GetInstance");
static_assert(sizeof(KuroWorldInfo_BP_GetInstance) == 0x000018, "Wrong size on KuroWorldInfo_BP_GetInstance");
static_assert(offsetof(KuroWorldInfo_BP_GetInstance, WorldContextObject) == 0x000000, "Member 'KuroWorldInfo_BP_GetInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KuroWorldInfo_BP_GetInstance, AutoCreate) == 0x000008, "Member 'KuroWorldInfo_BP_GetInstance::AutoCreate' has a wrong offset!");
static_assert(offsetof(KuroWorldInfo_BP_GetInstance, ReturnValue) == 0x000010, "Member 'KuroWorldInfo_BP_GetInstance::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldInfo.GetSLInfo
// 0x0040 (0x0040 - 0x0000)
struct KuroWorldInfo_GetSLInfo final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKuroStreamingLevelInfo                LandscapeInfo;                                     // 0x000C(0x0030)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x003C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldInfo_GetSLInfo) == 0x000004, "Wrong alignment on KuroWorldInfo_GetSLInfo");
static_assert(sizeof(KuroWorldInfo_GetSLInfo) == 0x000040, "Wrong size on KuroWorldInfo_GetSLInfo");
static_assert(offsetof(KuroWorldInfo_GetSLInfo, PackageName) == 0x000000, "Member 'KuroWorldInfo_GetSLInfo::PackageName' has a wrong offset!");
static_assert(offsetof(KuroWorldInfo_GetSLInfo, LandscapeInfo) == 0x00000C, "Member 'KuroWorldInfo_GetSLInfo::LandscapeInfo' has a wrong offset!");
static_assert(offsetof(KuroWorldInfo_GetSLInfo, ReturnValue) == 0x00003C, "Member 'KuroWorldInfo_GetSLInfo::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldInfo.GetLandscapeInfo
// 0x0058 (0x0058 - 0x0000)
struct KuroWorldInfo_GetLandscapeInfo final
{
public:
	struct FKuroLandscapeInfo                     LandscapeInfo;                                     // 0x0000(0x0058)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldInfo_GetLandscapeInfo) == 0x000004, "Wrong alignment on KuroWorldInfo_GetLandscapeInfo");
static_assert(sizeof(KuroWorldInfo_GetLandscapeInfo) == 0x000058, "Wrong size on KuroWorldInfo_GetLandscapeInfo");
static_assert(offsetof(KuroWorldInfo_GetLandscapeInfo, LandscapeInfo) == 0x000000, "Member 'KuroWorldInfo_GetLandscapeInfo::LandscapeInfo' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldPartitionPreviewManager.AddPreviewActorType
// 0x0008 (0x0008 - 0x0000)
struct KuroWorldPartitionPreviewManager_AddPreviewActorType final
{
public:
	TSubclassOf<class AActor>                     Param_Class;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldPartitionPreviewManager_AddPreviewActorType) == 0x000008, "Wrong alignment on KuroWorldPartitionPreviewManager_AddPreviewActorType");
static_assert(sizeof(KuroWorldPartitionPreviewManager_AddPreviewActorType) == 0x000008, "Wrong size on KuroWorldPartitionPreviewManager_AddPreviewActorType");
static_assert(offsetof(KuroWorldPartitionPreviewManager_AddPreviewActorType, Param_Class) == 0x000000, "Member 'KuroWorldPartitionPreviewManager_AddPreviewActorType::Param_Class' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldPartitionPreviewManager.RemovePreviewActorType
// 0x0008 (0x0008 - 0x0000)
struct KuroWorldPartitionPreviewManager_RemovePreviewActorType final
{
public:
	TSubclassOf<class AActor>                     Param_Class;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldPartitionPreviewManager_RemovePreviewActorType) == 0x000008, "Wrong alignment on KuroWorldPartitionPreviewManager_RemovePreviewActorType");
static_assert(sizeof(KuroWorldPartitionPreviewManager_RemovePreviewActorType) == 0x000008, "Wrong size on KuroWorldPartitionPreviewManager_RemovePreviewActorType");
static_assert(offsetof(KuroWorldPartitionPreviewManager_RemovePreviewActorType, Param_Class) == 0x000000, "Member 'KuroWorldPartitionPreviewManager_RemovePreviewActorType::Param_Class' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.KuroWorldPartitionPreviewManager.SetPreviewMobile
// 0x0001 (0x0001 - 0x0000)
struct KuroWorldPartitionPreviewManager_SetPreviewMobile final
{
public:
	bool                                          PreviewMobile;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KuroWorldPartitionPreviewManager_SetPreviewMobile) == 0x000001, "Wrong alignment on KuroWorldPartitionPreviewManager_SetPreviewMobile");
static_assert(sizeof(KuroWorldPartitionPreviewManager_SetPreviewMobile) == 0x000001, "Wrong size on KuroWorldPartitionPreviewManager_SetPreviewMobile");
static_assert(offsetof(KuroWorldPartitionPreviewManager_SetPreviewMobile, PreviewMobile) == 0x000000, "Member 'KuroWorldPartitionPreviewManager_SetPreviewMobile::PreviewMobile' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.SpawnThunderInWorld
// 0x0018 (0x0018 - 0x0000)
struct ThunderGenerator_SpawnThunderInWorld final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttack;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194C[0x3];                                     // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ThunderGenerator_SpawnThunderInWorld) == 0x000008, "Wrong alignment on ThunderGenerator_SpawnThunderInWorld");
static_assert(sizeof(ThunderGenerator_SpawnThunderInWorld) == 0x000018, "Wrong size on ThunderGenerator_SpawnThunderInWorld");
static_assert(offsetof(ThunderGenerator_SpawnThunderInWorld, WorldContextObject) == 0x000000, "Member 'ThunderGenerator_SpawnThunderInWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_SpawnThunderInWorld, Location) == 0x000008, "Member 'ThunderGenerator_SpawnThunderInWorld::Location' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_SpawnThunderInWorld, bAttack) == 0x000014, "Member 'ThunderGenerator_SpawnThunderInWorld::bAttack' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.CalculateThunderPosition
// 0x0040 (0x0040 - 0x0000)
struct ThunderGenerator_CalculateThunderPosition final
{
public:
	struct FTransform                             CameraTransform;                                   // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OutPosition;                                       // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194D[0x3];                                     // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ThunderGenerator_CalculateThunderPosition) == 0x000010, "Wrong alignment on ThunderGenerator_CalculateThunderPosition");
static_assert(sizeof(ThunderGenerator_CalculateThunderPosition) == 0x000040, "Wrong size on ThunderGenerator_CalculateThunderPosition");
static_assert(offsetof(ThunderGenerator_CalculateThunderPosition, CameraTransform) == 0x000000, "Member 'ThunderGenerator_CalculateThunderPosition::CameraTransform' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_CalculateThunderPosition, OutPosition) == 0x000030, "Member 'ThunderGenerator_CalculateThunderPosition::OutPosition' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_CalculateThunderPosition, ReturnValue) == 0x00003C, "Member 'ThunderGenerator_CalculateThunderPosition::ReturnValue' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.OnReceiveThunderAttack
// 0x0010 (0x0010 - 0x0000)
struct ThunderGenerator_OnReceiveThunderAttack final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttack;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194E[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ThunderGenerator_OnReceiveThunderAttack) == 0x000004, "Wrong alignment on ThunderGenerator_OnReceiveThunderAttack");
static_assert(sizeof(ThunderGenerator_OnReceiveThunderAttack) == 0x000010, "Wrong size on ThunderGenerator_OnReceiveThunderAttack");
static_assert(offsetof(ThunderGenerator_OnReceiveThunderAttack, Location) == 0x000000, "Member 'ThunderGenerator_OnReceiveThunderAttack::Location' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_OnReceiveThunderAttack, bAttack) == 0x00000C, "Member 'ThunderGenerator_OnReceiveThunderAttack::bAttack' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.OnUpdateThunderEffect
// 0x0004 (0x0004 - 0x0000)
struct ThunderGenerator_OnUpdateThunderEffect final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ThunderGenerator_OnUpdateThunderEffect) == 0x000004, "Wrong alignment on ThunderGenerator_OnUpdateThunderEffect");
static_assert(sizeof(ThunderGenerator_OnUpdateThunderEffect) == 0x000004, "Wrong size on ThunderGenerator_OnUpdateThunderEffect");
static_assert(offsetof(ThunderGenerator_OnUpdateThunderEffect, DeltaSeconds) == 0x000000, "Member 'ThunderGenerator_OnUpdateThunderEffect::DeltaSeconds' has a wrong offset!");

// Function KuroRenderingRuntimeBPPlugin.ThunderGenerator.SpawnThunder
// 0x0010 (0x0010 - 0x0000)
struct ThunderGenerator_SpawnThunder final
{
public:
	struct FVector                                HitLocation;                                       // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttack;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194F[0x3];                                     // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ThunderGenerator_SpawnThunder) == 0x000004, "Wrong alignment on ThunderGenerator_SpawnThunder");
static_assert(sizeof(ThunderGenerator_SpawnThunder) == 0x000010, "Wrong size on ThunderGenerator_SpawnThunder");
static_assert(offsetof(ThunderGenerator_SpawnThunder, HitLocation) == 0x000000, "Member 'ThunderGenerator_SpawnThunder::HitLocation' has a wrong offset!");
static_assert(offsetof(ThunderGenerator_SpawnThunder, bAttack) == 0x00000C, "Member 'ThunderGenerator_SpawnThunder::bAttack' has a wrong offset!");

}

