#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: KuroMovement

#include "Basic.hpp"

#include "KuroMovement_classes.hpp"
#include "KuroMovement_parameters.hpp"


namespace SDK
{

// Function KuroMovement.KuroClimbObject.ClimbBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::ClimbBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "ClimbBlock");

	Params::KuroClimbObject_ClimbBlock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.ConfirmMove
// (Final, Native, Public, BlueprintCallable)

void UKuroClimbObject::ConfirmMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "ConfirmMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.ExitClimb
// (Final, Native, Public, BlueprintCallable)

void UKuroClimbObject::ExitClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "ExitClimb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.GetSafetyLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKuroClimbObject::GetSafetyLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "GetSafetyLocation");

	Params::KuroClimbObject_GetSafetyLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.GetSecondMoveOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKuroClimbObject::GetSecondMoveOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "GetSecondMoveOffset");

	Params::KuroClimbObject_GetSecondMoveOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.InitBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UShapeComponent*                  InShapeComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       InClimbChannel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  BaseLocations                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   InSphereRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InActorToWallDist                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDetectLength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSafetyHalfHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSafetyRadius                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitBase(class UShapeComponent* InShapeComp, ECollisionChannel InClimbChannel, const TArray<struct FVector>& BaseLocations, float InSphereRadius, float InActorToWallDist, float InDetectLength, float InSafetyHalfHeight, float InSafetyRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitBase");

	Params::KuroClimbObject_InitBase Parms{};

	Parms.InShapeComp = InShapeComp;
	Parms.InClimbChannel = InClimbChannel;
	Parms.BaseLocations = std::move(BaseLocations);
	Parms.InSphereRadius = InSphereRadius;
	Parms.InActorToWallDist = InActorToWallDist;
	Parms.InDetectLength = InDetectLength;
	Parms.InSafetyHalfHeight = InSafetyHalfHeight;
	Parms.InSafetyRadius = InSafetyRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.InitBlockUps
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InBlockUpOffset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlockUpDetectRadius                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlockUpDetectDistance                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlockUpBackDistance                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InBlockUpBackMin                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InBlockUpFinalMove                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlockUpVerticalRangeMin                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlockUpVerticalRangeMax                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitBlockUps(const struct FVector& InBlockUpOffset, float InBlockUpDetectRadius, float InBlockUpDetectDistance, float InBlockUpBackDistance, float InBlockUpBackMin, const struct FVector& InBlockUpFinalMove, float BlockUpVerticalRangeMin, float BlockUpVerticalRangeMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitBlockUps");

	Params::KuroClimbObject_InitBlockUps Parms{};

	Parms.InBlockUpOffset = std::move(InBlockUpOffset);
	Parms.InBlockUpDetectRadius = InBlockUpDetectRadius;
	Parms.InBlockUpDetectDistance = InBlockUpDetectDistance;
	Parms.InBlockUpBackDistance = InBlockUpBackDistance;
	Parms.InBlockUpBackMin = InBlockUpBackMin;
	Parms.InBlockUpFinalMove = std::move(InBlockUpFinalMove);
	Parms.BlockUpVerticalRangeMin = BlockUpVerticalRangeMin;
	Parms.BlockUpVerticalRangeMax = BlockUpVerticalRangeMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.InitClimbSafety
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHalfHeight                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitClimbSafety(float InRadius, float InHalfHeight, float InMaxOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitClimbSafety");

	Params::KuroClimbObject_InitClimbSafety Parms{};

	Parms.InRadius = InRadius;
	Parms.InHalfHeight = InHalfHeight;
	Parms.InMaxOffset = InMaxOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.InitSprintVault
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   InForwardBlockHeight                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForwardBlockRadius                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForwardBlockDistanceMin                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForwardBlockDistanceMax                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InSprintVaultMoveOffset                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHeightMin                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InHeightMax                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSprintVaultLongNeedDistance                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSprintVaultLongHeight                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         InBlockChannel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintVaultLongMin                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintVaultLongMax                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintVaultBlockMaxAngle                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitSprintVault(float InForwardBlockHeight, float InForwardBlockRadius, float InForwardBlockDistanceMin, float InForwardBlockDistanceMax, const struct FVector& InSprintVaultMoveOffset, float InHeightMin, float InHeightMax, float InSprintVaultLongNeedDistance, float InSprintVaultLongHeight, ETraceTypeQuery InBlockChannel, float SprintVaultLongMin, float SprintVaultLongMax, float SprintVaultBlockMaxAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitSprintVault");

	Params::KuroClimbObject_InitSprintVault Parms{};

	Parms.InForwardBlockHeight = InForwardBlockHeight;
	Parms.InForwardBlockRadius = InForwardBlockRadius;
	Parms.InForwardBlockDistanceMin = InForwardBlockDistanceMin;
	Parms.InForwardBlockDistanceMax = InForwardBlockDistanceMax;
	Parms.InSprintVaultMoveOffset = std::move(InSprintVaultMoveOffset);
	Parms.InHeightMin = InHeightMin;
	Parms.InHeightMax = InHeightMax;
	Parms.InSprintVaultLongNeedDistance = InSprintVaultLongNeedDistance;
	Parms.InSprintVaultLongHeight = InSprintVaultLongHeight;
	Parms.InBlockChannel = InBlockChannel;
	Parms.SprintVaultLongMin = SprintVaultLongMin;
	Parms.SprintVaultLongMax = SprintVaultLongMax;
	Parms.SprintVaultBlockMaxAngle = SprintVaultBlockMaxAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.InitUpArrives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  InUpArriveMoveOffsets                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           InHeightMins                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           InHeightMaxs                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UKuroClimbObject::InitUpArrives(const TArray<struct FVector>& InUpArriveMoveOffsets, const TArray<float>& InHeightMins, const TArray<float>& InHeightMaxs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "InitUpArrives");

	Params::KuroClimbObject_InitUpArrives Parms{};

	Parms.InUpArriveMoveOffsets = std::move(InUpArriveMoveOffsets);
	Parms.InHeightMins = std::move(InHeightMins);
	Parms.InHeightMaxs = std::move(InHeightMaxs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.NeedFollowHangOnStartingClimb
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::NeedFollowHangOnStartingClimb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "NeedFollowHangOnStartingClimb");

	Params::KuroClimbObject_NeedFollowHangOnStartingClimb Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.ProcessClimbing
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsTryMove                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::ProcessClimbing(const struct FVector& MoveSpeed, float DeltaTime, bool IsTryMove, float DebugDrawDuration, struct FTransform* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "ProcessClimbing");

	Params::KuroClimbObject_ProcessClimbing Parms{};

	Parms.MoveSpeed = std::move(MoveSpeed);
	Parms.DeltaTime = DeltaTime;
	Parms.IsTryMove = IsTryMove;
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.SyncFromOther
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UKuroClimbObject*                 Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroClimbObject::SyncFromOther(class UKuroClimbObject* Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "SyncFromOther");

	Params::KuroClimbObject_SyncFromOther Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroClimbObject.TryClimbingArrives
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InputDirect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    NeedTryBlockUp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EClimbingArriveType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClimbingArriveType UKuroClimbObject::TryClimbingArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans, bool NeedTryBlockUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "TryClimbingArrives");

	Params::KuroClimbObject_TryClimbingArrives Parms{};

	Parms.InputDirect = std::move(InputDirect);
	Parms.DebugDrawDuration = DebugDrawDuration;
	Parms.NeedTryBlockUp = NeedTryBlockUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.TrySprintVault
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OutLongOffset                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESprintVaultType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESprintVaultType UKuroClimbObject::TrySprintVault(float DebugDrawDuration, struct FTransform* OutTrans, float* OutLongOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "TrySprintVault");

	Params::KuroClimbObject_TrySprintVault Parms{};

	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	if (OutLongOffset != nullptr)
		*OutLongOffset = Parms.OutLongOffset;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.TryStartClimb
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Trans                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroClimbObject::TryStartClimb(const struct FTransform& Trans, float DebugDrawDuration, struct FTransform* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "TryStartClimb");

	Params::KuroClimbObject_TryStartClimb Parms{};

	Parms.Trans = std::move(Trans);
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroClimbObject.TryUpArrives
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InputDirect                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTrans                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EClimbingArriveType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EClimbingArriveType UKuroClimbObject::TryUpArrives(const struct FVector& InputDirect, float DebugDrawDuration, struct FTransform* OutTrans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroClimbObject", "TryUpArrives");

	Params::KuroClimbObject_TryUpArrives Parms{};

	Parms.InputDirect = std::move(InputDirect);
	Parms.DebugDrawDuration = DebugDrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTrans != nullptr)
		*OutTrans = std::move(Parms.OutTrans);

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.KuroDebugMovementBaseRecordToString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FBaseRecord                      Record                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroDebugMovementComponent::KuroDebugMovementBaseRecordToString(const struct FBaseRecord& Record)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroDebugMovementComponent", "KuroDebugMovementBaseRecordToString");

	Params::KuroDebugMovementComponent_KuroDebugMovementBaseRecordToString Parms{};

	Parms.Record = std::move(Record);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.GetFrameCountInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UKuroDebugMovementComponent::GetFrameCountInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "GetFrameCountInfo");

	Params::KuroDebugMovementComponent_GetFrameCountInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.GetRecentRecords
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FSingleFrameDebugInfo>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FSingleFrameDebugInfo> UKuroDebugMovementComponent::GetRecentRecords()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "GetRecentRecords");

	Params::KuroDebugMovementComponent_GetRecentRecords Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroDebugMovementComponent.RecordModifyInfo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           Context                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CustomVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKDMRecordType                          Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroDebugMovementComponent::RecordModifyInfo(const class FString& Context, const struct FVector& CustomVector, EKDMRecordType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "RecordModifyInfo");

	Params::KuroDebugMovementComponent_RecordModifyInfo Parms{};

	Parms.Context = std::move(Context);
	Parms.CustomVector = std::move(CustomVector);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroDebugMovementComponent.Resigter
// (Final, Native, Public, BlueprintCallable)

void UKuroDebugMovementComponent::Resigter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "Resigter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroDebugMovementComponent.SetDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDetial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKuroDebugMovementComponent::SetDebug(bool bDebug, bool bDetial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "SetDebug");

	Params::KuroDebugMovementComponent_SetDebug Parms{};

	Parms.bDebug = bDebug;
	Parms.bDetial = bDetial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroDebugMovementComponent.UnResigter
// (Final, Native, Public, BlueprintCallable)

void UKuroDebugMovementComponent::UnResigter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroDebugMovementComponent", "UnResigter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMoveTrigger.OnEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKuroMoveTrigger::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMoveTrigger", "OnEndOverlap");

	Params::KuroMoveTrigger_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMoveTrigger.OnEnterOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AKuroMoveTrigger::OnEnterOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMoveTrigger", "OnEnterOverlap");

	Params::KuroMoveTrigger_OnEnterOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMovementBPLibrary.KuroSoar
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCharacterMovementComponent*      CharMoveComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AirFriction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Aerodynamics                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Gravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SoarPlaneNormal                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKuroMovementBPLibrary::KuroSoar(float DeltaSeconds, class UCharacterMovementComponent* CharMoveComp, float AirFriction, float Aerodynamics, const struct FVector& Gravity, const struct FVector& SoarPlaneNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMovementBPLibrary", "KuroSoar");

	Params::KuroMovementBPLibrary_KuroSoar Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.CharMoveComp = CharMoveComp;
	Parms.AirFriction = AirFriction;
	Parms.Aerodynamics = Aerodynamics;
	Parms.Gravity = std::move(Gravity);
	Parms.SoarPlaneNormal = std::move(SoarPlaneNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function KuroMovement.KuroMoveTriggerController.RegisterController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AKuroMoveTriggerController*       ControllerPtr                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKuroMoveTriggerController::RegisterController(class AKuroMoveTriggerController* ControllerPtr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMoveTriggerController", "RegisterController");

	Params::KuroMoveTriggerController_RegisterController Parms{};

	Parms.ControllerPtr = ControllerPtr;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMoveTriggerController.UnRegisterController
// (Final, Native, Static, Public, BlueprintCallable)

void AKuroMoveTriggerController::UnRegisterController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("KuroMoveTriggerController", "UnRegisterController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function KuroMovement.KuroMoveTriggerController.InitAllTriggers
// (Final, Native, Public, BlueprintCallable)

void AKuroMoveTriggerController::InitAllTriggers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KuroMoveTriggerController", "InitAllTriggers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

